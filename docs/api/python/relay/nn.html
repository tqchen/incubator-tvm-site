

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>tvm.relay.nn &mdash; tvm 0.7.dev1 documentation</title>
  

  
  
    <link rel="shortcut icon" href="../../../_static/tvm-logo-square.png"/>
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/tvm_theme.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="tvm.relay.op" href="op.html" />
    <link rel="prev" title="tvm.relay.transform" href="transform.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/tvm-logo-small.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.7.dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../vta/index.html">VTA: Deep Learning Accelerator Stack</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../deploy/index.html">Deploy and Integration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contribute to TVM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">Frequently Asked Questions</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../langref/index.html">Language Reference</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Python API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../runtime.html">tvm.runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ndarray.html">tvm.runtime.ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="../error.html">tvm.error</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ir.html">tvm.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../target.html">tvm.target</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html">tvm.tir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tir.html#module-tvm.tir.transform">tvm.tir.transform</a></li>
<li class="toctree-l2"><a class="reference internal" href="../te.html">tvm.te</a></li>
<li class="toctree-l2"><a class="reference internal" href="../driver.html">tvm.driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../autotvm.html">tvm.autotvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rpc.html">tvm.rpc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../contrib.html">tvm.contrib</a></li>
<li class="toctree-l2"><a class="reference internal" href="../graph_runtime.html">tvm.contrib.graph_runtime</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hybrid.html">tvm.hybrid</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">tvm.relay</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="analysis.html">tvm.relay.analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="backend.html">tvm.relay.backend</a></li>
<li class="toctree-l3"><a class="reference internal" href="frontend.html">tvm.relay.frontend</a></li>
<li class="toctree-l3"><a class="reference internal" href="image.html">tvm.relay.image</a></li>
<li class="toctree-l3"><a class="reference internal" href="transform.html">tvm.relay.transform</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">tvm.relay.nn</a></li>
<li class="toctree-l3"><a class="reference internal" href="op.html">tvm.relay.op</a></li>
<li class="toctree-l3"><a class="reference internal" href="vision.html">tvm.relay.vision</a></li>
<li class="toctree-l3"><a class="reference internal" href="testing.html">tvm.relay.testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../vta/index.html">vta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../topi.html">topi</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_links.html">Links to API References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Design and Developer Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../frontend/tensorflow.html">TensorFlow Frontend</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">tvm</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Python API</a> &raquo;</li>
        
          <li><a href="index.html">tvm.relay</a> &raquo;</li>
        
      <li>tvm.relay.nn</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../../_sources/api/python/relay/nn.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-tvm.relay.op.nn.nn">
<span id="tvm-relay-nn"></span><h1>tvm.relay.nn<a class="headerlink" href="#module-tvm.relay.op.nn.nn" title="Permalink to this headline">¶</a></h1>
<p>Neural network operations.</p>
<dl class="class">
<dt id="tvm.relay.op.nn.nn.TupleWrapper">
<em class="property">class </em><code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">TupleWrapper</code><span class="sig-paren">(</span><em class="sig-param">tuple_value</em>, <em class="sig-param">size</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.TupleWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>TupleWrapper.</p>
<p>This class is a Python wrapper for a Relay tuple of known size.
It allows for accessing the fields of the Relay tuple as though
it were a Python tuple.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tuple_value</strong> (<em>tvm.relay.Expr</em>) – The input tuple</p></li>
<li><p><strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The size of the tuple.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="tvm.relay.op.nn.nn.TupleWrapper.astuple">
<code class="sig-name descname">astuple</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.TupleWrapper.astuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the underlying Relay tuple if this wrapper is passed
as an argument to an FFI function.</p>
</dd></dl>

<dl class="method">
<dt id="tvm.relay.op.nn.nn.TupleWrapper.astext">
<code class="sig-name descname">astext</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.TupleWrapper.astext" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the text format of the tuple expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>text</strong> – The text format of the tuple expression.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)">str</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.get_pad_tuple2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">get_pad_tuple2d</code><span class="sig-paren">(</span><em class="sig-param">padding</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.get_pad_tuple2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Common code to get the pad option
:param padding: Padding size
:type padding: Union[int, Tuple[int, …]]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>pad_top</strong> (<em>int</em>) – Padding size on top</p></li>
<li><p><strong>pad_left</strong> (<em>int</em>) – Padding size on left</p></li>
<li><p><strong>pad_down</strong> (<em>int</em>) – Padding size on down.</p></li>
<li><p><strong>pad_right</strong> (<em>int</em>) – Padding size on right.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.conv1d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">conv1d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=1</em>, <em class="sig-param">padding=0</em>, <em class="sig-param">dilation=1</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCW'</em>, <em class="sig-param">kernel_layout='OIW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.conv1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
and kernel_layout is <cite>OIW</cite>, conv1d takes in
a data Tensor with shape <cite>(batch_size, in_channels, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size)</cite>
to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, w] = \sum_{dw, k}
   \mbox{data}[b, k, \mbox{strides}[0] * w + dw] *
   \mbox{weight}[c, k, dw]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCW</cite> for data and <cite>OIW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of the input before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Currently unused for 1D convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial dimension of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.conv2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">conv2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
and kernel_layout is <cite>OIHW</cite>, conv2d takes in
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size[0], kernel_size[1])</cite>
to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, y, x] = \sum_{dy, dx, k}
   \mbox{data}[b, k, \mbox{strides}[0] * y  + dy, \mbox{strides}[1] * x + dx] *
   \mbox{weight}[c, k, dy, dx]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCHW</cite> for data and <cite>OIHW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.conv3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">conv3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCDHW'</em>, <em class="sig-param">kernel_layout='OIDHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.conv3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
and kernel_layout is <cite>OIDHW</cite>, conv3d takes in
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
and a weight Tensor with shape <cite>(channels, in_channels, kernel_size[0], kernel_size[1],
kernel_size[2])</cite> to produce an output Tensor with the following rule:</p>
<div class="math notranslate nohighlight">
\[\mbox{out}[b, c, z, y, x] = \sum_{dz, dy, dx, k}
   \mbox{data}[b, k, \mbox{strides}[0] * z  + dz, \mbox{strides}[1] * y  + dy,
   \mbox{strides}[2] * x + dx] * \mbox{weight}[c, k, dz, dy, dx]\]</div>
<p>Padding and dilation are applied to data and weight respectively before the computation.
This operator accepts data layout specification.
Semantically, the operator will convert the layout to the canonical layout
(<cite>NCDHW</cite> for data and <cite>OIDHW</cite> for weight), perform the computation,
then convert to the out_layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>]</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.conv2d_transpose">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">conv2d_transpose</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">output_padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.conv2d_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Two dimensional transposed convolution operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs.</p></li>
<li><p><strong>dilation</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>output_padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Additional zero-padding to be added to one side of the output.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.conv1d_transpose">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">conv1d_transpose</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCW'</em>, <em class="sig-param">kernel_layout='OIW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">output_padding=(0</em>, <em class="sig-param">)</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.conv1d_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>One dimensional transposed convolution operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs.</p></li>
<li><p><strong>dilation</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>]</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>output_padding</strong> (<a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple"><em>Tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>]</em><em>, </em><em>optional</em>) – Additional zero-padding to be added to one side of the output.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.softmax">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">softmax</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes softmax.</p>
<div class="math notranslate nohighlight">
\[\text{softmax}(x)_i = \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The axis to sum over when computing softmax</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.log_softmax">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">log_softmax</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">axis=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.log_softmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes log softmax.</p>
<div class="math notranslate nohighlight">
\[\text{log_softmax}(x)_i = \log \frac{exp(x_i)}{\sum_j exp(x_j)}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The axis to sum over when computing softmax</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.max_pool1d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">max_pool1d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">)</em>, <em class="sig-param">layout='NCW'</em>, <em class="sig-param">ceil_mode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.max_pool1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D maximum pooling operator.</p>
<p>This operator takes data as input and does 1D max value calculation
with in pool_size sized window by striding defined by stride.</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
a data Tensor with shape <cite>(batch_size, channels, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.max_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">max_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">ceil_mode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D maximum pooling operator.</p>
<p>This operator takes data as input and does 2D max value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w) and pool_size (kh, kw)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, y, x)  = \max_{m=0, \ldots, kh-1} \max_{n=0, \ldots, kw-1}
     \mbox{data}(b, c, \mbox{stride}[0] * y + m, \mbox{stride}[1] * x + n)\]</div>
<p>Padding is applied to data before the computation.
ceil_mode is used to take ceil or floor while computing out shape.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.max_pool3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">max_pool3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCDHW'</em>, <em class="sig-param">ceil_mode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.max_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D maximum pooling operator.</p>
<p>This operator takes data as input and does 3D max value calculation
with in pool_size sized window by striding defined by stride.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, channels, depth, height, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.avg_pool1d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">avg_pool1d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">)</em>, <em class="sig-param">layout='NCW'</em>, <em class="sig-param">ceil_mode=False</em>, <em class="sig-param">count_include_pad=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.avg_pool1d" title="Permalink to this definition">¶</a></dt>
<dd><p>1D average pooling operator.</p>
<p>This operator takes data as input and does 1D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCW</cite>
a data Tensor with shape <cite>(batch_size, channels, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em> or </em><em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">ceil_mode=False</em>, <em class="sig-param">count_include_pad=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D average pooling operator.</p>
<p>This operator takes data as input and does 2D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w), pool_size (kh, kw)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, y, x)  = \frac{1}{kh * kw} \sum_{m=0}^{kh-1} \sum_{n=0}^{kw-1}
     \mbox{data}(b, c, \mbox{stride}[0] * y + m, \mbox{stride}[1] * x + n)\]</div>
<p>Padding is applied to data before the computation.
ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.avg_pool3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">avg_pool3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCDHW'</em>, <em class="sig-param">ceil_mode=False</em>, <em class="sig-param">count_include_pad=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.avg_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D average pooling operator.</p>
<p>This operator takes data as input and does 3D average value calculation
with in pool_size sized window by striding defined by stride</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, channels, depth, height, width)</cite>,
to produce an output Tensor.</p>
<p>The ceil_mode is used to take ceil or floor while computing out shape.
count_include_pad indicates including or excluding padded input values in computation.
This operator accepts data layout specification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.max_pool2d_grad">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">max_pool2d_grad</code><span class="sig-paren">(</span><em class="sig-param">out_grad</em>, <em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">ceil_mode=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.max_pool2d_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of 2D maximum pooling operator.</p>
<p>This operator takes out_grad and data as input and calculates gradient of max_pool2d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out_grad</strong> (<em>tvm.relay.Expr</em>) – The output gradient</p></li>
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.avg_pool2d_grad">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">avg_pool2d_grad</code><span class="sig-paren">(</span><em class="sig-param">out_grad</em>, <em class="sig-param">data</em>, <em class="sig-param">pool_size=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">ceil_mode=False</em>, <em class="sig-param">count_include_pad=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.avg_pool2d_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Gradient of 2D average pooling operator.</p>
<p>This operator takes out_grad and data as input and calculates gradient of avg_pool2d.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>out_grad</strong> (<em>tvm.relay.Expr</em>) – The output gradient</p></li>
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of pooling.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding for pooling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>ceil_mode</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To enable or disable ceil while pooling.</p></li>
<li><p><strong>count_include_pad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – To include padding to compute the average.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.global_max_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">global_max_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">layout='NCHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.global_max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D global maximum pooling operator.</p>
<p>This operator takes data as input and does 2D max value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, 1, 1)  = \max_{m=0, \ldots, h} \max_{n=0, \ldots, w}
     \mbox{data}(b, c, m, n)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.global_avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">global_avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">layout='NCHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.global_avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D global average pooling operator.</p>
<p>This operator takes data as input and does 2D average value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with the following rule:</p>
<p>with data of shape (b, c, h, w)</p>
<div class="math notranslate nohighlight">
\[\mbox{out}(b, c, 1, 1)  = \frac{1}{h * w} \sum_{m=0}^{h-1} \sum_{n=0}^{w-1}
     \mbox{data}(b, c, m, n)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.upsampling">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">upsampling</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">scale_h=1</em>, <em class="sig-param">scale_w=1</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">method='nearest_neighbor'</em>, <em class="sig-param">align_corners=False</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.upsampling" title="Permalink to this definition">¶</a></dt>
<dd><p>Upsampling.</p>
<p>This operator takes data as input and does 2D scaling to the given scale factor.
In the default case, where the data_layout is <cite>NCHW</cite>
with data of shape (n, c, h, w)
out will have a shape (n, c, h*scale_h, w*scale_w)</p>
<p>method indicates the algorithm to be used while calculating the out value
and method can be one of (“bilinear”, “nearest_neighbor”, “bicubic”)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>scale_h</strong> (<em>tvm.relay.Expr</em>) – The scale factor for height upsampling.</p></li>
<li><p><strong>scale_w</strong> (<em>tvm.relay.Expr</em>) – The scale factor for width upsampling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Scale method to used [nearest_neighbor, bilinear, bicubic].</p></li>
<li><p><strong>align_corners</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to keep corners in proper place.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.upsampling3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">upsampling3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">scale_d=1</em>, <em class="sig-param">scale_h=1</em>, <em class="sig-param">scale_w=1</em>, <em class="sig-param">layout='NCDHW'</em>, <em class="sig-param">method='nearest_neighbor'</em>, <em class="sig-param">coordinate_transformation_mode='half_pixel'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.upsampling3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D Upsampling.</p>
<p>This operator takes data as input and does 3D scaling to the given scale factor.
In the default case, where the data_layout is <cite>NCDHW</cite>
with data of shape (n, c, d, h, w)
out will have a shape (n, c, d*scale_d, h*scale_h, w*scale_w)</p>
<p>method indicates the algorithm to be used while calculating the out value
and method can be one of (“trilinear”, “nearest_neighbor”)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>scale_d</strong> (<em>tvm.relay.Expr</em>) – The scale factor for depth upsampling.</p></li>
<li><p><strong>scale_h</strong> (<em>tvm.relay.Expr</em>) – The scale factor for height upsampling.</p></li>
<li><p><strong>scale_w</strong> (<em>tvm.relay.Expr</em>) – The scale factor for width upsampling.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Scale method to used [nearest_neighbor, trilinear].</p></li>
<li><p><strong>coordinate_transformation_mode</strong> (<em>string</em><em>, </em><em>optional</em>) – Describes how to transform the coordinate in the resized tensor
to the coordinate in the original tensor.
Refer to the ONNX Resize operator specification for details.
Available options are “half_pixel”, “align_corners” and “asymmetric”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.batch_flatten">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">batch_flatten</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.batch_flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>BatchFlatten.</p>
<p>This operator flattens all the dimensions except for the batch dimension.
which results a 2D output.</p>
<p>For data with shape <code class="docutils literal notranslate"><span class="pre">(d1,</span> <span class="pre">d2,</span> <span class="pre">...,</span> <span class="pre">dk)</span></code>
batch_flatten(data) returns reshaped output of shape <code class="docutils literal notranslate"><span class="pre">(d1,</span> <span class="pre">d2*...*dk)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The Flattened result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.bias_add">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">bias_add</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">bias</em>, <em class="sig-param">axis=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.bias_add" title="Permalink to this definition">¶</a></dt>
<dd><p>add_bias operator.</p>
<p>Add 1D bias to the axis of data.
This function is a special case of add which allows
inference of shape of the bias from data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>bias</strong> (<em>tvm.relay.Expr</em>) – The bias to be added.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The axis to add the bias.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The final result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.dense">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">dense</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">units=None</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense operator.
Applies a linear transformation</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p><cite>Y = X * W</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>units</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of hidden units of the dense transformation.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision dense.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.fifo_buffer">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">fifo_buffer</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">buffer</em>, <em class="sig-param">axis</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.fifo_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>FIFO buffer to enable computation reuse in CNNs with sliding indow input</p>
<p>Compute equivalent of</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">concat</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
<span class="o">.</span><span class="n">slice_axis</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">begin</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
            <span class="n">end</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">+</span><span class="nb">buffer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
</pre></div>
</div>
<p>Useful for</p>
<ul class="simple">
<li><p>Encoding explicit re-use of computation in convolution ops operated on a sliding window input</p></li>
<li><p>Implementing a FIFO queue to cache intermediate results, e.g. as in Fast WaveNet.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data</p></li>
<li><p><strong>buffer</strong> (<em>tvm.relay.Expr</em>) – Previous value of the FIFO buffer</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Specify which axis should be used for buffering</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Updated value for the buffer</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.relu">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">relu</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.relu" title="Permalink to this definition">¶</a></dt>
<dd><p>Rectified linear unit.</p>
<div class="math notranslate nohighlight">
\[out = max(x, 0)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.leaky_relu">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">leaky_relu</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">alpha</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.leaky_relu" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does Leaky version
of a Rectified Linear Unit.</p>
<div class="math notranslate nohighlight">
\[`y = x &gt; 0 ? x : alpha * x`\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – Slope coefficient for the negative half axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.prelu">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">prelu</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">alpha</em>, <em class="sig-param">axis=1</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.prelu" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does Leaky version
of a Rectified Linear Unit.</p>
<div class="math notranslate nohighlight">
\[`y = x &gt; 0 ? x : alpha * x`\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>alpha</strong> (<em>tvm.relay.Expr</em>) – Slope coefficient for the negative half axis.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Specify which shape axis the channel is specified.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.pad">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">pad</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pad_width</em>, <em class="sig-param">pad_value=0.0</em>, <em class="sig-param">pad_mode='constant'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Padding</p>
<p>This operator takes in a tensor and pads each axis by the specified
widths using the specified value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator</p></li>
<li><p><strong>pad_width</strong> (<em>tuple of &lt;tuple of &lt;int&gt;&gt;</em><em>, </em><em>required</em>) – Number of values padded to the edges of each axis, in the format
of ((before_1, after_1), …, (before_N, after_N))</p></li>
<li><p><strong>pad_value</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em>, </em><em>default=0.0</em>) – The value used for padding</p></li>
<li><p><strong>pad_mode</strong> (<em>'constant'</em><em>, </em><em>'edge'</em><em>, </em><em>'reflect'</em>) – ‘constant’ pads with constant_value pad_value
‘edge’ pads using the edge values of the input array
‘reflect’ pads by reflecting values with respect to the edge</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.mirror_pad">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">mirror_pad</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">pad_width</em>, <em class="sig-param">mode='SYMMETRIC'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.mirror_pad" title="Permalink to this definition">¶</a></dt>
<dd><p>MirrorPadding</p>
<p>This operator takes in a tensor and pads each axis by the specified
widths using mirroring of the border pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator</p></li>
<li><p><strong>pad_width</strong> (<em>tuple of &lt;tuple of &lt;int&gt;&gt;</em><em>, </em><em>required</em>) – Number of values padded to the edges of each axis, in the format
of ((before_1, after_1), …, (before_N, after_N))</p></li>
<li><p><strong>mode</strong> (<em>string</em><em>, </em><em>optional</em><em>, </em><em>default='SYMMETRIC'</em>) – What type of mirroring to use, must be SYMMETRIC or REFLECT.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.lrn">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">lrn</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">size=5</em>, <em class="sig-param">axis=1</em>, <em class="sig-param">bias=2</em>, <em class="sig-param">alpha=1e-05</em>, <em class="sig-param">beta=0.75</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.lrn" title="Permalink to this definition">¶</a></dt>
<dd><p>This operator takes data as input and does local response normalization.</p>
<p>Normalize the input in a local region across or within feature maps.
Each input value is divided by (data / (bias + (alpha * sum_data ^2 /size))^beta)
where n is the size of each local region, and the sum is taken over the region
centered at that value (zero padding is added where necessary).</p>
<div class="math notranslate nohighlight">
\[(data / (bias + (alpha * sum_data ^2 /size))^beta)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – The size of the local region to be considered for normalization.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Input data layout channel axis. Default value is 1 for NCHW format</p></li>
<li><p><strong>bias</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The offset parameter to avoid dividing by 0.</p></li>
<li><p><strong>alpha</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The scaling parameter.</p></li>
<li><p><strong>beta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em>) – The exponent parameter.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.l2_normalize">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">l2_normalize</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">eps</em>, <em class="sig-param">axis=None</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.l2_normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform L2 normalization on the input data</p>
<div class="math notranslate nohighlight">
\[y(i, j) = x(i, j) / sqrt(max(sum(x^2), eps))\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a>) – epsilon value</p></li>
<li><p><strong>axis</strong> (<em>list of int</em><em>, </em><em>optional</em>) – axis over the normalization applied</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.dropout">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">dropout</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">rate=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the dropout operation to the input array.</p>
<p>During training, each element of the input is set to zero with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. The whole array is rescaled by <code class="docutils literal notranslate"><span class="pre">1/(1-p)</span></code>
to keep the expected sum of the input unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – The probability for an element to be reset to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The result of dropout</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.dropout_raw">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">dropout_raw</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">rate=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.dropout_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the dropout operation to the input array.</p>
<p>During training, each element of the input is set to zero with
probability <code class="docutils literal notranslate"><span class="pre">p</span></code>. The whole array is rescaled by <code class="docutils literal notranslate"><span class="pre">1/(1-p)</span></code>
to keep the expected sum of the input unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>rate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.8)"><em>float</em></a><em>, </em><em>optional</em><em> (</em><em>default=0.5</em><em>)</em>) – The probability for an element to be reset to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The result of dropout</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.batch_norm">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">batch_norm</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">gamma</em>, <em class="sig-param">beta</em>, <em class="sig-param">moving_mean</em>, <em class="sig-param">moving_var</em>, <em class="sig-param">axis=1</em>, <em class="sig-param">epsilon=1e-05</em>, <em class="sig-param">center=True</em>, <em class="sig-param">scale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.batch_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch normalization layer (Ioffe and Szegedy, 2014).
Normalizes the input at each batch, i.e. applies a transformation
that maintains the mean activation close to 0 and the activation
standard deviation close to 1.</p>
<div class="math notranslate nohighlight">
\[\begin{split}data\_mean[i] = mean(data[:,i,:,...]) \\
data\_var[i] = var(data[:,i,:,...])\end{split}\]</div>
<p>Then compute the normalized output, which has the same shape as input, as following:</p>
<div class="math notranslate nohighlight">
\[out[:,i,:,...] = \frac{data[:,i,:,...] - data\_mean[i]}{\sqrt{data\_var[i]+\epsilon}}
    * gamma[i] + beta[i]\]</div>
<p>Both <em>mean</em> and <em>var</em> returns a scalar by treating the input as a vector.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal notranslate"><span class="pre">gamma</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>
have shape <em>(k,)</em>.</p>
<p>Besides the inputs and the outputs, this operator accepts two auxiliary
states, <code class="docutils literal notranslate"><span class="pre">moving_mean</span></code> and <code class="docutils literal notranslate"><span class="pre">moving_var</span></code>, which are <em>k</em>-length
vectors. They are global statistics for the whole dataset, which are updated by</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span class="n">moving_mean</span> <span class="o">=</span> <span class="n">moving_mean</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_mean</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
<span class="n">moving_var</span> <span class="o">=</span> <span class="n">moving_var</span> <span class="o">*</span> <span class="n">momentum</span> <span class="o">+</span> <span class="n">data_var</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">momentum</span><span class="p">)</span>
</pre></div>
</div>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’ (separately normalized groups).  The default is 1.
Specifying -1 sets the channel axis to be the last item in the input shape.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which batch_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>moving_mean</strong> (<em>tvm.relay.Expr</em>) – Running mean of input,</p></li>
<li><p><strong>moving_var</strong> (<em>tvm.relay.Expr</em>) – Running variance of input.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Specify along which shape axis the channel is specified.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If true, multiply by gamma. If False, gamma is not used.
When the next layer is piecewise linear (also e.g. nn.relu),
this can be disabled since the scaling will be done by the next layer.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Tuple of normed data (same shape as input),
new running mean (k-length vector),
and new running variance (k-length vector)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple">relay.Tuple</a>([tvm.relay.Expr, tvm.relay.Expr, tvm.relay.Expr])</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.instance_norm">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">instance_norm</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">gamma</em>, <em class="sig-param">beta</em>, <em class="sig-param">axis=1</em>, <em class="sig-param">epsilon=1e-05</em>, <em class="sig-param">center=True</em>, <em class="sig-param">scale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.instance_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance Normalization (Ulyanov and et al., 2016)
Applies instance normalization to the n-dimensional input array.</p>
<div class="math notranslate nohighlight">
\[out = \frac{data - mean(data)}{\sqrt{var(data)+\epsilon}}
    * gamma + beta\]</div>
<p>The instance normalization is similar to batch normalization, but unlike
batch normalization, the mean and var are calculated per-dimension
separately for each object(instance) in a mini-batch, not over a batch.
And the same normalization is applied both at test and train time.</p>
<p>Assume the input has size <em>k</em> on axis 1, then both <code class="docutils literal notranslate"><span class="pre">gamma</span></code> and <code class="docutils literal notranslate"><span class="pre">beta</span></code>
have shape <em>(k,)</em>.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code> specifies which axis of the input shape denotes
the ‘channel’.  The default is 1. Specifying -1 sets the channel axis
to be the last item in the input shape.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which instance_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=1</em>) – Specify along which shape axis the channel is specified.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, multiply by gamma. If False, gamma is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>result</strong> (<em>tvm.relay.Expr</em>) – The normalized data.</p></li>
<li><p><strong>.. _`Instance Normalization</strong> (The Missing Ingredient for Fast Stylization`:) – <a class="reference external" href="https://arxiv.org/abs/1607.08022">https://arxiv.org/abs/1607.08022</a></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.layer_norm">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">layer_norm</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">gamma</em>, <em class="sig-param">beta</em>, <em class="sig-param">axis=-1</em>, <em class="sig-param">epsilon=1e-05</em>, <em class="sig-param">center=True</em>, <em class="sig-param">scale=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.layer_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Layer normalization (Lei Ba and et al., 2016).
Applies layer normalization to the n-dimensional input array.
This operator takes an n-dimensional input array and normalizes
the input using the given axis:</p>
<div class="math notranslate nohighlight">
\[out = \frac{data - mean(data, axis)}{\sqrt{var(data, axis)+\epsilon}}
    * gamma + beta\]</div>
<p>Unlike batch normalization, the mean and var are computed along the channel dimension.</p>
<p>Assume the input has size k on axis 1, then both gamma and beta have shape (k,).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This operator can be optimized away for inference.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input to which layer_norm will be applied.</p></li>
<li><p><strong>gamma</strong> (<em>tvm.relay.Expr</em>) – The gamma scale factor.</p></li>
<li><p><strong>beta</strong> (<em>tvm.relay.Expr</em>) – The beta offset factor.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em><em>, </em><em>default=-1</em>) – The axis that should be normalized, typically the axis of the channels.</p></li>
<li><p><strong>epsilon</strong> (<em>double</em><em>, </em><em>optional</em><em>, </em><em>default=1e-5</em>) – Small float added to variance to avoid dividing by zero.</p></li>
<li><p><strong>center</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, add offset of beta to normalized tensor, If False,
beta is ignored.</p></li>
<li><p><strong>scale</strong> (<em>boolean</em><em>, </em><em>optional</em><em>, </em><em>default=True</em>) – If True, multiply by gamma. If False, gamma is not used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The normalized data.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.batch_matmul">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">batch_matmul</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">y</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.batch_matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes batch matrix multiplication of <cite>x</cite> and <cite>y</cite> when <cite>x</cite> and <cite>y</cite> are data
in batch.</p>
<div class="math notranslate nohighlight">
\[\mbox{batch_matmul}(x, y)[i, :, :] = \mbox{matmul}(x[i, :, :], y[i, :, :]^T)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>tvm.relay.Expr</em>) – The first input.</p></li>
<li><p><strong>y</strong> (<em>tvm.relay.Expr</em>) – The second input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.sparse_dense">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">sparse_dense</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.sparse_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the matrix multiplication of <cite>data</cite> and <cite>weight</cite>, where <cite>data</cite> is
a dense matrix and <cite>weight</cite> is a sparse (either BSR or CSR) namedtuple with
fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>.</p>
<div class="math notranslate nohighlight">
\[\mbox{sparse_dense}(data, weight)[m, n] = \mbox{matmul}(x, \mbox{as_dense}(weight)^T)[m, n]\]</div>
<p>where <cite>as_dense</cite> returns dense equivalent of the given sparse matrix.</p>
<p>See
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html</a>
and
<a class="reference external" href="https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.bsr_matrix.html">https://docs.scipy.org/doc/scipy-0.14.0/reference/generated/scipy.sparse.bsr_matrix.html</a>
for more detail on the sparse matrix representation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data for the matrix multiplication</p></li>
<li><p><strong>weight</strong> (<em>namedtuple.</em>) – The sparse weight matrix for the matrix multiplication.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.sparse_transpose">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">sparse_transpose</code><span class="sig-paren">(</span><em class="sig-param">x</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.sparse_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the fast matrix transpose of x,
where x is a sparse tensor in CSR format (represented as a namedtuple
with fields <cite>data</cite>, <cite>indices</cite>, and <cite>indptr</cite>).</p>
<p>** Currently only support Square Matrices **</p>
<div class="math notranslate nohighlight">
\[\mbox{sparse_transpose}(x)[n, n] = (x^T)[n, n]\]</div>
<p>Please refer to <a class="reference external" href="https://github.com/scipy/scipy/blob/v1.3.0/scipy/sparse/csr.py">https://github.com/scipy/scipy/blob/v1.3.0/scipy/sparse/csr.py</a>
for the algorithm implemented in this operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>x</strong> (<em>namedtuple.</em>) – The sparse weight matrix for the fast matrix transpose.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – Tuple of output sparse tensor (same shape and format as input),
i.e. if CSR then output is in ([data, indices, indptr]) form</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="index.html#tvm.relay.Tuple" title="tvm.relay.Tuple">relay.Tuple</a>([tvm.relay.Expr, tvm.relay.Expr, tvm.relay.Expr])</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.contrib_conv2d_winograd_without_weight_transform">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_without_weight_transform</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">tile_size</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.contrib_conv2d_winograd_without_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution with winograd algorithm.</p>
<p>The basic parameters are the same as the ones in vanilla conv2d.
It assumes the weight is pre-transformed by nn.contrib_conv2d_winograd_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.contrib_conv2d_nchwc">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">contrib_conv2d_nchwc</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">kernel</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW8c'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.contrib_conv2d_nchwc" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of 2D convolution.</p>
<p>This operator takes the weight as the convolution kernel
and convolves it with data to produce an output, following a specialized
NCHWc data layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>kernel</strong> (<em>tvm.relay.Expr</em>) – The kernel expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.contrib_depthwise_conv2d_nchwc">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">contrib_depthwise_conv2d_nchwc</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">kernel</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW8c'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.contrib_depthwise_conv2d_nchwc" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of 2D depthwise convolution.</p>
<p>This operator takes the weight as the depthwise convolution kernel
and depthwise convolves it with data to produce an output, following a specialized
NCHWc data layout.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>kernel</strong> (<em>tvm.relay.Expr</em>) – The kernel expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.contrib_conv2d_winograd_weight_transform">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_weight_transform</code><span class="sig-paren">(</span><em class="sig-param">weight</em>, <em class="sig-param">tile_size</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.contrib_conv2d_winograd_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight Transformation part for 2D convolution with winograd algorithm.</p>
<p>We separate this as a single op to enable pre-compute for inference.
Use this together with nn.contrib_conv2d_winograd_without_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>tile_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.contrib_conv2d_winograd_nnpack_weight_transform">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">contrib_conv2d_winograd_nnpack_weight_transform</code><span class="sig-paren">(</span><em class="sig-param">weight</em>, <em class="sig-param">convolution_algorithm</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.contrib_conv2d_winograd_nnpack_weight_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Weight Transformation part for 2D convolution with winograd algorithm.</p>
<p>We separate this as a single op to enable pre-compute for inference.
Use this together with nn.contrib_conv2d_winograd_without_weight_transform</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>convolution_algorithm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – The Tile size of winograd. E.g. 2 for F(2x2, 3x3) and 4 for F(4x4, 3x3)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.deformable_conv2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">deformable_conv2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">offset</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">dilation=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">deformable_groups=1</em>, <em class="sig-param">groups=1</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=None</em>, <em class="sig-param">data_layout='NCHW'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">out_layout=''</em>, <em class="sig-param">out_dtype=''</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.deformable_conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Deformable 2d convolution.</p>
<p>The deformable convolution operation is described in <a class="reference external" href="https://arxiv.org/abs/1703.06211">https://arxiv.org/abs/1703.06211</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>offset</strong> (<em>tvm.relay.Expr</em>) – The offset expressions.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>dilation</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – Specifies the dilation rate to be used for dilated convolution.</p></li>
<li><p><strong>deformable_groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of deformable groups.</p></li>
<li><p><strong>groups</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of groups for grouped convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the weight.</p></li>
<li><p><strong>out_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the output, by default, out_layout is the same as data_layout</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.bitpack">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">bitpack</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">bits=1</em>, <em class="sig-param">pack_axis=1</em>, <em class="sig-param">bit_axis=2</em>, <em class="sig-param">pack_type='uint32'</em>, <em class="sig-param">name='BitPack'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.bitpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Tensor packing for bitserial operations.
The values along the input tensor’s pack_axis are quantized
and packed together into the specified pack_type in a new
bit axis.</p>
<p>For example, consider bitpacking with data to be a tensor with shape [1, 64, 128, 128],
pack_axis=1, bit_axis=4, pack_type=uint8, and bits=2. The output in this case will
be of shape [1, 8, 128, 128, 2]. The dimension of axis 1 has been reduced by a factor
of 8 since each value is packed into an 8-bit uint8. Axis 4 is now two bitplanes
representing the quantized value of the incoming data. The output tensor is now
ready to be used in a bitserial operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.expr</em>) – The incoming tensor to be packed.</p></li>
<li><p><strong>bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits that should be packed.</p></li>
<li><p><strong>pack_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Axis that should be decomposed and packed.</p></li>
<li><p><strong>bit_axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – New axis containing bitplane.</p></li>
<li><p><strong>pack_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a>) – Datatype to pack bits into.</p></li>
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Name of the operation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The packed tensor.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.bitserial_conv2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">bitserial_conv2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">strides=(1</em>, <em class="sig-param">1)</em>, <em class="sig-param">padding=(0</em>, <em class="sig-param">0)</em>, <em class="sig-param">channels=None</em>, <em class="sig-param">kernel_size=(3</em>, <em class="sig-param">3)</em>, <em class="sig-param">activation_bits=1</em>, <em class="sig-param">weight_bits=1</em>, <em class="sig-param">data_layout='NCHW'</em>, <em class="sig-param">kernel_layout='OIHW'</em>, <em class="sig-param">pack_dtype='uint32'</em>, <em class="sig-param">out_dtype='int16'</em>, <em class="sig-param">unipolar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.bitserial_conv2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D convolution using bitserial computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>strides</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The strides of convolution.</p></li>
<li><p><strong>padding</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The padding of convolution on both sides of inputs before convolution.</p></li>
<li><p><strong>channels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of output channels of this convolution.</p></li>
<li><p><strong>kernel_size</strong> (<em>tuple of int</em><em>, </em><em>optional</em>) – The spatial of the convolution kernel.</p></li>
<li><p><strong>activation_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits to pack for activations.</p></li>
<li><p><strong>weight_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits to pack for weights.</p></li>
<li><p><strong>data_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
<li><p><strong>kernel_layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the kernel</p></li>
<li><p><strong>pack_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Datatype to pack bits into.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision conv2d.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.bitserial_dense">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">bitserial_dense</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">weight</em>, <em class="sig-param">units=None</em>, <em class="sig-param">data_bits=1</em>, <em class="sig-param">weight_bits=1</em>, <em class="sig-param">pack_dtype='uint32'</em>, <em class="sig-param">out_dtype='int16'</em>, <em class="sig-param">unipolar=True</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.bitserial_dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitserial Dense operator.
Applies matrix multiplication of two quantized matrices
using a fast bitserial algorithm.</p>
<div class="math notranslate nohighlight">
\[\]</div>
<p><cite>Y = X * W</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>weight</strong> (<em>tvm.relay.Expr</em>) – The weight expressions.</p></li>
<li><p><strong>units</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a><em>, </em><em>optional</em>) – Number of hidden units of the dense transformation.</p></li>
<li><p><strong>data_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits incoming tensor should be packed with.</p></li>
<li><p><strong>weight_bits</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Number of bits weight tensor should be packed with.</p></li>
<li><p><strong>pack_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Datatype to pack individual bits into before computation.</p></li>
<li><p><strong>out_dtype</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Specifies the output data type for mixed precision dense.</p></li>
<li><p><strong>unipolar</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.8)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether to use unipolar or bipolar quantization for inputs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.cross_entropy">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">cross_entropy</code><span class="sig-paren">(</span><em class="sig-param">predictions</em>, <em class="sig-param">targets</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.cross_entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>CrossEntropy without logits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predictions</strong> (<em>tvm.relay.Expr</em>) – The predictions.</p></li>
<li><p><strong>targets</strong> (<em>tvm.relay.Expr</em>) – The targets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.cross_entropy_with_logits">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">cross_entropy_with_logits</code><span class="sig-paren">(</span><em class="sig-param">predictions</em>, <em class="sig-param">targets</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.cross_entropy_with_logits" title="Permalink to this definition">¶</a></dt>
<dd><p>CrossEntropy with logits.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>predictions</strong> (<em>tvm.relay.Expr</em>) – The predictions.</p></li>
<li><p><strong>targets</strong> (<em>tvm.relay.Expr</em>) – The targets.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.depth_to_space">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">depth_to_space</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">block_size</em>, <em class="sig-param">layout='NCHW'</em>, <em class="sig-param">mode='DCR'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.depth_to_space" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert channels into spatial blocks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input data with channels divisible by block_size**2</p></li>
<li><p><strong>block_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Size of blocks to convert channels into.</p></li>
<li><p><strong>layout</strong> (<em>string</em>) – One of NCHW or NHWC, indicates channel axis.</p></li>
<li><p><strong>mode</strong> (<em>string</em>) – One of DCR or CDR, indicates which order channels
are accessed in.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> –</p>
<dl class="simple">
<dt>Tensor with shape [in_batch, in_channel / block_size * block_size,</dt><dd><p>in_height * block_size, in_width * block_size]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.space_to_depth">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">space_to_depth</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">block_size</em>, <em class="sig-param">layout='NCHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.space_to_depth" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert spatial blocks into channels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – Input data with spatial dimensions divisible by block_size</p></li>
<li><p><strong>block_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.8)"><em>int</em></a>) – Size of blocks to decompose into channels.</p></li>
<li><p><strong>layout</strong> (<em>string</em>) – One of NCHW or NHWC, indicates channel axis.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p><strong>result</strong> –</p>
<dl class="simple">
<dt>Tensor with shape [in_batch, in_channel * block_size * block_size,</dt><dd><p>in_height / block_size, in_width / block_size]</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.adaptive_max_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">adaptive_max_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">output_size=None</em>, <em class="sig-param">layout='NCHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.adaptive_max_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D adaptive max pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 2D max value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input height and width will be used
as output height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size) for any input (NCHW).</p>
<p>If a tuple of integers (height, width) are provided for output_size,
the output size is (N x C x height x width) for any input (NCHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.adaptive_avg_pool2d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">adaptive_avg_pool2d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">output_size=None</em>, <em class="sig-param">layout='NCHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.adaptive_avg_pool2d" title="Permalink to this definition">¶</a></dt>
<dd><p>2D adaptive average pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 2D average value calculation
across each window represented by WxH.</p>
<p>In the default case, where the data_layout is <cite>NCHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input height and width will be used
as output height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size) for any input (NCHW).</p>
<p>If a tuple of integers (height, width) are provided for output_size,
the output size is (N x C x height x width) for any input (NCHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.adaptive_max_pool3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">adaptive_max_pool3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">output_size=None</em>, <em class="sig-param">layout='NCDHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.adaptive_max_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D adaptive max pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 3D max value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_depth, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input depth, height and width will be used
as output depth, height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size x output_size) for any input (NCDHW).</p>
<p>If a tuple of integers (depth, height, width) are provided for output_size,
the output size is (N x C x depth x height x width) for any input (NCDHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="tvm.relay.op.nn.nn.adaptive_avg_pool3d">
<code class="sig-prename descclassname">tvm.relay.op.nn.nn.</code><code class="sig-name descname">adaptive_avg_pool3d</code><span class="sig-paren">(</span><em class="sig-param">data</em>, <em class="sig-param">output_size=None</em>, <em class="sig-param">layout='NCDHW'</em><span class="sig-paren">)</span><a class="headerlink" href="#tvm.relay.op.nn.nn.adaptive_avg_pool3d" title="Permalink to this definition">¶</a></dt>
<dd><p>3D adaptive avg pooling operator. This operator is experimental.</p>
<p>This operator takes data as input and does 3D avg value calculation
across each window represented by DxWxH.</p>
<p>In the default case, where the data_layout is <cite>NCDHW</cite>
a data Tensor with shape <cite>(batch_size, in_channels, depth, height, width)</cite>,
to produce an output Tensor with shape
(batch_size, in_channels, output_depth, output_height, output_width).</p>
<p>The pooling kernel and stride sizes are automatically chosen for
desired output sizes.</p>
<dl>
<dt>For output_size:</dt><dd><p>If this argument is not provided, input depth, height and width will be used
as output depth, height and width.</p>
<p>If a single integer is provided for output_size, the output size is
(N x C x output_size x output_size x output_size) for any input (NCDHW).</p>
<p>If a tuple of integers (depth, height, width) are provided for output_size,
the output size is (N x C x depth x height x width) for any input (NCDHW).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>tvm.relay.Expr</em>) – The input data to the operator.</p></li>
<li><p><strong>output_size</strong> (<em>tuple of int. optional</em>) – Output height and width.</p></li>
<li><p><strong>layout</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.8)"><em>str</em></a><em>, </em><em>optional</em>) – Layout of the input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>result</strong> – The computed result.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tvm.relay.Expr</p>
</dd>
</dl>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="op.html" class="btn btn-neutral float-right" title="tvm.relay.op" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="transform.html" class="btn btn-neutral float-left" title="tvm.relay.transform" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Apache Software Foundation

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>