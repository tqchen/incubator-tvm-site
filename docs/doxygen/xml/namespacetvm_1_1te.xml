<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="namespacetvm_1_1te" kind="namespace" language="C++">
    <compoundname>tvm::te</compoundname>
    <innerclass refid="classtvm_1_1te_1_1BaseComputeOpNode" prot="public">tvm::te::BaseComputeOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1ComputeOpNode" prot="public">tvm::te::ComputeOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1ExternOpNode" prot="public">tvm::te::ExternOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1FuseNode" prot="public">tvm::te::FuseNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1HybridOpNode" prot="public">tvm::te::HybridOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1IterVarAttr" prot="public">tvm::te::IterVarAttr</innerclass>
    <innerclass refid="classtvm_1_1te_1_1IterVarAttrNode" prot="public">tvm::te::IterVarAttrNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1IterVarRelation" prot="public">tvm::te::IterVarRelation</innerclass>
    <innerclass refid="classtvm_1_1te_1_1IterVarRelationNode" prot="public">tvm::te::IterVarRelationNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1Operation" prot="public">tvm::te::Operation</innerclass>
    <innerclass refid="classtvm_1_1te_1_1OperationNode" prot="public">tvm::te::OperationNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1PlaceholderOpNode" prot="public">tvm::te::PlaceholderOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1RebaseNode" prot="public">tvm::te::RebaseNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1ScanOpNode" prot="public">tvm::te::ScanOpNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1Schedule" prot="public">tvm::te::Schedule</innerclass>
    <innerclass refid="classtvm_1_1te_1_1ScheduleNode" prot="public">tvm::te::ScheduleNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1SingletonNode" prot="public">tvm::te::SingletonNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1SpecializedCondition" prot="public">tvm::te::SpecializedCondition</innerclass>
    <innerclass refid="classtvm_1_1te_1_1SpecializedConditionNode" prot="public">tvm::te::SpecializedConditionNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1SplitNode" prot="public">tvm::te::SplitNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1Stage" prot="public">tvm::te::Stage</innerclass>
    <innerclass refid="classtvm_1_1te_1_1StageNode" prot="public">tvm::te::StageNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1Tensor" prot="public">tvm::te::Tensor</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorComputeOpNode" prot="public">tvm::te::TensorComputeOpNode</innerclass>
    <innerclass refid="structtvm_1_1te_1_1TensorDom" prot="public">tvm::te::TensorDom</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorIntrin" prot="public">tvm::te::TensorIntrin</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorIntrinCall" prot="public">tvm::te::TensorIntrinCall</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorIntrinCallNode" prot="public">tvm::te::TensorIntrinCallNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorIntrinNode" prot="public">tvm::te::TensorIntrinNode</innerclass>
    <innerclass refid="classtvm_1_1te_1_1TensorNode" prot="public">tvm::te::TensorNode</innerclass>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5" prot="public" static="no">
        <name>AttachType</name>
        <enumvalue id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5aac738a0b856206b6347a1f4899f31bfa" prot="public">
          <name>kGroupRoot</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5a6472eda35fc70bd00e3ce3b3ce3047fc" prot="public">
          <name>kInline</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5af4fc945dfabb70f21d7341f8ee0b3cf3" prot="public">
          <name>kInlinedAlready</name>
          <initializer>= 3</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5a672a7857e6a2ba34f56bc81e66f4133e" prot="public">
          <name>kScope</name>
          <initializer>= 4</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1te_1a7693a274748dadfa2eaa35f5ce9008a5a502d1f34c7923709e22688c3a1514e80" prot="public">
          <name>kScanUpdate</name>
          <initializer>= 5</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>the attachment type </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule.h" line="48" column="1" bodyfile="include/tvm/te/schedule.h" bodystart="48" bodyend="54"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacetvm_1_1te_1a234ec7f58c22878752d476bd7e99bcea" prot="public" static="no">
        <type>std::function&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>(const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &gt; &amp;i)&gt;</type>
        <definition>using tvm::te::FCompute = typedef std::function&lt;PrimExpr (const Array&lt;Var&gt;&amp; i)&gt;</definition>
        <argsstring></argsstring>
        <name>FCompute</name>
        <briefdescription>
<para>The compute function to specify the input source of a <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref>. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="578" column="1" bodyfile="include/tvm/te/operation.h" bodystart="578" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetvm_1_1te_1aabb227a4a0747faf17a2a8028f5430d5" prot="public" static="no">
        <type>std::function&lt; <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;(const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &gt; &amp;i)&gt;</type>
        <definition>using tvm::te::FBatchCompute = typedef std::function&lt;Array&lt;PrimExpr&gt; (const Array&lt;Var&gt;&amp; i)&gt;</definition>
        <argsstring></argsstring>
        <name>FBatchCompute</name>
        <briefdescription>
<para>The compute function to specify the inputs source of Tensors. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="581" column="1" bodyfile="include/tvm/te/operation.h" bodystart="581" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetvm_1_1te_1ae0c71f84710b436cbe0b32289d0838f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref></type>
        <definition>Var tvm::te::var</definition>
        <argsstring>(std::string name_hint, DataType t=DataType::Int(32))</argsstring>
        <name>var</name>
        <param>
          <type>std::string</type>
          <declname>name_hint</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>t</declname>
          <defval><ref refid="classtvm_1_1runtime_1_1DataType_1ab45f13dd70d982d9f977c79b6f7fac98" kindref="member">DataType::Int</ref>(32)</defval>
        </param>
        <briefdescription>
<para>Construct a new Var expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name_hint</parametername>
</parameternamelist>
<parameterdescription>
<para>The name hint for the expression </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the expression </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="559" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aacca360b75a7db1eb79785bff8c6e205" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref></type>
        <definition>IterVar tvm::te::thread_axis</definition>
        <argsstring>(Range dom, std::string tag)</argsstring>
        <name>thread_axis</name>
        <param>
          <type><ref refid="classtvm_1_1Range" kindref="compound">Range</ref></type>
          <declname>dom</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
        </param>
        <briefdescription>
<para>Create a new IterVar that represents an axis in thread. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dom</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional, domain of the thread axis. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The thread tag of the axis. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="567" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aae384e9b73c2271905486e4a74b69265" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref></type>
        <definition>IterVar tvm::te::reduce_axis</definition>
        <argsstring>(Range dom, std::string name=&quot;rv&quot;)</argsstring>
        <name>reduce_axis</name>
        <param>
          <type><ref refid="classtvm_1_1Range" kindref="compound">Range</ref></type>
          <declname>dom</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;rv&quot;</defval>
        </param>
        <briefdescription>
<para>Create a new IterVar for reduction operations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dom</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain of the reduction axis. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the reduction axis. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="575" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a15a1cc6f7146730ec1f03210c81a8a3c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::placeholder</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, DataType dtype=DataType::Float(32), std::string name=&quot;placeholder&quot;)</argsstring>
        <name>placeholder</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>dtype</declname>
          <defval><ref refid="classtvm_1_1runtime_1_1DataType_1a237a714a6a16e14aa01fa4ac52426551" kindref="member">DataType::Float</ref>(32)</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;placeholder&quot;</defval>
        </param>
        <briefdescription>
<para>create a place holder tensor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>The shape of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtype</parametername>
</parameternamelist>
<parameterdescription>
<para>the data type of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref>. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="589" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aeacae1afc9dd1267cbb5779f9daa4671" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, FCompute fcompute, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1_1te_1a234ec7f58c22878752d476bd7e99bcea" kindref="member">FCompute</ref></type>
          <declname>fcompute</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Construct a new tensor by computing over shape, using the computation rule: result_tensor[axis] = fcompute(axis) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>Shape of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fcompute</parametername>
</parameternamelist>
<parameterdescription>
<para>The compute function to create the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional name of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional tag of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>attrs</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional additional attributes of the compute. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="602" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aecda635ef665a59178b464d7ac6f55c8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>Array&lt;Tensor&gt; tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, FBatchCompute fcompute, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1_1te_1aabb227a4a0747faf17a2a8028f5430d5" kindref="member">FBatchCompute</ref></type>
          <declname>fcompute</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Construct a new tensor by computing over shape, using the computation rule: result_tensor[axis] = fcompute(axis) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>Shape of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fcompute</parametername>
</parameternamelist>
<parameterdescription>
<para>The compute function to create the tensors. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional name of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional tag of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>attrs</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional additional attributes of the compute. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="617" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ad78173237a27f7145c6b198be85b1f0d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
        <definition>Array&lt;Tensor&gt; tvm::te::scan</definition>
        <argsstring>(Array&lt; Tensor &gt; init, Array&lt; Tensor &gt; update, Array&lt; Tensor &gt; state_placeholder, Array&lt; Tensor &gt; inputs=Array&lt; Tensor &gt;(), std::string name=&quot;scan&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>scan</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
          <declname>init</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
          <declname>update</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
          <declname>state_placeholder</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;</type>
          <declname>inputs</declname>
          <defval><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &gt;()</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;scan&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>Construct new tensors by scan. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>The intialize tensor of first K steps. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>update</parametername>
</parameternamelist>
<parameterdescription>
<para>The update tensor indicated the updated result after each timestamp. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>state_placeholder</parametername>
</parameternamelist>
<parameterdescription>
<para>The placeholder for the states. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inputs</parametername>
</parameternamelist>
<parameterdescription>
<para>The inputs to the scan body, this is optional, but recommended to provide concrete information about scan body. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional name of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The optional tag of the tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>attrs</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional additional attributes of the compute. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="635" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aa7dcf52a4277350f202a9103e6ad9d17" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, std::function&lt; PrimExpr(Var)&gt; f, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>(<ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="644" column="1" bodyfile="include/tvm/te/operation.h" bodystart="644" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a44dae0ad08627ceebe2d0d3f45daa388" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, std::function&lt; PrimExpr(Var, Var)&gt; f, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>(<ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="652" column="1" bodyfile="include/tvm/te/operation.h" bodystart="652" bodyend="659"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a37b573ec96a0c47ff16719bcd13d7531" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, std::function&lt; PrimExpr(Var, Var, Var)&gt; f, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>(<ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="660" column="1" bodyfile="include/tvm/te/operation.h" bodystart="660" bodyend="667"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aaf04658c5295c3ccebaed3f7b824a841" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor tvm::te::compute</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, std::function&lt; PrimExpr(Var, Var, Var, Var)&gt; f, std::string name=&quot;tensor&quot;, std::string tag=&quot;&quot;, Map&lt; std::string, ObjectRef &gt; attrs={})</argsstring>
        <name>compute</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type>std::function&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>(<ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>)&gt;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;&quot;</defval>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, ObjectRef &gt;</type>
          <declname>attrs</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/operation.h" line="668" column="1" bodyfile="include/tvm/te/operation.h" bodystart="668" bodyend="675"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a485034766309df280239e0994913b34b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref></type>
        <definition>Schedule tvm::te::create_schedule</definition>
        <argsstring>(Array&lt; Operation &gt; ops)</argsstring>
        <name>create_schedule</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1te_1_1Operation" kindref="compound">Operation</ref> &gt;</type>
          <declname>ops</declname>
        </param>
        <briefdescription>
<para>Create a schedule for array of ops(and their dependencies). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ops</parametername>
</parameternamelist>
<parameterdescription>
<para>The ops to be scheduled. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>sch The created <ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule.h" line="588" column="1" bodyfile="include/tvm/te/schedule.h" bodystart="588" bodyend="590"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ac0effd02bbddf8ce2cce7073e175ca4c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
        <definition>Map&lt;IterVar, Range&gt; tvm::te::InferBound</definition>
        <argsstring>(const Schedule &amp;sch)</argsstring>
        <name>InferBound</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref> &amp;</type>
          <declname>sch</declname>
        </param>
        <briefdescription>
<para>Infer the bound of all iteration variables relates to the schedule. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sch</parametername>
</parameternamelist>
<parameterdescription>
<para>The root schedule to infer all the bounds. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the result bound of the iteration Variable </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule_pass.h" line="42" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ac5f0fdd7c2d3deb15b7855c5b1ff1aff" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::te::ScheduleOps</definition>
        <argsstring>(Schedule s, Map&lt; IterVar, Range &gt; dom_map, bool debug_keep_trivial_loop)</argsstring>
        <name>ScheduleOps</name>
        <param>
          <type><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref></type>
          <declname>s</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
          <declname>dom_map</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>debug_keep_trivial_loop</declname>
        </param>
        <briefdescription>
<para><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref> s&apos; dependent operations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>The schedule to be realized </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dom_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain of each iter vars. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>debug_keep_trivial_loop</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether keep trivial loops with extent of 1 during lowering. This is a debug feature for dataflow/axis analysis. Note: If this is true, The lowered IR may be incorrect, because we will also delete the init part of reduction </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the result Stmt </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule_pass.h" line="55" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a26ae0c9351036d0f7ca362e3c857d24a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tvm::te::AutoInlineElemWise</definition>
        <argsstring>(Schedule sch)</argsstring>
        <name>AutoInlineElemWise</name>
        <param>
          <type><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref></type>
          <declname>sch</declname>
        </param>
        <briefdescription>
<para>To automatically inline the element-wise operations. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sch</parametername>
</parameternamelist>
<parameterdescription>
<para>The schedule to be inlined. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule_pass.h" line="62" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a9872626811f38606b4e934faa13b5b9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tvm::te::AutoInlineInjective</definition>
        <argsstring>(Schedule sch)</argsstring>
        <name>AutoInlineInjective</name>
        <param>
          <type><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">Schedule</ref></type>
          <declname>sch</declname>
        </param>
        <briefdescription>
<para>To automatically inline operations with injective writes (i.e. writes without reduction or sequential loops). Note that in this case, guarantees about contiguity, transpose, stride, alignemnt and memory footprint in general do not hold. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sch</parametername>
</parameternamelist>
<parameterdescription>
<para>The schedule to be inlined. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/schedule_pass.h" line="72" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a27eae569b04a2d43a513b654b6d2b98c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator!</definition>
        <argsstring>(const Tensor::Slice &amp;a)</argsstring>
        <name>operator!</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="236" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="236" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a7cbaaf91ad0e43d83d88a522fcb4214b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator-</definition>
        <argsstring>(const Tensor::Slice &amp;a)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="237" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="237" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a8aa8fb334a26e4b8e8ab3d66454187a7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator+</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="238" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="238" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ac979385c6381a7ca0a87ffaa4f60e5ea" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator+</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator+</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="238" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="238" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ab5a98e93df74228039fff60553720999" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator+</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator+</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="238" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="238" bodyend="238"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a2f041d85fc4eb81c053099cbbb617d1d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator-</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="239" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="239" bodyend="239"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ab9e6e16a169b217585f10e94552ca5f6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator-</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator-</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="239" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="239" bodyend="239"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a0e218dec6bd51cebdbb05fab7d3f07d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator-</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator-</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="239" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="239" bodyend="239"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ae558c447bd0877edf4d5b0e612a735a2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator*</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="240" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="240" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a024b66eea44dbdea15a328e812c75a7f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator*</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator*</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="240" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="240" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a3b9149e3bfe9aa3db7112eb94b87a953" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator*</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator*</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="240" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="240" bodyend="240"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a5d186948df24bd18a8aef7eee3b37727" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator==</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="241" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="241" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a640a91e87c3d3a55c5df248c1a194b90" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator==</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator==</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="241" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="241" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a643184f062c87081a55f9e4ba0e6d0d6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator==</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="241" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="241" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a155868a829cdec5e04c00fee9fd6b8ab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="242" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="242" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a9049756f490d96b37d24fb4a4d019d6e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;=</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="242" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="242" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ae7fe819e0a6e9615e65cabfe5058b498" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="242" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="242" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a54c35df3fc069cb65ad6e28fa6b35109" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="243" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="243" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a5cbaee6b481ab46d55c17206e2487eed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;=</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="243" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="243" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1ac3fd738e5127c9070b347732f40c88b9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="243" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="243" bodyend="243"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a8953e862224184536c2a94d773abf62d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator!=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="244" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="244" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a9aa8f8b632906748d97cf155d9c41449" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator!=</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="244" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="244" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a2ec6eaac719b6db0b90cb3bc2111c627" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator!=</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator!=</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="244" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="244" bodyend="244"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a1c953ed8d8af876442f158bc97c7478a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&amp;&amp;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="245" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="245" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1af5599e3e5add2bfba06085275213de11" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&amp;&amp;</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="245" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="245" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a5e13828dac02bc1cb4e63e08a9b2eeba" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&amp;&amp;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&amp;&amp;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="245" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="245" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a1fd6b8f8380a489cfcd806952c2aae42" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator||</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator||</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="246" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a5be3fdf7d7b6e325b0d1887b47416918" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator||</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator||</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="246" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a1619810ecdc1c9b051522a4313a2c24e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator||</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator||</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="246" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="246" bodyend="246"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a4a8524467a57ae005654a3f0cb816e3f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;&gt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&gt;&gt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="247" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="247" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a8705a88b943011532ff4c94c4b06c213" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;&gt;</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;&gt;</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="247" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="247" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a9d3d9a057d5f1a36277ac4005f38bafa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;&gt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;&gt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="247" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="247" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a8d52a6dd288ed59dd3f75fac6e3833f4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;&lt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="248" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="248" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1afba65b87ed8a5587c48b1f63ff9d8437" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;&lt;</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="248" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="248" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a6bb44656b78b7d6a02ede706ed0a85ec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;&lt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="248" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="248" bodyend="248"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1aa8b01278c56c8099c02bf1a614f1a100" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="249" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="249" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a74074c1b06a426adb0f300944b8c4e88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="249" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="249" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1af05f53104e6686e271783712280e4005" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&gt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&gt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="249" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="249" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a161a27f91902b5a05c0232ebf8562e00" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const T &amp;b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="250" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="250" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a825f173e411f783dffef4dc5d1a44b08" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;</definition>
        <argsstring>(const T &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const T &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="250" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="250" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1te_1a7585d3a07b7a501536fe8337464d243e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::te::operator&lt;</definition>
        <argsstring>(const Tensor::Slice &amp;a, const Tensor::Slice &amp;b)</argsstring>
        <name>operator&lt;</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor_1_1Slice" kindref="compound">Tensor::Slice</ref> &amp;</type>
          <declname>b</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/te/tensor.h" line="250" column="1" bodyfile="include/tvm/te/tensor.h" bodystart="250" bodyend="250"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> expression language DSL. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/tvm/arith/bound.h" line="36" column="1"/>
  </compounddef>
</doxygen>
