<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="classtvm_1_1runtime_1_1Registry" kind="class" language="C++" prot="public">
    <compoundname>tvm::runtime::Registry</compoundname>
    <includes refid="registry_8h" local="no">registry.h</includes>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classtvm_1_1runtime_1_1Registry_1a4d8221b67729bafee4c2c5b424ed80ea" prot="protected" static="no" mutable="no">
        <type>std::string</type>
        <definition>std::string tvm::runtime::Registry::name_</definition>
        <argsstring></argsstring>
        <name>name_</name>
        <briefdescription>
<para>name of the function </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="267" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="263" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtvm_1_1runtime_1_1Registry_1a911416a22858355e0b95ec493db67218" prot="protected" static="no" mutable="no">
        <type><ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">PackedFunc</ref></type>
        <definition>PackedFunc tvm::runtime::Registry::func_</definition>
        <argsstring></argsstring>
        <name>func_</name>
        <briefdescription>
<para>internal packed function </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="269" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="269" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtvm_1_1runtime_1_1Registry_1a1fd6b9bc3f72bb2b64e602de3982929d" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend struct</type>
        <definition>friend struct Manager</definition>
        <argsstring></argsstring>
        <name>Manager</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="270" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="270" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1aed802ed365a13a9cef9de4e9f601b62a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body</definition>
        <argsstring>(PackedFunc f)</argsstring>
        <name>set_body</name>
        <param>
          <type><ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">PackedFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be f </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The body of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="61" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1aa093c769200bbf53e1c5911bd1be5568" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body</definition>
        <argsstring>(PackedFunc::FType f)</argsstring>
        <name>set_body</name>
        <param>
          <type><ref refid="classtvm_1_1runtime_1_1PackedFunc_1ae5f951a6a515f3e3a7493c27704b7849" kindref="member">PackedFunc::FType</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be f </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The body of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="66" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="66" bodyend="68"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1a607848df01d8c33d7e2cf40e7dae42b1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename FLambda</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body_typed</definition>
        <argsstring>(FLambda f)</argsstring>
        <name>set_body_typed</name>
        <param>
          <type>FLambda</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to the given function. Note that this will ignore default arg values and always require all arguments to be provided. </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">int<sp/>multiply(int<sp/>x,<sp/>int<sp/>y)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>x<sp/>*<sp/>y;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;multiply&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_typed(multiply);<sp/>//<sp/>will<sp/>have<sp/>type<sp/>int(int,<sp/>int)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>will<sp/>have<sp/>type<sp/>int(int,<sp/>int)</highlight></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;sub&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_typed([](int<sp/>a,<sp/>int<sp/>b)<sp/>-&gt;<sp/>int<sp/>{<sp/>return<sp/>a<sp/>-<sp/>b;<sp/>});</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to forward to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>FLambda</parametername>
</parameternamelist>
<parameterdescription>
<para>The signature of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="92" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="92" bodyend="95"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1ae5f7cc19067b609a79e1bb32b7b6f086" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body_method</definition>
        <argsstring>(R(T::*f)(Args...))</argsstring>
        <name>set_body_method</name>
        <param>
          <type>R(T::*)(Args...)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be the passed method pointer. Note that this will ignore default arg values and always require all arguments to be provided. </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">//<sp/>node<sp/>subclass:</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>Example<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>int<sp/>doThing(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;Example_doThing&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_method(&amp;Example::doThing);<sp/>//<sp/>will<sp/>have<sp/>type<sp/>int(Example,<sp/>int)</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the method pointer to forward to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>the type containing the method (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>the return type of the function (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>the argument types of the function (inferred). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="117" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="117" bodyend="123"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1ae1243626f5f81ca956343dbe8c22b9b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body_method</definition>
        <argsstring>(R(T::*f)(Args...) const)</argsstring>
        <name>set_body_method</name>
        <param>
          <type>R(T::*)(Args...) const</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be the passed method pointer. Note that this will ignore default arg values and always require all arguments to be provided. </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">//<sp/>node<sp/>subclass:</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>Example<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>int<sp/>doThing(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;Example_doThing&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_method(&amp;Example::doThing);<sp/>//<sp/>will<sp/>have<sp/>type<sp/>int(Example,<sp/>int)</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the method pointer to forward to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>the type containing the method (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>the return type of the function (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>the argument types of the function (inferred). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="146" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="146" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1ae5fcbc18ff9a33ad700592dc8e46bd90" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TObjectRef</type>
          </param>
          <param>
            <type>typename TNode</type>
          </param>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;std::is_base_of&lt;<ref refid="classtvm_1_1runtime_1_1ObjectRef" kindref="compound">ObjectRef</ref>, TObjectRef&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body_method</definition>
        <argsstring>(R(TNode::*f)(Args...))</argsstring>
        <name>set_body_method</name>
        <param>
          <type>R(TNode::*)(Args...)</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be the passed method pointer. Used when calling a method on a Node subclass through a <ref refid="classtvm_1_1runtime_1_1ObjectRef" kindref="compound">ObjectRef</ref> subclass. Note that this will ignore default arg values and always require all arguments to be provided. </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">//<sp/>node<sp/>subclass:</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>ExampleNode:<sp/>BaseNode<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>int<sp/>doThing(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>noderef<sp/>subclass</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>Example;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;Example_doThing&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_method&lt;Example&gt;(&amp;ExampleNode::doThing);<sp/>//<sp/>will<sp/>have<sp/>type<sp/>int(Example,<sp/>int)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>note<sp/>that<sp/>just<sp/>doing:</highlight></codeline>
<codeline><highlight class="normal">//<sp/>.set_body_method(&amp;ExampleNode::doThing);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>wouldn&apos;t<sp/>work,<sp/>because<sp/>ExampleNode<sp/>can&apos;t<sp/>be<sp/>taken<sp/>from<sp/>a<sp/>TVMArgValue.</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the method pointer to forward to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TObjectRef</parametername>
</parameternamelist>
<parameterdescription>
<para>the node reference type to call the method on </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNode</parametername>
</parameternamelist>
<parameterdescription>
<para>the node type containing the method (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>the return type of the function (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>the argument types of the function (inferred). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="186" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="186" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1a106607f2535dc7c838646aabd029aa60" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename TObjectRef</type>
          </param>
          <param>
            <type>typename TNode</type>
          </param>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Args</declname>
            <defname>Args</defname>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;std::is_base_of&lt;<ref refid="classtvm_1_1runtime_1_1ObjectRef" kindref="compound">ObjectRef</ref>, TObjectRef&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>Registry&amp; tvm::runtime::Registry::set_body_method</definition>
        <argsstring>(R(TNode::*f)(Args...) const)</argsstring>
        <name>set_body_method</name>
        <param>
          <type>R(TNode::*)(Args...) const</type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>set the body of the function to be the passed method pointer. Used when calling a method on a Node subclass through a <ref refid="classtvm_1_1runtime_1_1ObjectRef" kindref="compound">ObjectRef</ref> subclass. Note that this will ignore default arg values and always require all arguments to be provided. </para>        </briefdescription>
        <detaileddescription>
<para><programlisting><codeline><highlight class="normal">//<sp/>node<sp/>subclass:</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>ExampleNode:<sp/>BaseNode<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>int<sp/>doThing(int<sp/>x);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>noderef<sp/>subclass</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>Example;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">TVM_REGISTER_GLOBAL(&quot;Example_doThing&quot;)</highlight></codeline>
<codeline><highlight class="normal">.set_body_method&lt;Example&gt;(&amp;ExampleNode::doThing);<sp/>//<sp/>will<sp/>have<sp/>type<sp/>int(Example,<sp/>int)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>note<sp/>that<sp/>just<sp/>doing:</highlight></codeline>
<codeline><highlight class="normal">//<sp/>.set_body_method(&amp;ExampleNode::doThing);</highlight></codeline>
<codeline><highlight class="normal">//<sp/>wouldn&apos;t<sp/>work,<sp/>because<sp/>ExampleNode<sp/>can&apos;t<sp/>be<sp/>taken<sp/>from<sp/>a<sp/>TVMArgValue.</highlight></codeline>
</programlisting></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>the method pointer to forward to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>TObjectRef</parametername>
</parameternamelist>
<parameterdescription>
<para>the node reference type to call the method on </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>TNode</parametername>
</parameternamelist>
<parameterdescription>
<para>the node type containing the method (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>the return type of the function (inferred). </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Args</parametername>
</parameternamelist>
<parameterdescription>
<para>the argument types of the function (inferred). </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="227" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="227" bodyend="234"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1a227ffef03991cd50224d5d31257a475a" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> &amp;</type>
        <definition>static Registry&amp; tvm::runtime::Registry::Register</definition>
        <argsstring>(const std::string &amp;name, bool override=false)</argsstring>
        <name>Register</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>override</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Register a function with given name. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>override</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether allow oveeride existing function. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Reference to theregistry. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="242" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1aad89aa915515019c59364b7b569c4648" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>static bool tvm::runtime::Registry::Remove</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>Remove</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Erase global function from registry, if exist. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Whether function exist. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="248" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1afcddc7b207f519f92c622e6918076635" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const <ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">PackedFunc</ref> *</type>
        <definition>static const PackedFunc* tvm::runtime::Registry::Get</definition>
        <argsstring>(const std::string &amp;name)</argsstring>
        <name>Get</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>Get the global function by name. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>pointer to the registered function, nullptr if it does not exist. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="255" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtvm_1_1runtime_1_1Registry_1a5c2ff3b997756d76a1ae5fb1d3cc550d" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::vector&lt; std::string &gt;</type>
        <definition>static std::vector&lt;std::string&gt; tvm::runtime::Registry::ListNames</definition>
        <argsstring>()</argsstring>
        <name>ListNames</name>
        <briefdescription>
<para>Get the names of currently registered global function. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>The names </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/runtime/registry.h" line="260" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para><ref refid="classtvm_1_1runtime_1_1Registry" kindref="compound">Registry</ref> for global function. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <collaborationgraph>
      <node id="6530">
        <label>tvm::runtime::PackedFunc</label>
        <link refid="classtvm_1_1runtime_1_1PackedFunc"/>
      </node>
      <node id="6529">
        <label>tvm::runtime::Registry</label>
        <link refid="classtvm_1_1runtime_1_1Registry"/>
        <childnode refid="6530" relation="usage">
          <edgelabel>#func_</edgelabel>
        </childnode>
      </node>
    </collaborationgraph>
    <location file="include/tvm/runtime/registry.h" line="55" column="1" bodyfile="include/tvm/runtime/registry.h" bodystart="55" bodyend="271"/>
    <listofallmembers>
      <member refid="classtvm_1_1runtime_1_1Registry_1a911416a22858355e0b95ec493db67218" prot="protected" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>func_</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1afcddc7b207f519f92c622e6918076635" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>Get</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a5c2ff3b997756d76a1ae5fb1d3cc550d" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>ListNames</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a1fd6b9bc3f72bb2b64e602de3982929d" prot="protected" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>Manager</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a4d8221b67729bafee4c2c5b424ed80ea" prot="protected" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>name_</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a227ffef03991cd50224d5d31257a475a" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>Register</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1aad89aa915515019c59364b7b569c4648" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>Remove</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1aed802ed365a13a9cef9de4e9f601b62a" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1aa093c769200bbf53e1c5911bd1be5568" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1ae5f7cc19067b609a79e1bb32b7b6f086" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body_method</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1ae1243626f5f81ca956343dbe8c22b9b3" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body_method</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1ae5fcbc18ff9a33ad700592dc8e46bd90" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body_method</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a106607f2535dc7c838646aabd029aa60" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body_method</name></member>
      <member refid="classtvm_1_1runtime_1_1Registry_1a607848df01d8c33d7e2cf40e7dae42b1" prot="public" virt="non-virtual"><scope>tvm::runtime::Registry</scope><name>set_body_typed</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
