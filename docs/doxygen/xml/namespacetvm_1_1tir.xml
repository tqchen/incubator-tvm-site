<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="namespacetvm_1_1tir" kind="namespace" language="C++">
    <compoundname>tvm::tir</compoundname>
    <innerclass refid="classtvm_1_1tir_1_1AddNode" prot="public">tvm::tir::AddNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1AllocateNode" prot="public">tvm::tir::AllocateNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1AndNode" prot="public">tvm::tir::AndNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1AnyNode" prot="public">tvm::tir::AnyNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1AssertStmtNode" prot="public">tvm::tir::AssertStmtNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1AttrStmtNode" prot="public">tvm::tir::AttrStmtNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1BijectiveLayout" prot="public">tvm::tir::BijectiveLayout</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1BijectiveLayoutNode" prot="public">tvm::tir::BijectiveLayoutNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1BinaryOpNode" prot="public">tvm::tir::BinaryOpNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1BroadcastNode" prot="public">tvm::tir::BroadcastNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1Buffer" prot="public">tvm::tir::Buffer</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1BufferNode" prot="public">tvm::tir::BufferNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1CallNode" prot="public">tvm::tir::CallNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1CastNode" prot="public">tvm::tir::CastNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1CmpOpNode" prot="public">tvm::tir::CmpOpNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1CommReducer" prot="public">tvm::tir::CommReducer</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1CommReducerNode" prot="public">tvm::tir::CommReducerNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1DivNode" prot="public">tvm::tir::DivNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1EQNode" prot="public">tvm::tir::EQNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1EvaluateNode" prot="public">tvm::tir::EvaluateNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ExprFunctor" prot="public">tvm::tir::ExprFunctor</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4" prot="public">tvm::tir::ExprFunctor&lt; R(const PrimExpr &amp;n, Args...)&gt;</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ExprMutator" prot="public">tvm::tir::ExprMutator</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ExprVisitor" prot="public">tvm::tir::ExprVisitor</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1FloorDivNode" prot="public">tvm::tir::FloorDivNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1FloorModNode" prot="public">tvm::tir::FloorModNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ForNode" prot="public">tvm::tir::ForNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1FreeNode" prot="public">tvm::tir::FreeNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1FunctionBaseNode" prot="public">tvm::tir::FunctionBaseNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1FunctionRef" prot="public">tvm::tir::FunctionRef</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1GENode" prot="public">tvm::tir::GENode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1GTNode" prot="public">tvm::tir::GTNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1IfThenElseNode" prot="public">tvm::tir::IfThenElseNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1IterVar" prot="public">tvm::tir::IterVar</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1IterVarNode" prot="public">tvm::tir::IterVarNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1Layout" prot="public">tvm::tir::Layout</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LayoutAxis" prot="public">tvm::tir::LayoutAxis</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LayoutNode" prot="public">tvm::tir::LayoutNode</innerclass>
    <innerclass refid="structtvm_1_1tir_1_1LENode" prot="public">tvm::tir::LENode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LetNode" prot="public">tvm::tir::LetNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LetStmtNode" prot="public">tvm::tir::LetStmtNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LoadNode" prot="public">tvm::tir::LoadNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LoweredFunc" prot="public">tvm::tir::LoweredFunc</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LoweredFuncNode" prot="public">tvm::tir::LoweredFuncNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1LTNode" prot="public">tvm::tir::LTNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1MaxNode" prot="public">tvm::tir::MaxNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1MinNode" prot="public">tvm::tir::MinNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ModNode" prot="public">tvm::tir::ModNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1MulNode" prot="public">tvm::tir::MulNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1NENode" prot="public">tvm::tir::NENode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1NotNode" prot="public">tvm::tir::NotNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1OrNode" prot="public">tvm::tir::OrNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1PrefetchNode" prot="public">tvm::tir::PrefetchNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1PrimFunc" prot="public">tvm::tir::PrimFunc</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1PrimFuncNode" prot="public">tvm::tir::PrimFuncNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ProducerConsumerNode" prot="public">tvm::tir::ProducerConsumerNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ProvideNode" prot="public">tvm::tir::ProvideNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1RampNode" prot="public">tvm::tir::RampNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1RealizeNode" prot="public">tvm::tir::RealizeNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ReduceNode" prot="public">tvm::tir::ReduceNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SelectNode" prot="public">tvm::tir::SelectNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SeqStmt" prot="public">tvm::tir::SeqStmt</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SeqStmtNode" prot="public">tvm::tir::SeqStmtNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1ShuffleNode" prot="public">tvm::tir::ShuffleNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SizeVar" prot="public">tvm::tir::SizeVar</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SizeVarNode" prot="public">tvm::tir::SizeVarNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1Stmt" prot="public">tvm::tir::Stmt</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtExprMutator" prot="public">tvm::tir::StmtExprMutator</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtExprVisitor" prot="public">tvm::tir::StmtExprVisitor</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtFunctor" prot="public">tvm::tir::StmtFunctor</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4" prot="public">tvm::tir::StmtFunctor&lt; R(const Stmt &amp;n, Args...args)&gt;</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtMutator" prot="public">tvm::tir::StmtMutator</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtNode" prot="public">tvm::tir::StmtNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StmtVisitor" prot="public">tvm::tir::StmtVisitor</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StoreNode" prot="public">tvm::tir::StoreNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StringImm" prot="public">tvm::tir::StringImm</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1StringImmNode" prot="public">tvm::tir::StringImmNode</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1SubNode" prot="public">tvm::tir::SubNode</innerclass>
    <innerclass refid="structtvm_1_1tir_1_1TensorKey" prot="public">tvm::tir::TensorKey</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1Var" prot="public">tvm::tir::Var</innerclass>
    <innerclass refid="classtvm_1_1tir_1_1VarNode" prot="public">tvm::tir::VarNode</innerclass>
    <innernamespace refid="namespacetvm_1_1tir_1_1attr">tvm::tir::attr</innernamespace>
    <innernamespace refid="namespacetvm_1_1tir_1_1intrinsic">tvm::tir::intrinsic</innernamespace>
    <innernamespace refid="namespacetvm_1_1tir_1_1transform">tvm::tir::transform</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetvm_1_1tir_1a9ac05a14db42ca73da1d3945e7ce2fd1" prot="public" static="no">
        <name>BufferType</name>
        <enumvalue id="namespacetvm_1_1tir_1a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39" prot="public">
          <name>kDefault</name>
          <initializer>= 1</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663" prot="public">
          <name>kAutoBroadcast</name>
          <initializer>= 2</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>buffer type </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/buffer.h" line="40" column="1" bodyfile="include/tvm/tir/buffer.h" bodystart="40" bodyend="44"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358e" prot="public" static="no">
        <name>IterVarType</name>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422" prot="public">
          <name>kDataPar</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Data parallel iteration. This normally corresponds to axis of Tensor. Allow all <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> manipulations. </para>          </briefdescription>
          <detaileddescription>
<para><simplesect kind="note"><para>This does not mean the loop have to be executed in parallel fashion. </para></simplesect>
</para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0" prot="public">
          <name>kThreadIndex</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>The <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> itself is a thread-index of a fixed thread launching group. Note that this is already assumed to be paralellized. </para>          </briefdescription>
          <detaileddescription>
<para>Disallow: split/fuse/vectorize/parallel </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4" prot="public">
          <name>kCommReduce</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Communicative reduction. Cannot be directly parallelized. </para>          </briefdescription>
          <detaileddescription>
<para>Disallow: parallel/vectorize </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b" prot="public">
          <name>kOrdered</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-ordered. </para>          </briefdescription>
          <detaileddescription>
<para>Disallow: reorder/parallel/vectorize </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c" prot="public">
          <name>kOpaque</name>
          <initializer>= 4</initializer>
          <briefdescription>
<para><ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> is opaque,. </para>          </briefdescription>
          <detaileddescription>
<para>May not corresponds to any generated loop Disallow all <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> manipulations and compute_at</para><para><simplesect kind="note"><para>This is usually used to implement composite op or external op, where the </para></simplesect>
</para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403" prot="public">
          <name>kUnrolled</name>
          <initializer>= 5</initializer>
          <briefdescription>
<para>The execution is unrolled. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd" prot="public">
          <name>kVectorized</name>
          <initializer>= 6</initializer>
          <briefdescription>
<para>The loop is vectorized. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652" prot="public">
          <name>kParallelized</name>
          <initializer>= 7</initializer>
          <briefdescription>
<para>The loop is parallelized. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47" prot="public">
          <name>kTensorized</name>
          <initializer>= 8</initializer>
          <briefdescription>
<para>Marks boundary of tensorization intrinsic. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para><ref refid="classtvm_1_1Type" kindref="compound">Type</ref> of iteration variable. Each <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> have a specific type. </para>        </briefdescription>
        <detaileddescription>
<para>The type of iter var can be overriden via stage.iter_var_attrs given they are compatible. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="187" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="187" bodyend="248"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetvm_1_1tir_1a69f0089a367b98e377b652186fa7dc66" prot="public" static="no">
        <name>LoweredFuncType</name>
        <enumvalue id="namespacetvm_1_1tir_1a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9" prot="public">
          <name>kMixedFunc</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Function that can mix device and host calls. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858" prot="public">
          <name>kHostFunc</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Only contains host code. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628" prot="public">
          <name>kDeviceFunc</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Only contains device code. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>specific type of lowered function </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/lowered_func.h" line="57" column="1" bodyfile="include/tvm/tir/lowered_func.h" bodystart="57" bodyend="64"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736" prot="public" static="no">
        <name>ForType</name>
        <enumvalue id="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493" prot="public">
          <name>Serial</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>serial execution. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131" prot="public">
          <name>Parallel</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>parallel execution on CPU. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725" prot="public">
          <name>Vectorized</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Vector SIMD loop annotaion. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac" prot="public">
          <name>Unrolled</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>Unroll annotation. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Additional annotation of for loop. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt.h" line="663" column="1" bodyfile="include/tvm/tir/stmt.h" bodystart="663" bodyend="672"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetvm_1_1tir_1aed067b57db2923a07913239b2165e019" prot="public" static="no">
        <name>DeviceAPI</name>
        <enumvalue id="namespacetvm_1_1tir_1aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754" prot="public">
          <name>None</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt.h" line="677" column="1" bodyfile="include/tvm/tir/stmt.h" bodystart="677" bodyend="679"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacetvm_1_1tir_1a8277e2a3d81a80a4776705673df51e0a" prot="public" static="no">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
        <definition>using tvm::tir::Region = typedef Array&lt;Range&gt;</definition>
        <argsstring></argsstring>
        <name>Region</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="178" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="178" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetvm_1_1tir_1aa177c432dd27540d34b22c05559324ab" prot="public" static="no">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
        <definition>using tvm::tir::Domain = typedef Array&lt;Range&gt;</definition>
        <argsstring></argsstring>
        <name>Domain</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="273" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="273" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetvm_1_1tir_1ae8c7db788e840dc1c2ed1f365d5ea829" prot="public" static="no">
        <type><ref refid="classtvm_1_1IntImmNode" kindref="compound">tvm::IntImmNode</ref></type>
        <definition>using tvm::tir::IntImmNode = typedef tvm::IntImmNode</definition>
        <argsstring></argsstring>
        <name>IntImmNode</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="352" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="352" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetvm_1_1tir_1adb123be81447d2871f4c716ce2d1dc00" prot="public" static="no">
        <type><ref refid="classtvm_1_1FloatImmNode" kindref="compound">tvm::FloatImmNode</ref></type>
        <definition>using tvm::tir::FloatImmNode = typedef tvm::FloatImmNode</definition>
        <argsstring></argsstring>
        <name>FloatImmNode</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="353" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="353" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetvm_1_1tir_1a9b3692f3f081d3b5b84a24cf8082141e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref></type>
        <definition>Buffer tvm::tir::decl_buffer</definition>
        <argsstring>(Array&lt; PrimExpr &gt; shape, DataType dtype=DataType::Float(32), std::string name=&quot;buffer&quot;)</argsstring>
        <name>decl_buffer</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>shape</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>dtype</declname>
          <defval><ref refid="classtvm_1_1runtime_1_1DataType_1a237a714a6a16e14aa01fa4ac52426551" kindref="member">DataType::Float</ref>(32)</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;buffer&quot;</defval>
        </param>
        <briefdescription>
<para>Construct a new buffer given shape, and dtype. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>shape</parametername>
</parameternamelist>
<parameterdescription>
<para>The shape of the buffer, </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dtype</parametername>
</parameternamelist>
<parameterdescription>
<para>The content data type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The created buffer. </para></simplesect>
<simplesect kind="see"><para><ref refid="classtvm_1_1tir_1_1BufferNode_1abdf17916660dd43932e3f72958ca297d" kindref="member">BufferNode::make</ref> for complete constructor. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/buffer.h" line="214" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1afc0fdee9fc81462318d59dbe64c8df26" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tvm::tir::IterVarType2String</definition>
        <argsstring>(IterVarType t)</argsstring>
        <name>IterVarType2String</name>
        <param>
          <type><ref refid="namespacetvm_1_1tir_1add7d0a6b1dd91f0c3c5dd2f4cf64358e" kindref="member">IterVarType</ref></type>
          <declname>t</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="337" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="337" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1abb777c4f4d61883c0cbdf9116458b70d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
          </param>
        </templateparamlist>
        <type>std::unordered_map&lt; K, V &gt;</type>
        <definition>std::unordered_map&lt;K, V&gt; tvm::tir::as_unordered_map</definition>
        <argsstring>(const Map&lt; K, V &gt; &amp;dmap)</argsstring>
        <name>as_unordered_map</name>
        <param>
          <type>const <ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; K, V &gt; &amp;</type>
          <declname>dmap</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/expr.h" line="1251" column="1" bodyfile="include/tvm/tir/expr.h" bodystart="1251" bodyend="1257"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a923d1bb833c984008772782e90cda37a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::Simplify</definition>
        <argsstring>(PrimExpr expr, Map&lt; Var, Range &gt; vrange=Map&lt; Var, Range &gt;())</argsstring>
        <name>Simplify</name>
        <param>
          <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
          <declname>vrange</declname>
          <defval><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Simplify the expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression to be simplifed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vrange</parametername>
</parameternamelist>
<parameterdescription>
<para>The range information about the variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Canonicalized statement. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="51" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a49287db98b766f8900dbbfcc466cb596" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::Simplify</definition>
        <argsstring>(Stmt stmt, Map&lt; Var, Range &gt; vrange=Map&lt; Var, Range &gt;())</argsstring>
        <name>Simplify</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
          <declname>vrange</declname>
          <defval><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Simplify the statement. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be simplifed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vrange</parametername>
</parameternamelist>
<parameterdescription>
<para>The range information about the variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Canonicalized statement. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="59" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae3f7ea11fa82b0cb4a990f51beaa5203" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::CanonicalSimplify</definition>
        <argsstring>(Stmt stmt, Map&lt; Var, Range &gt; vrange=Map&lt; Var, Range &gt;())</argsstring>
        <name>CanonicalSimplify</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
          <declname>vrange</declname>
          <defval><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Simplify by applying canonical form. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be canonically simplifed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vrange</parametername>
</parameternamelist>
<parameterdescription>
<para>The range information about the variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Canonicalized statement. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="67" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a6a22160396635ce8b681f3aaed32df5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::CanonicalSimplify</definition>
        <argsstring>(PrimExpr expr, Map&lt; Var, Range &gt; vrange=Map&lt; Var, Range &gt;())</argsstring>
        <name>CanonicalSimplify</name>
        <param>
          <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;</type>
          <declname>vrange</declname>
          <defval><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1Range" kindref="compound">Range</ref> &gt;()</defval>
        </param>
        <briefdescription>
<para>Simplify by applying canonical form. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be canonically simplifed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vrange</parametername>
</parameternamelist>
<parameterdescription>
<para>The range information about the variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Canonicalized expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="76" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae9b75fe00e0f29e2cc8e2b3ffe541ff4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::Equal</definition>
        <argsstring>(const PrimExpr &amp;lhs, const PrimExpr &amp;rhs)</argsstring>
        <name>Equal</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Deep compare lhs and rhs. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The left operand </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The right operand </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The comparison result. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="85" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1af7135e786c567aacc96fa95bac4dae4b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::Equal</definition>
        <argsstring>(const Stmt &amp;lhs, const Stmt &amp;rhs)</argsstring>
        <name>Equal</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Deep compare lhs and rhs. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The left operand </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The right operand </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The comparison result. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="93" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a388b768f462e6699d061b5ea3ca87616" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tvm::tir::Compare</definition>
        <argsstring>(const PrimExpr &amp;lhs, const PrimExpr &amp;rhs)</argsstring>
        <name>Compare</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>lhs</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>rhs</declname>
        </param>
        <briefdescription>
<para>Deep compare lhs and rhs. </para>        </briefdescription>
        <detaileddescription>
<para>If you only want equality comparison, use Equal which will also tie definitions. The compare mode will give order of expression in total order.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The left operand </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>rhs</parametername>
</parameternamelist>
<parameterdescription>
<para>The right operand </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The comparison result. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="106" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae4506ebe76b8f44653dafdf0aef263f1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::VerifySSA</definition>
        <argsstring>(const Stmt &amp;ir)</argsstring>
        <name>VerifySSA</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref> &amp;</type>
          <declname>ir</declname>
        </param>
        <briefdescription>
<para>verifies whether the IR stmt or Expr is in SSA form. That is: each VarExpr is defined and assigned once(in Let/For) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ir</parametername>
</parameternamelist>
<parameterdescription>
<para>The root of the IR DAG. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Whether IR is in SSA form. </para></simplesect>
<simplesect kind="note"><para>All the passes in this file uses SSA form and outputs SSA form. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="116" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a93a2b6c1ea585d4cfd12539e65f48fdb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::HasSideEffect</definition>
        <argsstring>(const PrimExpr &amp;e)</argsstring>
        <name>HasSideEffect</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>e</declname>
        </param>
        <briefdescription>
<para>Whether the expression have side effect. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>whether expression have side effect </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="122" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a2a95f59679b6acbb47ab488a1e2c6b09" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::ExprUseVar</definition>
        <argsstring>(const PrimExpr &amp;e, const Var &amp;v)</argsstring>
        <name>ExprUseVar</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &amp;</type>
          <declname>v</declname>
        </param>
        <briefdescription>
<para>Whether e expression used var. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression to be checked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Whether e uses v. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="130" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae82ce8b3c5f0cd3a8213b90153637177" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::ExprUseVar</definition>
        <argsstring>(const PrimExpr &amp;e, const std::unordered_set&lt; const VarNode * &gt; &amp;vset)</argsstring>
        <name>ExprUseVar</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>e</declname>
        </param>
        <param>
          <type>const std::unordered_set&lt; const <ref refid="classtvm_1_1tir_1_1VarNode" kindref="compound">VarNode</ref> * &gt; &amp;</type>
          <declname>vset</declname>
        </param>
        <briefdescription>
<para>Whether e expression used any var in variable set.. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>e</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression to be checked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vset</parametername>
</parameternamelist>
<parameterdescription>
<para>The variable set. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Whether e uses vset. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="138" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1afdbcd71b66872684f3dc873b9380520f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::ConvertSSA</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>ConvertSSA</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Convert a IR node to be SSA form. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The source statement to be converted. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted form. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="145" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a4b122873fd63b721684ffb4cd9913bb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::Substitute</definition>
        <argsstring>(Stmt stmt, const std::unordered_map&lt; const VarNode *, PrimExpr &gt; &amp;value_map)</argsstring>
        <name>Substitute</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>const std::unordered_map&lt; const <ref refid="classtvm_1_1tir_1_1VarNode" kindref="compound">VarNode</ref> *, <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>value_map</declname>
        </param>
        <briefdescription>
<para>Substitute the var specified in key-&gt;var to be value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The source statement to be substituted </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The map of new values. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted form. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="153" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a1753495736a7c0ab703ed01c673ec5d0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::Substitute</definition>
        <argsstring>(PrimExpr expr, const std::unordered_map&lt; const VarNode *, PrimExpr &gt; &amp;value_map)</argsstring>
        <name>Substitute</name>
        <param>
          <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const std::unordered_map&lt; const <ref refid="classtvm_1_1tir_1_1VarNode" kindref="compound">VarNode</ref> *, <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>value_map</declname>
        </param>
        <briefdescription>
<para>Substitute the var specified in key-&gt;var to be value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The source expression to be substituted </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The map of new values. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="162" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1abc79c4131e8b95c4ae4be56d4ab3c494" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::Substitute</definition>
        <argsstring>(Stmt stmt, const Map&lt; Var, PrimExpr &gt; &amp;value_map)</argsstring>
        <name>Substitute</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>value_map</declname>
        </param>
        <briefdescription>
<para>Substitute the var specified in key-&gt;var to be value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The source statement to be substituted </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The map of new values. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted form. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="171" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a34e6a1e27339fcc255f664dd14e7c6cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::Substitute</definition>
        <argsstring>(PrimExpr expr, const Map&lt; Var, PrimExpr &gt; &amp;value_map)</argsstring>
        <name>Substitute</name>
        <param>
          <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
          <declname>expr</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>value_map</declname>
        </param>
        <briefdescription>
<para>Substitute the var specified in key-&gt;var to be value. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>expr</parametername>
</parameternamelist>
<parameterdescription>
<para>The source expression to be substituted </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The map of new values. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The converted expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="179" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a96379de32bcde10449bdb01b9b816e99" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::Inline</definition>
        <argsstring>(Stmt stmt, FunctionRef f, Array&lt; Var &gt; args, PrimExpr body)</argsstring>
        <name>Inline</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1FunctionRef" kindref="compound">FunctionRef</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &gt;</type>
          <declname>args</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
          <declname>body</declname>
        </param>
        <briefdescription>
<para>inline all calls of f in stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to apply inline optimization. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function reference to be inlined </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The arguments variable of the function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>The definition body of the function. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result stmt</para></simplesect>
<simplesect kind="note"><para>All the passes in this file uses SSA form and outputs SSA form. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="192" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a2c63e0decac1e98ee375d32dee15526e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::StorageFlatten</definition>
        <argsstring>(Stmt stmt, Map&lt; te::Tensor, Buffer &gt; extern_buffer, int cache_line_size, bool create_bound_attribute=false)</argsstring>
        <name>StorageFlatten</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">te::Tensor</ref>, <ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>extern_buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>cache_line_size</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>create_bound_attribute</declname>
          <defval>false</defval>
        </param>
        <briefdescription>
<para>Flatten the multi-dimensional read/write to single dimensional Load/Store. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be trasnformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>extern_buffer</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtvm_1_1Map" kindref="compound">Map</ref> specifies external buffer assignment of input and outputs. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cache_line_size</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of CPU cache line. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>create_bound_attribute</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to create bound attributes. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="208" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a00e711fe4801fd2d11f85cb64bc64d56" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::RewriteForTensorCore</definition>
        <argsstring>(Stmt stmt, te::Schedule schedule, Map&lt; te::Tensor, Buffer &gt; extern_buffer)</argsstring>
        <name>RewriteForTensorCore</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1te_1_1Schedule" kindref="compound">te::Schedule</ref></type>
          <declname>schedule</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">te::Tensor</ref>, <ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref> &gt;</type>
          <declname>extern_buffer</declname>
        </param>
        <briefdescription>
<para>Try to modify the AST to support TensorCore. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be trasnformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>schedule</parametername>
</parameternamelist>
<parameterdescription>
<para>The original schedule. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>extern_buffer</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classtvm_1_1Map" kindref="compound">Map</ref> specifies external buffer assignment of input and outputs. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="222" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae892521d99d9475a59e2d01df9413b49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::VerifyCompactBuffer</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>VerifyCompactBuffer</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Verify if there is any argument bound to compact buffer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be verified. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true if there is any buffer_bind_scope attribute found, otherwise, false. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="233" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a64dd52c904c2944a4771b81a2cf8f08a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::RemoveNoOp</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>RemoveNoOp</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Remove No <ref refid="classtvm_1_1Op" kindref="compound">Op</ref> from the <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be trasnformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="240" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a319c8f6b65c8c053c87b429d6d791343" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::UnrollLoop</definition>
        <argsstring>(Stmt stmt, int auto_max_step, int auto_max_depth, int auto_max_extent, bool explicit_unroll)</argsstring>
        <name>UnrollLoop</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>auto_max_step</declname>
        </param>
        <param>
          <type>int</type>
          <declname>auto_max_depth</declname>
        </param>
        <param>
          <type>int</type>
          <declname>auto_max_extent</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>explicit_unroll</declname>
        </param>
        <briefdescription>
<para>unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statment to be unrolled. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>auto_max_step</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum step before stop attach automatic unroll </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>auto_max_depth</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum depth before stop attach automatic unroll </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>auto_max_extent</parametername>
</parameternamelist>
<parameterdescription>
<para>The maximum extent of the loop we can unroll, this is an legacy option that do not take the loop total steps into account. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>explicit_unroll</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether explicitly unroll the loop, or leave unroll annotation to codegen. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="254" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1abdd6d56877b9dd03803f433352b09060" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::VectorizeLoop</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>VectorizeLoop</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>vectorize the constant loops </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be vectorized. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="265" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a2f8fc7370ebc9a6b0de19ae9e597576f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::SkipVectorize</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>SkipVectorize</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>convert vectorized loops into serialized loops </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to skip vectorization on. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="272" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a604c5a3e5e7fad62a912b1d3bb41c3fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::InstrumentBoundCheckers</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>InstrumentBoundCheckers</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>instruments bound checkers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be instrumented. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Instrumented stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="279" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a8c9c2135e4a2a674c7ffe1f414d9b362" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::InjectVirtualThread</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>InjectVirtualThread</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Inject virtual thread loops into stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be transformed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="286" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a1d45de8cf5b6053ab16dde307a00238d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::InjectPrefetch</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>InjectPrefetch</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Inject prefetch instructions into stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be transformed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="293" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1abde051e07d9c7ba41d5676ce64208766" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::InjectDoubleBuffer</definition>
        <argsstring>(Stmt stmt, int split_loop)</argsstring>
        <name>InjectDoubleBuffer</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>int</type>
          <declname>split_loop</declname>
        </param>
        <briefdescription>
<para>Inject double buffer into stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be transformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split_loop</parametername>
</parameternamelist>
<parameterdescription>
<para>Loop splitting factor. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="301" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a3550907081d6332c5a4b0849e1948c79" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::InjectCopyIntrin</definition>
        <argsstring>(Stmt stmt, const std::string &amp;pragma_key, const runtime::PackedFunc &amp;fintrin)</argsstring>
        <name>InjectCopyIntrin</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>pragma_key</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">runtime::PackedFunc</ref> &amp;</type>
          <declname>fintrin</declname>
        </param>
        <briefdescription>
<para>Inject copy intrinsics with optional pad. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be transformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pragma_key</parametername>
</parameternamelist>
<parameterdescription>
<para>The pragma key for hint of copy. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fintrin</parametername>
</parameternamelist>
<parameterdescription>
<para>The function with signature</para></parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref> fintrin(<ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref> src, <ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref> dst, Array&lt;Expr&gt; pad_before, Array&lt;Expr&gt; pad_after, Expr pad_value) <simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="317" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a5b70ca88f988211332570160c82e3026" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::StorageRewrite</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>StorageRewrite</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be transformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="330" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae0606ab38faf2f31d42759f217fdec93" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::LoopPartition</definition>
        <argsstring>(Stmt stmt, bool split_const_loop)</argsstring>
        <name>LoopPartition</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>split_const_loop</declname>
        </param>
        <briefdescription>
<para>partition loops in the stmt </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to do loop partition </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>split_const_loop</parametername>
</parameternamelist>
<parameterdescription>
<para>flag to enable partition for const loop </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="338" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a9a890acc3681867fe74ad2207d17278f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::CoProcSync</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>CoProcSync</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Detect and insert sync points to co-processor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be transformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="346" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a799dff4f3a280576d6838694c151e657" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::LiftAttrScope</definition>
        <argsstring>(Stmt stmt, std::string attr_key)</argsstring>
        <name>LiftAttrScope</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>attr_key</declname>
        </param>
        <briefdescription>
<para>Lift common attrs with attr_key to outer scope. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be transformed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>attr_key</parametername>
</parameternamelist>
<parameterdescription>
<para>The attribute key to be checked. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="355" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a2c3a142f48991df5a96ee1791685ca64" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::RewriteUnsafeSelect</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>RewriteUnsafeSelect</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Detect and rewrite unsafe select that contains memory access. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be rewritten. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="362" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a3b6c7e53cce5184e897b0bd24adb06b6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::LowerStorageAccessInfo</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>LowerStorageAccessInfo</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Lower attached storage access information. Do this pass after all storage access analysis finish. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be transformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="371" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a1f89ddc934004f9e58b2e6ac3a260e3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::DecorateDeviceScope</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>DecorateDeviceScope</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be transformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="380" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a803eaac5980c445a9ff8e38fb2c595fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::HoistIfThenElse</definition>
        <argsstring>(Stmt stmt)</argsstring>
        <name>HoistIfThenElse</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Loop invariant code motion which locates and hoists if statements. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to do if statement hoisting. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed stmt. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="387" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ab2d44994c14f11c500586a007c782c84" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::MakeAPI</definition>
        <argsstring>(Stmt body, std::string name, Array&lt; ObjectRef &gt; api_args, int num_unpacked_args, bool is_restricted)</argsstring>
        <name>MakeAPI</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>body</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; ObjectRef &gt;</type>
          <declname>api_args</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_unpacked_args</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>is_restricted</declname>
        </param>
        <briefdescription>
<para>Make an user callable API <ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The main task of this function is to create code to :<itemizedlist>
<listitem><para><ref refid="classtvm_1_1Map" kindref="compound">Map</ref> the values in the api_args to <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> that is required by body.</para></listitem><listitem><para>Insert assertions to check type/value of the passed arguments.</para></listitem></itemizedlist>
</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>body</parametername>
</parameternamelist>
<parameterdescription>
<para>The body of the function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>api_args</parametername>
</parameternamelist>
<parameterdescription>
<para>Arguments to the function, can be either <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref>, or <ref refid="classtvm_1_1tir_1_1Buffer" kindref="compound">Buffer</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_unpacked_args</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of arguments that are processed in plain form instead of packed form. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>is_restricted</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether the caller can guarantee that each buffer argument do not overlap. It is recommended to set to true for optimized code if such invariant holds.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref> with the specified signiture.</para></simplesect>
<simplesect kind="note"><para>The function signature have two cases</para></simplesect>
let num_packed_args = len(api_args) - num_unpacked_args;</para><para>if num_packed_args is zero: f(api_arg_0, api_arg_1, .., api_arg_n) where n == len(api_args)</para><para>if num_packed_args is not zero: f(TVMArg* packed_args, int* packed_arg_type_ids, int num_packed_args, api_arg_k, api_arg_k+1, ... api_arg_n, TVMValue* out_ret_val, int* out_ret_tcode)</para><para>where n == len(api_args), k == num_packed_args</para><para>There is no thread_axis in generated function. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="423" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a1ac3af6813bf02262470992a3980a25a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::BindDeviceType</definition>
        <argsstring>(LoweredFunc func, int device_type)</argsstring>
        <name>BindDeviceType</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>func</declname>
        </param>
        <param>
          <type>int</type>
          <declname>device_type</declname>
        </param>
        <briefdescription>
<para>Bind the device type of host function to be device_type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be binded. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>device_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The device type to be binded. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The binded function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="435" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae110e02855d8bc12eb8b6f92ed391844" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &gt;</type>
        <definition>Array&lt;Var&gt; tvm::tir::UndefinedVars</definition>
        <argsstring>(const Stmt &amp;stmt, const Array&lt; Var &gt; &amp;defs)</argsstring>
        <name>UndefinedVars</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref> &amp;</type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &gt; &amp;</type>
          <declname>defs</declname>
        </param>
        <briefdescription>
<para>Find undefined vars in the statment. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be checked. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>defs</parametername>
</parameternamelist>
<parameterdescription>
<para>The vars that is defined. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtvm_1_1Array" kindref="compound">Array</ref> of undefined vars. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="443" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ac7f5e04aea66d87ad42baf957768c451" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref> &gt;</type>
        <definition>Array&lt;LoweredFunc&gt; tvm::tir::SplitHostDevice</definition>
        <argsstring>(LoweredFunc func)</argsstring>
        <name>SplitHostDevice</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>Split the function into a host function and device functions. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be splitted.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtvm_1_1Array" kindref="compound">Array</ref> of functions, the first one is host function, the others are device functions. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="452" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ab0df6d882d69f4ec8e1b146a0d8728f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::ThreadSync</definition>
        <argsstring>(LoweredFunc stmt, std::string storage_scope)</argsstring>
        <name>ThreadSync</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>storage_scope</declname>
        </param>
        <briefdescription>
<para>Insert sync between parallel read/write of shared buffers. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The stmt to be trasnformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>storage_scope</parametername>
</parameternamelist>
<parameterdescription>
<para>The storage scope considered. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="460" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a438729b72b0e38a28289d763b48995b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerThreadAllreduce</definition>
        <argsstring>(LoweredFunc f, int warp_size)</argsstring>
        <name>LowerThreadAllreduce</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>warp_size</declname>
        </param>
        <briefdescription>
<para>Lower cross thread alleduce in the stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>warp_size</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of warp where no sync is needed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="468" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1af5111eb3e9b9d2f52998c5db4b4e3ae9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerWarpMemory</definition>
        <argsstring>(LoweredFunc f, int warp_size)</argsstring>
        <name>LowerWarpMemory</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>int</type>
          <declname>warp_size</declname>
        </param>
        <briefdescription>
<para>Lower warp memory in stmt. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>warp_size</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of warp where no sync is needed. this function will only take in effect if warp_size is bigger than one. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="477" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ad55f17f026155f1424b3d0fdd3f86435" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::RemapThreadAxis</definition>
        <argsstring>(LoweredFunc f, Map&lt; PrimExpr, IterVar &gt; axis_map)</argsstring>
        <name>RemapThreadAxis</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref>, <ref refid="classtvm_1_1tir_1_1IterVar" kindref="compound">IterVar</ref> &gt;</type>
          <declname>axis_map</declname>
        </param>
        <briefdescription>
<para>Remap the thread axis. </para>        </briefdescription>
        <detaileddescription>
<para>This can be used to get equivalent program which uses threadIdx.y in place of threadIdx.x by passing {&quot;threadIdx.x&quot;: thread_axis(&quot;threadIdx.y&quot;)}</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis_map</parametername>
</parameternamelist>
<parameterdescription>
<para>The map from <ref refid="classtvm_1_1tir_1_1StringImm" kindref="compound">StringImm</ref> -&gt; ItrVar </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="491" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a9d59ba0cb48da1661593b7eeb2e96821" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerTVMBuiltin</definition>
        <argsstring>(LoweredFunc f)</argsstring>
        <name>LowerTVMBuiltin</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Lower packed function call. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be lowered. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="498" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a5c2b224ff5bb292b1b7e677d50576b38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::CombineContextCall</definition>
        <argsstring>(LoweredFunc f)</argsstring>
        <name>CombineContextCall</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Combine context function calls. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The host function to be lowered. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="505" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ad2814a5568d2e1329a5c5aab2e35091e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::PointerValueTypeRewrite</definition>
        <argsstring>(LoweredFunc f)</argsstring>
        <name>PointerValueTypeRewrite</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>implemeneted in storage_rewrite.cc </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be trasnformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="517" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1abbf2681c6850628b3c9b213298f056b3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1PrimFunc" kindref="compound">PrimFunc</ref></type>
        <definition>PrimFunc tvm::tir::PointerValueTypeRewrite</definition>
        <argsstring>(PrimFunc f)</argsstring>
        <name>PointerValueTypeRewrite</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1PrimFunc" kindref="compound">PrimFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>implemeneted in storage_rewrite.cc </para></simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be trasnformed </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="530" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1afcbd367b40fe2cd31d101c88a63a0b25" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerDeviceStorageAccessInfo</definition>
        <argsstring>(LoweredFunc func)</argsstring>
        <name>LowerDeviceStorageAccessInfo</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>Lower attached storage access information on device. Do this pass after all storage access analysis finish. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="539" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1adb8b5d13c11411299808c564adda2713" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerIntrin</definition>
        <argsstring>(LoweredFunc f, const std::string &amp;target)</argsstring>
        <name>LowerIntrin</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>target</declname>
        </param>
        <briefdescription>
<para>Lower intrinsic function calls. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>The target device. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="547" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ac8725d2ad12962353ec11b6285cc6b3d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::LowerCustomDatatypes</definition>
        <argsstring>(LoweredFunc f, const std::string &amp;target)</argsstring>
        <name>LowerCustomDatatypes</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>target</declname>
        </param>
        <briefdescription>
<para>Lower custom datatypes. </para>        </briefdescription>
        <detaileddescription>
<para>See tvm::datatypes::Registry for more information on adding custom datatypes.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>The target device. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="558" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1acd928ded601486ae3a3b787df3f09688" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::InferFragment</definition>
        <argsstring>(LoweredFunc f)</argsstring>
        <name>InferFragment</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>Infer the TensorCore fragment infomation using tensor intrinsics. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The device function to be lowered. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="566" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a9968b6563c42117a9a1cd4576054400f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
        <definition>LoweredFunc tvm::tir::SkipAssert</definition>
        <argsstring>(LoweredFunc f)</argsstring>
        <name>SkipAssert</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>f</declname>
        </param>
        <briefdescription>
<para>skip assert stmt generation </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be transformed. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Transformed function. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="573" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1aa649448c69d8324ba1fd7ec5e3e54731" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::VerifyMemory</definition>
        <argsstring>(LoweredFunc func, int device_type)</argsstring>
        <name>VerifyMemory</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1LoweredFunc" kindref="compound">LoweredFunc</ref></type>
          <declname>func</declname>
        </param>
        <param>
          <type>int</type>
          <declname>device_type</declname>
        </param>
        <briefdescription>
<para>Verify if memory accesses are legal for a specific target device type. </para>        </briefdescription>
        <detaileddescription>
<para>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>The function to be verified. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>device_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The target device type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Success of memory verification. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="586" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a705b3e58180a12eba5297cb2442fd1a2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::VerifyGPUCode</definition>
        <argsstring>(Stmt stmt, Map&lt; std::string, PrimExpr &gt; constraints)</argsstring>
        <name>VerifyGPUCode</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>stmt</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Map" kindref="compound">Map</ref>&lt; std::string, <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>constraints</declname>
        </param>
        <briefdescription>
<para>Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The statement to be checked </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>constraints</parametername>
</parameternamelist>
<parameterdescription>
<para>The dict to specify constraints to check. Possible keys are</para></parameterdescription>
</parameteritem>
</parameterlist>
&quot;max_local_memory_per_block&quot;: Total amount of local memory per block (in bytes). &quot;max_shared_memory_per_block&quot;: Total amount of shared memory per block (in bytes). &quot;max_threads_per_block&quot;: Maximum number of threads per block. &quot;max_thread_x&quot;: Maximum length of threadIdx.x. &quot;max_thread_y&quot;: Maximum length of threadIdx.y. &quot;max_thread_z&quot;: Maximum length of threadIdx.z.</para><para>If one key is missing in this argument, the pass won&apos;t check for that item. <simplesect kind="return"><para>valid Whether it is a valid GPU code </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/ir_pass.h" line="608" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a4ea566597880d04bd62fbec687e338b5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
          <param>
            <type>typename</type>
            <defval>typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::make_const</definition>
        <argsstring>(DataType t, ValueType value)</argsstring>
        <name>make_const</name>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>t</declname>
        </param>
        <param>
          <type>ValueType</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Make a const value with certain data type. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The target type. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>The input value </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the result expression. </para></simplesect>
<parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>ValueType</parametername>
</parameternamelist>
<parameterdescription>
<para>The constant value type </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="585" column="1" bodyfile="include/tvm/tir/op.h" bodystart="755" bodyend="762"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1adc4408508a413fb7f3b2567f8d847dbb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::make_zero</definition>
        <argsstring>(DataType t)</argsstring>
        <name>make_zero</name>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>t</declname>
        </param>
        <briefdescription>
<para>Make a const zero expr. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>t</parametername>
</parameternamelist>
<parameterdescription>
<para>The target type. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the result expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="591" column="1" bodyfile="include/tvm/tir/op.h" bodystart="764" bodyend="769"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ac40c127b53bca09d4c39f806a98dfdf8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::const_true</definition>
        <argsstring>(int lanes=1)</argsstring>
        <name>const_true</name>
        <param>
          <type>int</type>
          <declname>lanes</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Make a constant true expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lanes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of lanes in the bool </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="597" column="1" bodyfile="include/tvm/tir/op.h" bodystart="597" bodyend="599"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ae11cb5c6f810546e5aa4e08a0684071a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::const_false</definition>
        <argsstring>(int lanes=1)</argsstring>
        <name>const_false</name>
        <param>
          <type>int</type>
          <declname>lanes</declname>
          <defval>1</defval>
        </param>
        <briefdescription>
<para>Make a constant false expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>lanes</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of lanes in the bool </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The result expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="605" column="1" bodyfile="include/tvm/tir/op.h" bodystart="605" bodyend="607"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1acbe8f225faaf34c540194921a7ee6a66" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const int64_t *</type>
        <definition>const int64_t* tvm::tir::as_const_int</definition>
        <argsstring>(const PrimExpr &amp;x)</argsstring>
        <name>as_const_int</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Get x as constant int expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The expression </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the address to the int expression, return nullptr, if x is not <ref refid="classtvm_1_1IntImm" kindref="compound">IntImm</ref>. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="614" column="1" bodyfile="include/tvm/tir/op.h" bodystart="614" bodyend="621"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a5c414d5e54c099ad7287be302aac8f02" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_const_int</definition>
        <argsstring>(const PrimExpr &amp;x, int64_t value)</argsstring>
        <name>is_const_int</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int64_t</type>
          <declname>value</declname>
        </param>
        <briefdescription>
<para>Check whether x is a constant integer expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input argument </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>the value to be compared against. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether x is constant expression. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="629" column="1" bodyfile="include/tvm/tir/op.h" bodystart="704" bodyend="714"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a8de8f843c6eb433b6ddfbf34e24099ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_no_op</definition>
        <argsstring>(const tir::Stmt &amp;stmt)</argsstring>
        <name>is_no_op</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">tir::Stmt</ref> &amp;</type>
          <declname>stmt</declname>
        </param>
        <briefdescription>
<para>Check whether stmt is nop. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stmt</parametername>
</parameternamelist>
<parameterdescription>
<para>The input statement </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether stmt is nop </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="636" column="1" bodyfile="include/tvm/tir/op.h" bodystart="716" bodyend="725"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a9b5104dcf0933da31329bb0b2580a947" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_one</definition>
        <argsstring>(const PrimExpr &amp;x)</argsstring>
        <name>is_one</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Check whether x is a constant integer 1. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input argument. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="note"><para>This only return true for integer types. </para></simplesect>
<simplesect kind="return"><para>whether x is constant 1 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="644" column="1" bodyfile="include/tvm/tir/op.h" bodystart="644" bodyend="646"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a48bad3db162b334837716bf8e7ba9285" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_zero</definition>
        <argsstring>(const PrimExpr &amp;x)</argsstring>
        <name>is_zero</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Check whether x is a constant integer 0. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input argument </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether x is constant 0 </para></simplesect>
<simplesect kind="note"><para>This only return true for integer types. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="654" column="1" bodyfile="include/tvm/tir/op.h" bodystart="654" bodyend="656"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1ab706ef9860459b25068f3440d88a7193" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_const</definition>
        <argsstring>(const PrimExpr &amp;x)</argsstring>
        <name>is_const</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Check whether x is a constant. </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="note"><para>This only return true for integer types. </para></simplesect>
<simplesect kind="return"><para>whether x is constant </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="663" column="1" bodyfile="include/tvm/tir/op.h" bodystart="676" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a246623a4a0c9cd8f8a209ec952a8d1c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_const_power_of_two_integer</definition>
        <argsstring>(const PrimExpr &amp;x, int *shift)</argsstring>
        <name>is_const_power_of_two_integer</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>shift</declname>
        </param>
        <briefdescription>
<para>Check whether x is a constant power of two If x is power of two, write the power to the shift. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input expression. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>The output shift if x is power of two. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>whether x is constant power of two </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="673" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a782dc226f8b2b537efdc56b1f76351d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_positive_const</definition>
        <argsstring>(const PrimExpr &amp;a)</argsstring>
        <name>is_positive_const</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="688" column="1" bodyfile="include/tvm/tir/op.h" bodystart="688" bodyend="694"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a51d552441331effb387b7c8fb241c454" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tvm::tir::is_negative_const</definition>
        <argsstring>(const PrimExpr &amp;a)</argsstring>
        <name>is_negative_const</name>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>a</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="696" column="1" bodyfile="include/tvm/tir/op.h" bodystart="696" bodyend="702"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1af2ca71170aca9d397c2125eb4f55c197" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename ValueType</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::MakeConstScalar</definition>
        <argsstring>(DataType t, ValueType value)</argsstring>
        <name>MakeConstScalar</name>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>t</declname>
        </param>
        <param>
          <type>ValueType</type>
          <declname>value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/op.h" line="728" column="1" bodyfile="include/tvm/tir/op.h" bodystart="728" bodyend="752"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1afb1743e78389c4beaf0b788c631d424e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr tvm::tir::TypeAnnotation</definition>
        <argsstring>(DataType dtype)</argsstring>
        <name>TypeAnnotation</name>
        <param>
          <type><ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref></type>
          <declname>dtype</declname>
        </param>
        <briefdescription>
<para>Create a type annotation expression. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dtype</parametername>
</parameternamelist>
<parameterdescription>
<para>The data type </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Expr a expression with dtype. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt.h" line="946" column="1" bodyfile="include/tvm/tir/stmt.h" bodystart="946" bodyend="950"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a12a98cd1a8440b18d6bac0ad3eaa42ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream&amp; tvm::tir::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, ForType for_type)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type><ref refid="namespacetvm_1_1tir_1ae35cce8e3f1e8d7366dc0d9b15536736" kindref="member">ForType</ref></type>
          <declname>for_type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt.h" line="953" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a1217dd1b57e84b5901cf755251b9e164" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
        <definition>Stmt tvm::tir::IRTransform</definition>
        <argsstring>(Stmt node, const runtime::PackedFunc &amp;preorder, const runtime::PackedFunc &amp;postorder, const Array&lt; PrimExpr &gt; &amp;only_enable={})</argsstring>
        <name>IRTransform</name>
        <param>
          <type><ref refid="classtvm_1_1tir_1_1Stmt" kindref="compound">Stmt</ref></type>
          <declname>node</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">runtime::PackedFunc</ref> &amp;</type>
          <declname>preorder</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1runtime_1_1PackedFunc" kindref="compound">runtime::PackedFunc</ref> &amp;</type>
          <declname>postorder</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>only_enable</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
<para>recursively visit the ir in post DFS order node, and transform it </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para>The ir to be transformed. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>preorder</parametername>
</parameternamelist>
<parameterdescription>
<para>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won&apos;t do further recursion. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>postorder</parametername>
</parameternamelist>
<parameterdescription>
<para>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>only_enable</parametername>
</parameternamelist>
<parameterdescription>
<para>List of <ref refid="classtvm_1_1tir_1_1StringImm" kindref="compound">StringImm</ref>. If it is empty, all IRNode will call preorder/postorder If it is not empty, preorder/postorder will only be called when the IRNode&apos;s type key is in the list. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt_functor.h" line="331" column="1"/>
      </memberdef>
      <memberdef kind="function" id="namespacetvm_1_1tir_1a4b5067fa233d111c9db9cc402ed599c3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tvm::tir::PostOrderVisit</definition>
        <argsstring>(const ObjectRef &amp;node, std::function&lt; void(const ObjectRef &amp;)&gt; fvisit)</argsstring>
        <name>PostOrderVisit</name>
        <param>
          <type>const ObjectRef &amp;</type>
          <declname>node</declname>
        </param>
        <param>
          <type>std::function&lt; void(const ObjectRef &amp;)&gt;</type>
          <declname>fvisit</declname>
        </param>
        <briefdescription>
<para>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para>The ir to be visited. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fvisit</parametername>
</parameternamelist>
<parameterdescription>
<para>The visitor function to be applied. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/tvm/tir/stmt_functor.h" line="342" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/tvm/tir/buffer.h" line="35" column="1"/>
  </compounddef>
</doxygen>
