<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="namespacetopi_1_1nn" kind="namespace" language="C++">
    <compoundname>topi::nn</compoundname>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" prot="public" static="no">
        <name>PoolType</name>
        <enumvalue id="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95babbfb6c4315c8b57e558600af1515d3d8" prot="public">
          <name>kAvgPool</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95ba3a406a1361a3c7ca311d3c514842c2f4" prot="public">
          <name>kMaxPool</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Pooling type. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="43" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="43" bodyend="46"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetopi_1_1nn_1a607b758a01a9350507e44670cecfbbb1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref></type>
        <definition>tvm::te::Tensor topi::nn::batch_matmul</definition>
        <argsstring>(const tvm::te::Tensor &amp;x, const tvm::te::Tensor &amp;y)</argsstring>
        <name>batch_matmul</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>y</declname>
        </param>
        <briefdescription>
<para>Creates an operation that calculates matrix multiplication in batch. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch, M, K] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>y</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch, N, K]</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tensor with shape [batch, M, N] </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/batch_matmul.h" line="45" column="1" bodyfile="topi/include/topi/nn/batch_matmul.h" bodystart="45" bodyend="63"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1aff898fc8b6170d953782a01f6fc0e63f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref></type>
        <definition>tvm::te::Tensor topi::nn::bias_add</definition>
        <argsstring>(const tvm::te::Tensor &amp;data, const tvm::te::Tensor &amp;bias, int axis)</argsstring>
        <name>bias_add</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>bias</declname>
        </param>
        <param>
          <type>int</type>
          <declname>axis</declname>
        </param>
        <briefdescription>
<para>Creates an operation that calculates data + bias. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch, in_dim] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bias</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch]. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>The axis to add the bias to. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tensor with shape [batch, in_dim] </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/bias_add.h" line="45" column="1" bodyfile="topi/include/topi/nn/bias_add.h" bodystart="45" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a01028bdee00ceef9f58fd29e4fceeaad" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref></type>
        <definition>tvm::te::Tensor topi::nn::binarize_pack</definition>
        <argsstring>(const tvm::te::Tensor &amp;data, int axis, std::string name=&quot;PackedInput&quot;, std::string tag=&quot;binarize_pack&quot;)</argsstring>
        <name>binarize_pack</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>axis</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;PackedInput&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;binarize_pack&quot;</defval>
        </param>
        <briefdescription>
<para>Binarization and bit-packing along a certain axis. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>N-D tensor, can be any layout </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>The axis along which to do binarization and bit-packing. This axis must have a size equal to an integer multiple of 32. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Output tensor with dtype uint32 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/bnn.h" line="50" column="1" bodyfile="topi/include/topi/nn/bnn.h" bodystart="50" bodyend="92"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1acedfa473f37183df3c8188b667bb7594" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref></type>
        <definition>tvm::te::Tensor topi::nn::binary_dense</definition>
        <argsstring>(const tvm::te::Tensor &amp;data, const tvm::te::Tensor &amp;weight)</argsstring>
        <name>binary_dense</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>weight</declname>
        </param>
        <briefdescription>
<para>Binary matrix multiplication using xor and bit-count. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch, in_dim], dtype is uint32 </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>weight</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [out_dim, in_dim], dtype is uint32</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tensor with shape [batch, out_dim], dtype is float32 </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/bnn.h" line="102" column="1" bodyfile="topi/include/topi/nn/bnn.h" bodystart="102" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1abe55c065905a614f105da095a7f036ea" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref></type>
        <definition>tvm::te::Tensor topi::nn::dense</definition>
        <argsstring>(const tvm::te::Tensor &amp;data, const tvm::te::Tensor &amp;weight, const tvm::te::Tensor &amp;bias, const DataType &amp;out_dtype)</argsstring>
        <name>dense</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>weight</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">tvm::te::Tensor</ref> &amp;</type>
          <declname>bias</declname>
        </param>
        <param>
          <type>const <ref refid="namespacetvm_1a41918af1a1dc386388639a9d3ad06c5d" kindref="member">DataType</ref> &amp;</type>
          <declname>out_dtype</declname>
        </param>
        <briefdescription>
<para>Creates an operation that calculates data * weight^T + bias. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [batch, in_dim] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>weight</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [out_dim, in_dim] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bias</parametername>
</parameternamelist>
<parameterdescription>
<para>Tensor with shape [out_dim]. Optional; to omit bias, pass Tensor() </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>out_dtype</parametername>
</parameternamelist>
<parameterdescription>
<para>Output data type. Used for mixed precision.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Tensor with shape [batch, out_dim] </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/dense.h" line="47" column="1" bodyfile="topi/include/topi/nn/dense.h" bodystart="47" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ad57ccdad6f841aaafa2f64062f249a47" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr topi::nn::all</definition>
        <argsstring>(Array&lt; PrimExpr &gt; args)</argsstring>
        <name>all</name>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>Create a new expression of the logical and of all conditions in the arguments. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The arguments to find the logical conjunction of</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The logical conjunction expression </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/dilate.h" line="46" column="1" bodyfile="topi/include/topi/nn/dilate.h" bodystart="46" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a6ac795264be73287d92fcd7be8943ddc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::dilate</definition>
        <argsstring>(const Tensor &amp;x, Array&lt; PrimExpr &gt; strides, std::string name=&quot;tensor&quot;, std::string tag=kInjective)</argsstring>
        <name>dilate</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt;</type>
          <declname>strides</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval><ref refid="namespacetopi_1a60f05ec416e4618d25ad00dd9f536934" kindref="member">kInjective</ref></defval>
        </param>
        <briefdescription>
<para>Dilate data with zeros. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor, this can have any number of dimensions and any layout. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>strides</parametername>
</parameternamelist>
<parameterdescription>
<para>Dilation stride for each dimension. Stride 1 means no dilation. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/dilate.h" line="68" column="1" bodyfile="topi/include/topi/nn/dilate.h" bodystart="68" bodyend="103"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a84054f5c8010db45e80365c3c2c6e1d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::flatten</definition>
        <argsstring>(const Tensor &amp;x, std::string name=&quot;tensor&quot;, std::string tag=kInjective)</argsstring>
        <name>flatten</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval><ref refid="namespacetopi_1a60f05ec416e4618d25ad00dd9f536934" kindref="member">kInjective</ref></defval>
        </param>
        <briefdescription>
<para>Flattens the input tensor into a 2-D tensor by collapsing higher dimensions. This requires the input tensor to have constant sized dimensions. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A 2-D tensor. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/flatten.h" line="49" column="1" bodyfile="topi/include/topi/nn/flatten.h" bodystart="49" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a0ded232c2572637db6adc7cf5f0b35b2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::lrn</definition>
        <argsstring>(const Tensor &amp;data, int size, int axis=1, float alpha=0.0001, float beta=0.75, float bias=2, std::string name=&quot;tensor&quot;, std::string tag=kBroadcast)</argsstring>
        <name>lrn</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>size</declname>
        </param>
        <param>
          <type>int</type>
          <declname>axis</declname>
          <defval>1</defval>
        </param>
        <param>
          <type>float</type>
          <declname>alpha</declname>
          <defval>0.0001</defval>
        </param>
        <param>
          <type>float</type>
          <declname>beta</declname>
          <defval>0.75</defval>
        </param>
        <param>
          <type>float</type>
          <declname>bias</declname>
          <defval>2</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval><ref refid="namespacetopi_1a794b9155e9ba9d1c9c42a1cff1fb645f" kindref="member">kBroadcast</ref></defval>
        </param>
        <briefdescription>
<para>Local response normalization inference operator. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. 4-D shape NCHW or NHWC </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>Integer to define normalisation window size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>Input data layout channel axis </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alpha</parametername>
</parameternamelist>
<parameterdescription>
<para>Float scaling factor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>beta</parametername>
</parameternamelist>
<parameterdescription>
<para>Exponent value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bias</parametername>
</parameternamelist>
<parameterdescription>
<para>Offset to avoid dividing by zero </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Tensor whose op member is the Local response normalization operation </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/local_response_norm.h" line="51" column="1" bodyfile="topi/include/topi/nn/local_response_norm.h" bodystart="51" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ae9516b844130a2189ad2989b646ec2b1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::scale_shift_nchw</definition>
        <argsstring>(const Tensor &amp;x, const Tensor &amp;scale, const Tensor &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=kBroadcast)</argsstring>
        <name>scale_shift_nchw</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>shift</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;ScaleShift&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval><ref refid="namespacetopi_1a794b9155e9ba9d1c9c42a1cff1fb645f" kindref="member">kBroadcast</ref></defval>
        </param>
        <briefdescription>
<para>Scale and shift with NCHW order. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale</parametername>
</parameternamelist>
<parameterdescription>
<para>Scale tensor, 1-D of size channel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>Shift tensor, 1-D of size channel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Tensor whose op member is the scale shift operation </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/mapping.h" line="48" column="1" bodyfile="topi/include/topi/nn/mapping.h" bodystart="48" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ab19179f1b4a73a42b17ddf2f5fea46fc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::scale_shift_nhwc</definition>
        <argsstring>(const Tensor &amp;x, const Tensor &amp;scale, const Tensor &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=kBroadcast)</argsstring>
        <name>scale_shift_nhwc</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>scale</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>shift</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;ScaleShift&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval><ref refid="namespacetopi_1a794b9155e9ba9d1c9c42a1cff1fb645f" kindref="member">kBroadcast</ref></defval>
        </param>
        <briefdescription>
<para>Scale and shift with NHWC order. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scale</parametername>
</parameternamelist>
<parameterdescription>
<para>Scale tensor, 1-D of size channel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>shift</parametername>
</parameternamelist>
<parameterdescription>
<para>Shift tensor, 1-D of size channel </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Tensor whose op member is the scale shift operation </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/mapping.h" line="71" column="1" bodyfile="topi/include/topi/nn/mapping.h" bodystart="71" bodyend="81"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ad51533b09956d7bc8de2537adf3b6b77" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool_impl</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const size_t height_axis, const size_t width_axis, bool count_include_pad)</argsstring>
        <name>pool_impl</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>height_axis</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>width_axis</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
        </param>
        <briefdescription>
<para>Perform pooling on height and width dimension of data. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {kernel_height, kernel_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {stride_height, stride_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {padding_height, padding_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>height_axis</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the height dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>width_axis</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the width dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in same layout order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="64" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="64" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1af2c25e8b3ab3cac1c2896cb750838337" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool_grad_impl</definition>
        <argsstring>(const Tensor &amp;out_grad, const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const size_t height_axis, const size_t width_axis, bool count_include_pad)</argsstring>
        <name>pool_grad_impl</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>out_grad</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>height_axis</declname>
        </param>
        <param>
          <type>const size_t</type>
          <declname>width_axis</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="174" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="174" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a2e81a7938a1e3f273e184e2373d9138d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool topi::nn::find_depth_height_width</definition>
        <argsstring>(const std::string &amp;layout, int *depth_axis, int *height_axis, int *width_axis)</argsstring>
        <name>find_depth_height_width</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>depth_axis</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>height_axis</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>width_axis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="344" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="344" bodyend="371"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a428e0ba6800ef89b8c1f97f0245e244d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool topi::nn::find_height_width</definition>
        <argsstring>(const std::string &amp;layout, int *height_axis, int *width_axis)</argsstring>
        <name>find_height_width</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>height_axis</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>width_axis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="373" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="373" bodyend="382"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ab1f1f9f86723b30bb8997615e1d63ca8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool topi::nn::find_width</definition>
        <argsstring>(const std::string &amp;layout, int *width_axis)</argsstring>
        <name>find_width</name>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>width_axis</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="384" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="384" bodyend="392"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ac1708b3aa1a677f56a4063a568945d98" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCHW&quot;, bool count_include_pad=true)</argsstring>
        <name>pool</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCHW&quot;</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Perform pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which &apos;W&apos; and &apos;H&apos; means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {kernel_height, kernel_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {stride_height, stride_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {padding_height, padding_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. Pooling supports any layout as long as &apos;H&apos; and &apos;W&apos; appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>H</computeroutput> and <computeroutput>W</computeroutput>, one can pass <computeroutput>NCHWc</computeroutput> as well. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation when pool_type is &apos;avg&apos;</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in the same layout </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="423" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="423" bodyend="437"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a4f915567f195ade4a17743a5e7654e88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool_grad</definition>
        <argsstring>(const Tensor &amp;out_grad, const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCHW&quot;, bool count_include_pad=true)</argsstring>
        <name>pool_grad</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>out_grad</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCHW&quot;</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Calculate gradient of pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which &apos;W&apos; and &apos;H&apos; means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>out_grad</parametername>
</parameternamelist>
<parameterdescription>
<para>The output gradient tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {kernel_height, kernel_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {stride_height, stride_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {padding_height, padding_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. Pooling supports any layout as long as &apos;H&apos; and &apos;W&apos; appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>H</computeroutput> and <computeroutput>W</computeroutput>, one can pass <computeroutput>NCHWc</computeroutput> as well. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation when pool_type is &apos;avg&apos;</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in the same layout </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="469" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="469" bodyend="477"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a91b52c68356d23123474ebf10f9b0140" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr topi::nn::start_index</definition>
        <argsstring>(const Var &amp;out_index, const PrimExpr &amp;odim, const PrimExpr &amp;idim)</argsstring>
        <name>start_index</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &amp;</type>
          <declname>out_index</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>odim</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>idim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="479" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="479" bodyend="483"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1aadbaaec56f0b485262bf5199bbe3dcb3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref></type>
        <definition>PrimExpr topi::nn::end_index</definition>
        <argsstring>(const Var &amp;out_index, const PrimExpr &amp;odim, const PrimExpr &amp;idim)</argsstring>
        <name>end_index</name>
        <param>
          <type>const <ref refid="classtvm_1_1tir_1_1Var" kindref="compound">Var</ref> &amp;</type>
          <declname>out_index</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>odim</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &amp;</type>
          <declname>idim</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="485" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="485" bodyend="491"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ad4f34df5cfa8dc75843116bc39f06066" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::adaptive_pool_impl</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;output_size, PoolType pool_type, const std::vector&lt; int &gt; &amp;axes)</argsstring>
        <name>adaptive_pool_impl</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>output_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>axes</declname>
        </param>
        <briefdescription>
<para>Perform adaptive pooling on N dimensional data. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_size</parametername>
</parameternamelist>
<parameterdescription>
<para>int vector of size in each dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axes</parametername>
</parameternamelist>
<parameterdescription>
<para>indices of each dimension</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in same layout order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="503" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="503" bodyend="566"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1af721a019c13f1f99dc43d5d49cc71388" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::adaptive_pool</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;output_size, PoolType pool_type, const std::string &amp;layout=&quot;NCHW&quot;)</argsstring>
        <name>adaptive_pool</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>output_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCHW&quot;</defval>
        </param>
        <briefdescription>
<para>Adaptively perform pooling on height and width dimension of data. The pooling kernel and stride sizes are automatically chosen for desired output sizes. It decides the height and width dimension according to the layout string, in which &apos;W&apos; and &apos;H&apos; means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of two ints: {output_height, output_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. Pooling supports any layout as long as &apos;H&apos; and &apos;W&apos; appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>H</computeroutput> and <computeroutput>W</computeroutput>, one can pass <computeroutput>NCHWc</computeroutput> as well.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in same layout order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="594" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="594" bodyend="602"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ad48c57c26ce6bb02576555a4cb11bcd3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::adaptive_pool3d</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;output_size, PoolType pool_type, const std::string &amp;layout=&quot;NCDHW&quot;)</argsstring>
        <name>adaptive_pool3d</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>output_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCDHW&quot;</defval>
        </param>
        <briefdescription>
<para>Adaptively perform pooling on three dimensional data. See the two dimensional version above for details. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of three ints: {output_depth, output_height, output_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. The default is &quot;NCDHW&quot;. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="612" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="612" bodyend="620"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1ac5fe64687aa8bffee420bf282f2b8f8c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::global_pool</definition>
        <argsstring>(const Tensor &amp;x, PoolType pool_type, const std::string &amp;layout=&quot;NCHW&quot;)</argsstring>
        <name>global_pool</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCHW&quot;</defval>
        </param>
        <briefdescription>
<para>Perform global pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which &apos;W&apos; and &apos;H&apos; means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, ... are valid for global_pool, while NCHW16w, NCHW16h are not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor represent as layout </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. global-pooling supports any layout as long as &apos;H&apos; and &apos;W&apos; appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the sub-dimension. For example, <computeroutput>NCHW16c</computeroutput> can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>H</computeroutput> and <computeroutput>W</computeroutput>, one can pass <computeroutput>NCHWc</computeroutput> as well.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in same layout with height and width dimension size of 1. e.g., for NCHW, the output shape will be [batch, channel, 1, 1] </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="647" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="647" bodyend="651"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a0b2681e29b1f733835ffe2e6b3b69c13" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool_impl_nd</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const std::vector&lt; int &gt; &amp;axis, bool count_include_pad)</argsstring>
        <name>pool_impl_nd</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const std::vector&lt; int &gt; &amp;</type>
          <declname>axis</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
        </param>
        <briefdescription>
<para>Perform pooling on N-dimension of data. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of N ints </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of N ints </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of N*2 ints [head_pad_d1, head_pad_d2, ..., head_pad_dN, tail_pad_d1, tail_pad_d2, ..., tail_pad_dN] </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of indices for the N dimensions </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in same layout order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="668" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="668" bodyend="782"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a379dfcc1d33774fb4ce998550dda187c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool1d</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCW&quot;, bool count_include_pad=true)</argsstring>
        <name>pool1d</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCW&quot;</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Perform pooling on the width dimension of data. Width axis is determined by the layout string in which &apos;W&apos; means width. Width dimension cannot be split. For example, NCW, NCW16c, etc. are valid for pool, while NCW16w is not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of three ints: {kernel_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of three ints: {stride_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of six ints: {head_pad_width, tail_pad_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. Pooling supports any layout as long as &apos;W&apos; appears. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCW16c can describe a 4-D tensor of [batch_size, channel, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>W</computeroutput>, one can pass <computeroutput>NCWc</computeroutput> as well. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation when pool_type is &apos;avg&apos;</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in the same layout </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="813" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="813" bodyend="827"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1af84c2ac0c1fd4ec7db5c9bc661bd5aab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::pool3d</definition>
        <argsstring>(const Tensor &amp;x, const Array&lt; PrimExpr &gt; &amp;kernel_size, const Array&lt; PrimExpr &gt; &amp;stride_size, const Array&lt; PrimExpr &gt; &amp;padding_size, PoolType pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCDHW&quot;, bool count_include_pad=true)</argsstring>
        <name>pool3d</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>kernel_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>stride_size</declname>
        </param>
        <param>
          <type>const <ref refid="classtvm_1_1Array" kindref="compound">Array</ref>&lt; <ref refid="classtvm_1_1PrimExpr" kindref="compound">PrimExpr</ref> &gt; &amp;</type>
          <declname>padding_size</declname>
        </param>
        <param>
          <type><ref refid="namespacetopi_1_1nn_1ac531cfce9c3a031fa25cfb6ed1f9b95b" kindref="member">PoolType</ref></type>
          <declname>pool_type</declname>
        </param>
        <param>
          <type>bool</type>
          <declname>ceil_mode</declname>
        </param>
        <param>
          <type>const std::string &amp;</type>
          <declname>layout</declname>
          <defval>&quot;NCDHW&quot;</defval>
        </param>
        <param>
          <type>bool</type>
          <declname>count_include_pad</declname>
          <defval>true</defval>
        </param>
        <briefdescription>
<para>Perform pooling on depth, height and width dimension of data. It decides the depth, height and width dimension according to the layout string, in which &apos;D&apos;, &apos;W&apos; and &apos;H&apos; means depth, width and height respectively. Depth, Width and height dimension cannot be split. For example, NCDHW, NCDHW16c, etc. are valid for pool, while NCDHW16d, NCDHW16w or NCDHW16h are not. See <emphasis>layout</emphasis> for more information of the layout string convention. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>kernel_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of three ints: {kernel_depth, kernel_height, kernel_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stride_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of three ints: {stride_depth, stride_height, stride_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>padding_size</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector of six ints: {head_pad_depth, head_pad_height, head_pad_width, tail_pad_depth, tail_pad_height, tail_pad_width} </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool_type</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of pooling operator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ceil_mode</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether to use ceil when calculating the output size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>layout</parametername>
</parameternamelist>
<parameterdescription>
<para>The input layout. Pooling supports any layout as long as &apos;D&apos;, &apos;H&apos; and &apos;W&apos; appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCDHW16c can describe a 6-D tensor of [batch_size, channel, depth, height, width, channel_block]. (in which factor size <computeroutput>16</computeroutput> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <computeroutput>D</computeroutput>, <computeroutput>H</computeroutput> and <computeroutput>W</computeroutput>, one can pass <computeroutput>NCDHWc</computeroutput> as well. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count_include_pad</parametername>
</parameternamelist>
<parameterdescription>
<para>Whether include padding in the calculation when pool_type is &apos;avg&apos;</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The output tensor in the same layout </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/pooling.h" line="859" column="1" bodyfile="topi/include/topi/nn/pooling.h" bodystart="859" bodyend="873"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a1c845f2e02a677c556929d41a399e729" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::softmax</definition>
        <argsstring>(const Tensor &amp;x, int axis=-1, std::string name=&quot;tensor&quot;, std::string tag=&quot;softmax_output&quot;)</argsstring>
        <name>softmax</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>int</type>
          <declname>axis</declname>
          <defval>-1</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;softmax_output&quot;</defval>
        </param>
        <briefdescription>
<para>Softmax activation. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. Can be any dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>axis</parametername>
</parameternamelist>
<parameterdescription>
<para>The channel axis along which softmax is performed </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Tensor whose op member is the softmax operation </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/softmax.h" line="49" column="1" bodyfile="topi/include/topi/nn/softmax.h" bodystart="49" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="namespacetopi_1_1nn_1a667b9b98da3fd9a918a603d1b8aad5d7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref></type>
        <definition>Tensor topi::nn::log_softmax</definition>
        <argsstring>(const Tensor &amp;x, std::string name=&quot;tensor&quot;, std::string tag=&quot;log_softmax_output&quot;)</argsstring>
        <name>log_softmax</name>
        <param>
          <type>const <ref refid="classtvm_1_1te_1_1Tensor" kindref="compound">Tensor</ref> &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>std::string</type>
          <declname>name</declname>
          <defval>&quot;tensor&quot;</defval>
        </param>
        <param>
          <type>std::string</type>
          <declname>tag</declname>
          <defval>&quot;log_softmax_output&quot;</defval>
        </param>
        <briefdescription>
<para>Log softmax activation. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The input tensor. 2-D where log softmax is performed along the second dimension </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the operation </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tag</parametername>
</parameternamelist>
<parameterdescription>
<para>The tag to mark the operation</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A Tensor whose op member is the log softmax operation </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="topi/include/topi/nn/softmax.h" line="133" column="1" bodyfile="topi/include/topi/nn/softmax.h" bodystart="133" bodyend="155"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="topi/include/topi/nn/batch_matmul.h" line="33" column="1"/>
  </compounddef>
</doxygen>
