<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::runtime Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1runtime.html">runtime</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::runtime Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1symbol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1symbol.html">symbol</a></td></tr>
<tr class="memdesc:namespacetvm_1_1runtime_1_1symbol"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for constant symbols <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1threading"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1threading.html">threading</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1runtime_1_1vm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime_1_1vm.html">vm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADT.html">ADT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to algebraic data type objects.  <a href="classtvm_1_1runtime_1_1ADT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ADTObj.html">ADTObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing a structure or enumeration.  <a href="classtvm_1_1runtime_1_1ADTObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime primitive data type.  <a href="classtvm_1_1runtime_1_1DataType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1DeviceAPI.html">DeviceAPI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TVM Runtime Device API, abstracts the device specific interface for memory management.  <a href="classtvm_1_1runtime_1_1DeviceAPI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1InplaceArrayBase.html">InplaceArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for classes with array like memory layout.  <a href="classtvm_1_1runtime_1_1InplaceArrayBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Module.html">Module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Module.html" title="Module container of TVM. ">Module</a> container of TVM.  <a href="classtvm_1_1runtime_1_1Module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ModuleNode.html">ModuleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base container of module.  <a href="classtvm_1_1runtime_1_1ModuleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1NDArray.html">NDArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a>. The array is backed by reference counted blocks.  <a href="classtvm_1_1runtime_1_1NDArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjAllocatorBase.html">ObjAllocatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of object allocators that implements make. Use curiously recurring template pattern.  <a href="classtvm_1_1runtime_1_1ObjAllocatorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of all object containers.  <a href="classtvm_1_1runtime_1_1Object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectEqual.html">ObjectEqual</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> equal functor.  <a href="structtvm_1_1runtime_1_1ObjectEqual.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectHash.html">ObjectHash</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html" title="Base class of all object reference. ">ObjectRef</a> hash functor.  <a href="structtvm_1_1runtime_1_1ObjectHash.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom smart pointer for <a class="el" href="classtvm_1_1runtime_1_1Object.html" title="base class of all object containers. ">Object</a>.  <a href="classtvm_1_1runtime_1_1ObjectPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all object reference.  <a href="classtvm_1_1runtime_1_1ObjectRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker.html">ObjectTypeChecker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> traits for runtime type check during FFI conversion.  <a href="structtvm_1_1runtime_1_1ObjectTypeChecker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4.html">ObjectTypeChecker&lt; Array&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4.html">ObjectTypeChecker&lt; Map&lt; K, V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>ObjectTypeChecker&lt; Map&lt; std::string, V &gt; &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">PackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packed function is a type-erased function. The arguments are passed by packed format.  <a href="classtvm_1_1runtime_1_1PackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1runtime_1_1Registry.html" title="Registry for global function. ">Registry</a> for global function.  <a href="classtvm_1_1runtime_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1SimpleObjAllocator.html">SimpleObjAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1String.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to string objects.  <a href="classtvm_1_1runtime_1_1String.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1StringObj.html">StringObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object representing string. It's POD type.  <a href="classtvm_1_1runtime_1_1StringObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgs.html">TVMArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arguments into TVM functions.  <a href="classtvm_1_1runtime_1_1TVMArgs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgsSetter.html">TVMArgsSetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html">TVMArgValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A single argument value to <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a>. Containing both type_code and <a class="el" href="unionTVMValue.html" title="Union type of values being passed through API and function calls. ">TVMValue</a>.  <a href="classtvm_1_1runtime_1_1TVMArgValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMPODValue__.html">TVMPODValue_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal base class to handle conversion to POD values.  <a href="classtvm_1_1runtime_1_1TVMPODValue__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TVMRetValue.html">TVMRetValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Value container, Unlike <a class="el" href="classtvm_1_1runtime_1_1TVMArgValue.html" title="A single argument value to PackedFunc. Containing both type_code and TVMValue. ">TVMArgValue</a>, which only holds reference and do not delete the underlying container during destruction.  <a href="classtvm_1_1runtime_1_1TVMRetValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">TypedPackedFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Please refer to <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#TypedPackedFuncAnchor">TypedPackedFunc&lt;R(Args..)&gt;</a>.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html">TypedPackedFunc&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a> wrapper to provide typed function signature. It is backed by a <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html" title="Packed function is a type-erased function. The arguments are passed by packed format. ">PackedFunc</a> internally.  <a href="classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">DeviceAttrKind</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb">kExist</a> = 0, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4">kMaxThreadsPerBlock</a> = 1, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da">kWarpSize</a> = 2, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264">kMaxSharedMemoryPerBlock</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b">kComputeVersion</a> = 4, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca">kDeviceName</a> = 5, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630">kMaxClockRate</a> = 6, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd">kMultiProcessorCount</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991">kMaxThreadDimensions</a> = 8, 
<a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201">kGcnArch</a> = 9
<br />
 }<tr class="memdesc:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="mdescLeft">&#160;</td><td class="mdescRight">the query type into GetAttr  <a href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a46fef1ca0ccc05473e9bb0a8c6b66619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d395cd724f727e86358b73b5cdeb4e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4">TypeIndex</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4a1b73281b45b997205b5082ba53300d6a">kRoot</a> = 0, 
<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4a626309e16a9075cc8009c93adf3fbc9f">kClosure</a> = 1, 
<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4a86d9bc218c0f54443cbbe3fcc5c8382e">kVMADT</a> = 2, 
<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4af5474ebdbaaa19e977334eefa4bbd611">kRuntimeModule</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4a548302094bc9afb6bb14dc2a283c1014">kStaticIndexEnd</a>, 
<a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4a633f5947b3a79c577b538cec7528f5aa">kDynamic</a> = kStaticIndexEnd
<br />
 }<tr class="memdesc:a7d395cd724f727e86358b73b5cdeb4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of the type index.  <a href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a7d395cd724f727e86358b73b5cdeb4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af22b89284299c81d0c1802199af446d7"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#af22b89284299c81d0c1802199af446d7">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;n)</td></tr>
<tr class="separator:af22b89284299c81d0c1802199af446d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01a53416152b68029d67190c3709d25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad01a53416152b68029d67190c3709d25">GetVectorBytes</a> (<a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> dtype)</td></tr>
<tr class="memdesc:ad01a53416152b68029d67190c3709d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes needed in a vector.  <a href="#ad01a53416152b68029d67190c3709d25">More...</a><br /></td></tr>
<tr class="separator:ad01a53416152b68029d67190c3709d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adbabb7cfb79bfb6d802f65a9803e4eb6">TypeMatch</a> (DLDataType t, int code, int bits, int lanes=1)</td></tr>
<tr class="memdesc:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether type matches the given spec.  <a href="#adbabb7cfb79bfb6d802f65a9803e4eb6">More...</a><br /></td></tr>
<tr class="separator:adbabb7cfb79bfb6d802f65a9803e4eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee574cee6755b0c2f1aa664c6967686f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aee574cee6755b0c2f1aa664c6967686f">TypeEqual</a> (DLDataType lhs, DLDataType rhs)</td></tr>
<tr class="memdesc:aee574cee6755b0c2f1aa664c6967686f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether two types are equal .  <a href="#aee574cee6755b0c2f1aa664c6967686f">More...</a><br /></td></tr>
<tr class="separator:aee574cee6755b0c2f1aa664c6967686f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9109e4efe269213052ed6a94853c0c00"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a9109e4efe269213052ed6a94853c0c00">DeviceName</a> (int type)</td></tr>
<tr class="memdesc:a9109e4efe269213052ed6a94853c0c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of Device API factory.  <a href="#a9109e4efe269213052ed6a94853c0c00">More...</a><br /></td></tr>
<tr class="separator:a9109e4efe269213052ed6a94853c0c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce391c2492dfc73b5c6c6459693c6a6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a0ce391c2492dfc73b5c6c6459693c6a6">operator&lt;&lt;</a> (std::ostream &amp;os, DLContext ctx)</td></tr>
<tr class="separator:a0ce391c2492dfc73b5c6c6459693c6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93466f4543eedc3925c66ed0e7ef2671"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a93466f4543eedc3925c66ed0e7ef2671"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a93466f4543eedc3925c66ed0e7ef2671">make_object</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a93466f4543eedc3925c66ed0e7ef2671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate an object using default allocator.  <a href="#a93466f4543eedc3925c66ed0e7ef2671">More...</a><br /></td></tr>
<tr class="separator:a93466f4543eedc3925c66ed0e7ef2671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144496aaff68cd251b6bc0a7b24ca041"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </td></tr>
<tr class="memitem:a144496aaff68cd251b6bc0a7b24ca041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; ArrayType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a144496aaff68cd251b6bc0a7b24ca041">make_inplace_array_object</a> (size_t num_elems, Args &amp;&amp;...args)</td></tr>
<tr class="separator:a144496aaff68cd251b6bc0a7b24ca041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbea0c23882ae01431ac7fe6506b32a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#abbea0c23882ae01431ac7fe6506b32a7">RuntimeEnabled</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:abbea0c23882ae01431ac7fe6506b32a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if runtime module is enabled for target.  <a href="#abbea0c23882ae01431ac7fe6506b32a7">More...</a><br /></td></tr>
<tr class="separator:abbea0c23882ae01431ac7fe6506b32a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8fb37910dcd9bb6899e6a3a47f006514">SaveDLTensor</a> (dmlc::Stream *strm, const DLTensor *tensor)</td></tr>
<tr class="memdesc:a8fb37910dcd9bb6899e6a3a47f006514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a DLTensor to stream.  <a href="#a8fb37910dcd9bb6899e6a3a47f006514">More...</a><br /></td></tr>
<tr class="separator:a8fb37910dcd9bb6899e6a3a47f006514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59940b6d63dd4c5175c0fe875047c1cf">GetDataSize</a> (const DLTensor &amp;arr)</td></tr>
<tr class="memdesc:a59940b6d63dd4c5175c0fe875047c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of data the DLTensor hold, in term of number of bytes  <a href="#a59940b6d63dd4c5175c0fe875047c1cf">More...</a><br /></td></tr>
<tr class="separator:a59940b6d63dd4c5175c0fe875047c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2ed1227b418f5846d43d3234b52391"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#adb2ed1227b418f5846d43d3234b52391">IsContiguous</a> (const DLTensor &amp;arr)</td></tr>
<tr class="memdesc:adb2ed1227b418f5846d43d3234b52391"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a DLTensor is contiguous.  <a href="#adb2ed1227b418f5846d43d3234b52391">More...</a><br /></td></tr>
<tr class="separator:adb2ed1227b418f5846d43d3234b52391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd7050eda88b079f0a962bd413a34ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#afdd7050eda88b079f0a962bd413a34ea">TVMArrayHandleToObjectHandle</a> (<a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a> handle)</td></tr>
<tr class="separator:afdd7050eda88b079f0a962bd413a34ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplParams" colspan="2">template&lt;typename RelayRefType , typename ObjectType &gt; </td></tr>
<tr class="memitem:aa4a97de4fefd23aa5942c6a545544a05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#aa4a97de4fefd23aa5942c6a545544a05">GetRef</a> (const ObjectType *ptr)</td></tr>
<tr class="memdesc:aa4a97de4fefd23aa5942c6a545544a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference type from a raw object ptr type.  <a href="#aa4a97de4fefd23aa5942c6a545544a05">More...</a><br /></td></tr>
<tr class="separator:aa4a97de4fefd23aa5942c6a545544a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplParams" colspan="2">template&lt;typename SubRef , typename BaseRef &gt; </td></tr>
<tr class="memitem:a756a222aed384e208f32d35d3412c918"><td class="memTemplItemLeft" align="right" valign="top">SubRef&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a756a222aed384e208f32d35d3412c918">Downcast</a> (BaseRef ref)</td></tr>
<tr class="memdesc:a756a222aed384e208f32d35d3412c918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast a base reference type to a more specific type.  <a href="#a756a222aed384e208f32d35d3412c918">More...</a><br /></td></tr>
<tr class="separator:a756a222aed384e208f32d35d3412c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjectType &gt; </td></tr>
<tr class="memitem:a46bcf7948293194c5b9c7db91da96381"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a46bcf7948293194c5b9c7db91da96381">GetObjectPtr</a> (ObjectType *ptr)</td></tr>
<tr class="memdesc:a46bcf7948293194c5b9c7db91da96381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object ptr type from a raw object ptr.  <a href="#a46bcf7948293194c5b9c7db91da96381">More...</a><br /></td></tr>
<tr class="separator:a46bcf7948293194c5b9c7db91da96381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c790ddcf38a1ef9800466cd0c1a0a2"><td class="memTemplParams" colspan="2">template&lt;typename RelayRefType , typename ObjType &gt; </td></tr>
<tr class="memitem:ad4c790ddcf38a1ef9800466cd0c1a0a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ad4c790ddcf38a1ef9800466cd0c1a0a2">GetRef</a> (const ObjType *ptr)</td></tr>
<tr class="separator:ad4c790ddcf38a1ef9800466cd0c1a0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplParams" colspan="2">template&lt;typename BaseType , typename ObjType &gt; </td></tr>
<tr class="memitem:ac2d903012aff56c2bd54ff66f48450c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; BaseType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac2d903012aff56c2bd54ff66f48450c3">GetObjectPtr</a> (ObjType *ptr)</td></tr>
<tr class="separator:ac2d903012aff56c2bd54ff66f48450c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a49d761ea6373557c24c01eaceb07d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a06a49d761ea6373557c24c01eaceb07d">GetCustomTypeName</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a06a49d761ea6373557c24c01eaceb07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for getting custom type name from code.  <a href="#a06a49d761ea6373557c24c01eaceb07d">More...</a><br /></td></tr>
<tr class="separator:a06a49d761ea6373557c24c01eaceb07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a1b8eedadc5a269b2f9614ce69a9932e7">GetCustomTypeRegistered</a> (uint8_t type_code)</td></tr>
<tr class="memdesc:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for checking whether custom type is registered.  <a href="#a1b8eedadc5a269b2f9614ce69a9932e7">More...</a><br /></td></tr>
<tr class="separator:a1b8eedadc5a269b2f9614ce69a9932e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d167947285dff3c780bd5d01ace9b9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac6d167947285dff3c780bd5d01ace9b9">ParseCustomDatatype</a> (const std::string &amp;s, const char **scan)</td></tr>
<tr class="memdesc:ac6d167947285dff3c780bd5d01ace9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime utility for parsing string of the form "custom[&lt;typename&gt;]".  <a href="#ac6d167947285dff3c780bd5d01ace9b9">More...</a><br /></td></tr>
<tr class="separator:ac6d167947285dff3c780bd5d01ace9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504dc7b1fd693412576703f44bcc3cfb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a504dc7b1fd693412576703f44bcc3cfb">TypeCode2Str</a> (int type_code)</td></tr>
<tr class="memdesc:a504dc7b1fd693412576703f44bcc3cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert type code to its name.  <a href="#a504dc7b1fd693412576703f44bcc3cfb">More...</a><br /></td></tr>
<tr class="separator:a504dc7b1fd693412576703f44bcc3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277f104e659f71cd8885744700016341"><td class="memItemLeft" align="right" valign="top">DLDataType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a277f104e659f71cd8885744700016341">String2DLDataType</a> (std::string s)</td></tr>
<tr class="memdesc:a277f104e659f71cd8885744700016341"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a string to TVM type.  <a href="#a277f104e659f71cd8885744700016341">More...</a><br /></td></tr>
<tr class="separator:a277f104e659f71cd8885744700016341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac360f2d9815036ab1b4d84d9cfb46b4f">DLDataType2String</a> (DLDataType t)</td></tr>
<tr class="memdesc:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a TVM type to string.  <a href="#ac360f2d9815036ab1b4d84d9cfb46b4f">More...</a><br /></td></tr>
<tr class="separator:ac360f2d9815036ab1b4d84d9cfb46b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ed99740d7bb838d96617de83ff2363"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a11ed99740d7bb838d96617de83ff2363">operator&lt;&lt;</a> (std::ostream &amp;os, DLDataType t)</td></tr>
<tr class="separator:a11ed99740d7bb838d96617de83ff2363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d447b7bdac52d26bca3422fe098f6f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a59d447b7bdac52d26bca3422fe098f6f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;dtype)</td></tr>
<tr class="separator:a59d447b7bdac52d26bca3422fe098f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac8a77303649fb143634796b3dc50a286"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#ac8a77303649fb143634796b3dc50a286">kAllocAlignment</a> = 64</td></tr>
<tr class="memdesc:ac8a77303649fb143634796b3dc50a286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to.  <a href="#ac8a77303649fb143634796b3dc50a286">More...</a><br /></td></tr>
<tr class="separator:ac8a77303649fb143634796b3dc50a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a8f5819cabea098a1818cf7cda40fdb1f">kTempAllocaAlignment</a> = 64</td></tr>
<tr class="memdesc:a8f5819cabea098a1818cf7cda40fdb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes each allocation must align to in temporary allocation.  <a href="#a8f5819cabea098a1818cf7cda40fdb1f">More...</a><br /></td></tr>
<tr class="separator:a8f5819cabea098a1818cf7cda40fdb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a2f6f769f6dbbbb24929b7c9f91a48c90">kMaxStackAlloca</a> = 1024</td></tr>
<tr class="memdesc:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size that can be allocated on stack.  <a href="#a2f6f769f6dbbbb24929b7c9f91a48c90">More...</a><br /></td></tr>
<tr class="separator:a2f6f769f6dbbbb24929b7c9f91a48c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#a48cbe06e6c95ca6fabc20dd1cbacc2c9">kRPCSessMask</a> = 128</td></tr>
<tr class="memdesc:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type bigger than this is RPC device.  <a href="#a48cbe06e6c95ca6fabc20dd1cbacc2c9">More...</a><br /></td></tr>
<tr class="separator:a48cbe06e6c95ca6fabc20dd1cbacc2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memItemLeft" align="right" valign="top">constexpr uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1runtime.html#acf4599f17bfe79ae1fe8afc1af053b43">kTVMNDArrayMagic</a> = 0xDD5E40F096B4A13F</td></tr>
<tr class="memdesc:acf4599f17bfe79ae1fe8afc1af053b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a> file.  <a href="#acf4599f17bfe79ae1fe8afc1af053b43">More...</a><br /></td></tr>
<tr class="separator:acf4599f17bfe79ae1fe8afc1af053b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a46fef1ca0ccc05473e9bb0a8c6b66619">tvm::runtime::DeviceAttrKind</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the query type into GetAttr </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb"></a>kExist&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4"></a>kMaxThreadsPerBlock&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da"></a>kWarpSize&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264"></a>kMaxSharedMemoryPerBlock&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b"></a>kComputeVersion&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca"></a>kDeviceName&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630"></a>kMaxClockRate&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd"></a>kMultiProcessorCount&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991"></a>kMaxThreadDimensions&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201"></a>kGcnArch&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1runtime.html#a7d395cd724f727e86358b73b5cdeb4e4">tvm::runtime::TypeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>list of the type index. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4a1b73281b45b997205b5082ba53300d6a"></a>kRoot&#160;</td><td class="fielddoc">
<p>Root object type. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4a626309e16a9075cc8009c93adf3fbc9f"></a>kClosure&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4a86d9bc218c0f54443cbbe3fcc5c8382e"></a>kVMADT&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4af5474ebdbaaa19e977334eefa4bbd611"></a>kRuntimeModule&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4a548302094bc9afb6bb14dc2a283c1014"></a>kStaticIndexEnd&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a7d395cd724f727e86358b73b5cdeb4e4a633f5947b3a79c577b538cec7528f5aa"></a>kDynamic&#160;</td><td class="fielddoc">
<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> index is allocated during runtime. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9109e4efe269213052ed6a94853c0c00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::runtime::DeviceName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of Device API factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the device name. </dd></dl>

</div>
</div>
<a class="anchor" id="ac360f2d9815036ab1b4d84d9cfb46b4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::DLDataType2String </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a TVM type to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type in string. </dd></dl>

</div>
</div>
<a class="anchor" id="a756a222aed384e208f32d35d3412c918"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubRef , typename BaseRef &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SubRef tvm::runtime::Downcast </td>
          <td>(</td>
          <td class="paramtype">BaseRef&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast a base reference type to a more specific type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>The inptut reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding SubRef. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SubRef</td><td>The target specific reference type. </td></tr>
    <tr><td class="paramname">BaseRef</td><td>the current reference type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06a49d761ea6373557c24c01eaceb07d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tvm::runtime::GetCustomTypeName </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for getting custom type name from code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Custom type name </dd></dl>

</div>
</div>
<a class="anchor" id="a1b8eedadc5a269b2f9614ce69a9932e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::GetCustomTypeRegistered </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for checking whether custom type is registered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>Custom type code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bool representing whether type is registered </dd></dl>

</div>
</div>
<a class="anchor" id="a59940b6d63dd4c5175c0fe875047c1cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t tvm::runtime::GetDataSize </td>
          <td>(</td>
          <td class="paramtype">const DLTensor &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the size of data the DLTensor hold, in term of number of bytes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>the input DLTensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes of data in the DLTensor. </dd></dl>

</div>
</div>
<a class="anchor" id="a46bcf7948293194c5b9c7db91da96381"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object ptr type from a raw object ptr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BaseType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a class="anchor" id="ac2d903012aff56c2bd54ff66f48450c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;BaseType&gt; tvm::runtime::GetObjectPtr </td>
          <td>(</td>
          <td class="paramtype">ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4a97de4fefd23aa5942c6a545544a05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RelayRefType , typename ObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a> tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjectType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference type from a raw object ptr type. </p>
<p>It is always important to get a reference type if we want to return a value as reference or keep the object alive beyond the scope of the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The object pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RefType</td><td>The reference type </td></tr>
    <tr><td class="paramname">ObjectType</td><td>The object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding RefType </dd></dl>

</div>
</div>
<a class="anchor" id="ad4c790ddcf38a1ef9800466cd0c1a0a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RelayRefType , typename ObjType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1RelayRefType.html">RelayRefType</a> tvm::runtime::GetRef </td>
          <td>(</td>
          <td class="paramtype">const ObjType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad01a53416152b68029d67190c3709d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::runtime::GetVectorBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes needed in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes needed. </dd></dl>

</div>
</div>
<a class="anchor" id="adb2ed1227b418f5846d43d3234b52391"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::IsContiguous </td>
          <td>(</td>
          <td class="paramtype">const DLTensor &amp;&#160;</td>
          <td class="paramname"><em>arr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a DLTensor is contiguous. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>The input DLTensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The check result. </dd></dl>

</div>
</div>
<a class="anchor" id="a144496aaff68cd251b6bc0a7b24ca041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType , typename ElemType , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt;ArrayType&gt; tvm::runtime::make_inplace_array_object </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a93466f4543eedc3925c66ed0e7ef2671"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html">ObjectPtr</a>&lt; T &gt; tvm::runtime::make_object </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate an object using default allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the node type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1runtime_1_1ObjectPtr.html" title="A custom smart pointer for Object. ">ObjectPtr</a> to the allocated object. </dd></dl>

</div>
</div>
<a class="anchor" id="af22b89284299c81d0c1802199af446d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1ObjectRef.html">ObjectRef</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ce391c2492dfc73b5c6c6459693c6a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLContext&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a11ed99740d7bb838d96617de83ff2363"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59d447b7bdac52d26bca3422fe098f6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::runtime::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1DataType.html">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6d167947285dff3c780bd5d01ace9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t tvm::runtime::ParseCustomDatatype </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>scan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runtime utility for parsing string of the form "custom[&lt;typename&gt;]". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td><a class="el" href="classtvm_1_1runtime_1_1String.html" title="Reference to string objects. ">String</a> to parse </td></tr>
    <tr><td class="paramname">scan</td><td>pointer to parsing pointer, which is scanning across s </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type code of custom type parsed </dd></dl>

</div>
</div>
<a class="anchor" id="abbea0c23882ae01431ac7fe6506b32a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::RuntimeEnabled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if runtime module is enabled for target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target module name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether runtime is enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a8fb37910dcd9bb6899e6a3a47f006514"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::SaveDLTensor </td>
          <td>(</td>
          <td class="paramtype">dmlc::Stream *&#160;</td>
          <td class="paramname"><em>strm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DLTensor *&#160;</td>
          <td class="paramname"><em>tensor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Save a DLTensor to stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strm</td><td>The output stream </td></tr>
    <tr><td class="paramname">tensor</td><td>The tensor to be saved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a277f104e659f71cd8885744700016341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DLDataType tvm::runtime::String2DLDataType </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a string to TVM type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The string to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding tvm type. </dd></dl>

</div>
</div>
<a class="anchor" id="afdd7050eda88b079f0a962bd413a34ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1Object.html">Object</a>* tvm::runtime::TVMArrayHandleToObjectHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="c__runtime__api_8h.html#a73ca58cb32f4a4adf71d274dc1e27be4">TVMArrayHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a504dc7b1fd693412576703f44bcc3cfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * tvm::runtime::TypeCode2Str </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert type code to its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_code</td><td>The type code . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of type code. </dd></dl>

</div>
</div>
<a class="anchor" id="aee574cee6755b0c2f1aa664c6967686f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeEqual </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether two types are equal . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbabb7cfb79bfb6d802f65a9803e4eb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::runtime::TypeMatch </td>
          <td>(</td>
          <td class="paramtype">DLDataType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether type matches the given spec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type </td></tr>
    <tr><td class="paramname">code</td><td>The type code. </td></tr>
    <tr><td class="paramname">bits</td><td>The number of bits to be matched. </td></tr>
    <tr><td class="paramname">lanes</td><td>The number of lanes in the type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac8a77303649fb143634796b3dc50a286"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kAllocAlignment = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to. </p>

</div>
</div>
<a class="anchor" id="a2f6f769f6dbbbb24929b7c9f91a48c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kMaxStackAlloca = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size that can be allocated on stack. </p>

</div>
</div>
<a class="anchor" id="a48cbe06e6c95ca6fabc20dd1cbacc2c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kRPCSessMask = 128</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The device type bigger than this is RPC device. </p>

</div>
</div>
<a class="anchor" id="a8f5819cabea098a1818cf7cda40fdb1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int tvm::runtime::kTempAllocaAlignment = 64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes each allocation must align to in temporary allocation. </p>

</div>
</div>
<a class="anchor" id="acf4599f17bfe79ae1fe8afc1af053b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint64_t tvm::runtime::kTVMNDArrayMagic = 0xDD5E40F096B4A13F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magic number for <a class="el" href="classtvm_1_1runtime_1_1NDArray.html" title="Managed NDArray. The array is backed by reference counted blocks. ">NDArray</a> file. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
