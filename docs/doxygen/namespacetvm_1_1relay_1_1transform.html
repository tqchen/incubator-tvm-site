<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::relay::transform Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay_1_1transform.html">transform</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay::transform Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afa666ade112e9955059095d695238a9a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> = <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td></tr>
<tr class="separator:afa666ade112e9955059095d695238a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">PassNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td></tr>
<tr class="separator:aa695a8dfc3d5b087018ddd4ef1eb2487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">PassInfo</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td></tr>
<tr class="separator:aa405b5f11938fb8c4fa2ca21926edc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">PassInfoNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td></tr>
<tr class="separator:aae88cd0ad69cf64c7e9caf0a0c8ebb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744a05f8bba3c2ac238ba4569d926184"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a> = <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td></tr>
<tr class="separator:a744a05f8bba3c2ac238ba4569d926184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72900733e0d3510ae61a1c287c2ec125"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">PassContextNode</a> = <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td></tr>
<tr class="separator:a72900733e0d3510ae61a1c287c2ec125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae923037d22b4640b450c06e6c1e33e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">Sequential</a> = <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td></tr>
<tr class="separator:a3ae923037d22b4640b450c06e6c1e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aba687537c5fd54db0012c745bba74a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aba687537c5fd54db0012c745bba74a85">CreateFunctionPass</a> (const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;pass_func, int opt_level, const std::string &amp;name, const <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a> &gt; &amp;required)</td></tr>
<tr class="separator:aba687537c5fd54db0012c745bba74a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa08e0ced82fc7efe515d610104b070c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aaa08e0ced82fc7efe515d610104b070c">DeadCodeElimination</a> (bool inline_once=false)</td></tr>
<tr class="memdesc:aaa08e0ced82fc7efe515d610104b070c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove expressions which does not effect the program result.  <a href="#aaa08e0ced82fc7efe515d610104b070c">More...</a><br /></td></tr>
<tr class="separator:aaa08e0ced82fc7efe515d610104b070c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e60251741cca1e811564b2f03a4a5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ab6e60251741cca1e811564b2f03a4a5d">LazyGradientInit</a> ()</td></tr>
<tr class="memdesc:ab6e60251741cca1e811564b2f03a4a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly.  <a href="#ab6e60251741cca1e811564b2f03a4a5d">More...</a><br /></td></tr>
<tr class="separator:ab6e60251741cca1e811564b2f03a4a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41656c71a440f1f9c9eae0aa409d2b22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a41656c71a440f1f9c9eae0aa409d2b22">FoldConstant</a> ()</td></tr>
<tr class="memdesc:a41656c71a440f1f9c9eae0aa409d2b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold constant expressions.  <a href="#a41656c71a440f1f9c9eae0aa409d2b22">More...</a><br /></td></tr>
<tr class="separator:a41656c71a440f1f9c9eae0aa409d2b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6be6024a96a84f7230faa2519f1a97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2a6be6024a96a84f7230faa2519f1a97">FuseOps</a> (int fuse_opt_level=-1)</td></tr>
<tr class="memdesc:a2a6be6024a96a84f7230faa2519f1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse operations into expr into seperate functions.  <a href="#a2a6be6024a96a84f7230faa2519f1a97">More...</a><br /></td></tr>
<tr class="separator:a2a6be6024a96a84f7230faa2519f1a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a03b053f3d99d5c420ddc8492e6b987bf">RewriteAnnotatedOps</a> (int fallback_device)</td></tr>
<tr class="memdesc:a03b053f3d99d5c420ddc8492e6b987bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a03b053f3d99d5c420ddc8492e6b987bf">More...</a><br /></td></tr>
<tr class="separator:a03b053f3d99d5c420ddc8492e6b987bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a8cb03cf00b2ddf25f183ab837cde713c">ToANormalForm</a> ()</td></tr>
<tr class="memdesc:a8cb03cf00b2ddf25f183ab837cde713c"><td class="mdescLeft">&#160;</td><td class="mdescRight">turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF).  <a href="#a8cb03cf00b2ddf25f183ab837cde713c">More...</a><br /></td></tr>
<tr class="separator:a8cb03cf00b2ddf25f183ab837cde713c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90e4d6ac08b62ef553755e759d398fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ad90e4d6ac08b62ef553755e759d398fa">ToCPS</a> ()</td></tr>
<tr class="memdesc:ad90e4d6ac08b62ef553755e759d398fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression into continuation passing style(CPS).  <a href="#ad90e4d6ac08b62ef553755e759d398fa">More...</a><br /></td></tr>
<tr class="separator:ad90e4d6ac08b62ef553755e759d398fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a2cfef0e02cca22f3e0e85e0a10a82f5b">ToGraphNormalForm</a> ()</td></tr>
<tr class="memdesc:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove let binding and directly share via pointer instead.  <a href="#a2cfef0e02cca22f3e0e85e0a10a82f5b">More...</a><br /></td></tr>
<tr class="separator:a2cfef0e02cca22f3e0e85e0a10a82f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa270d98da5518969e005c7e30d6eb6fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa270d98da5518969e005c7e30d6eb6fe">PartialEval</a> ()</td></tr>
<tr class="memdesc:aa270d98da5518969e005c7e30d6eb6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggressive constant propagation/constant folding/inlining.  <a href="#aa270d98da5518969e005c7e30d6eb6fe">More...</a><br /></td></tr>
<tr class="separator:aa270d98da5518969e005c7e30d6eb6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add13a2ad7b216ad4683141bbbb4f6943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#add13a2ad7b216ad4683141bbbb4f6943">SimplifyInference</a> ()</td></tr>
<tr class="memdesc:add13a2ad7b216ad4683141bbbb4f6943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify certain operators during inference. For example, batch norm will be unpacked into a number of simplified operators.  <a href="#add13a2ad7b216ad4683141bbbb4f6943">More...</a><br /></td></tr>
<tr class="separator:add13a2ad7b216ad4683141bbbb4f6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a22870dd16693b2e3edb5fba7cb5dc3e8">FastMath</a> ()</td></tr>
<tr class="memdesc:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces non linear activation functions with their fast but approximate counterparts.  <a href="#a22870dd16693b2e3edb5fba7cb5dc3e8">More...</a><br /></td></tr>
<tr class="separator:a22870dd16693b2e3edb5fba7cb5dc3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a1a4fe2161bf32a60bc2e57debab083ee">InferType</a> ()</td></tr>
<tr class="memdesc:a1a4fe2161bf32a60bc2e57debab083ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of an expression.  <a href="#a1a4fe2161bf32a60bc2e57debab083ee">More...</a><br /></td></tr>
<tr class="separator:a1a4fe2161bf32a60bc2e57debab083ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21ade01969835b155241d277a94d1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adf21ade01969835b155241d277a94d1c">EliminateCommonSubexpr</a> (<a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> fskip=nullptr)</td></tr>
<tr class="memdesc:adf21ade01969835b155241d277a94d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable.  <a href="#adf21ade01969835b155241d277a94d1c">More...</a><br /></td></tr>
<tr class="separator:adf21ade01969835b155241d277a94d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3b8f4cbf0bd699d2ca0ab92c534c867d">CombineParallelConv2D</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>.  <a href="#a3b8f4cbf0bd699d2ca0ab92c534c867d">More...</a><br /></td></tr>
<tr class="separator:a3b8f4cbf0bd699d2ca0ab92c534c867d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186d1029887d7b33d002798d414f4d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a186d1029887d7b33d002798d414f4d31">CombineParallelDense</a> (uint64_t min_num_branches=3)</td></tr>
<tr class="memdesc:a186d1029887d7b33d002798d414f4d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>.  <a href="#a186d1029887d7b33d002798d414f4d31">More...</a><br /></td></tr>
<tr class="separator:a186d1029887d7b33d002798d414f4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3bde64d7774dcda7735f73a4e2ebecf7">BackwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backward fold axis scaling into weights of conv/dense operators.  <a href="#a3bde64d7774dcda7735f73a4e2ebecf7">More...</a><br /></td></tr>
<tr class="separator:a3bde64d7774dcda7735f73a4e2ebecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7f62610e05ed0211f17d452ee37f5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aab7f62610e05ed0211f17d452ee37f5f">ForwardFoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:aab7f62610e05ed0211f17d452ee37f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward fold axis scaling into weights of conv/dense operators.  <a href="#aab7f62610e05ed0211f17d452ee37f5f">More...</a><br /></td></tr>
<tr class="separator:aab7f62610e05ed0211f17d452ee37f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73946a29efe8cf6f186a681296c8e943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a73946a29efe8cf6f186a681296c8e943">FoldScaleAxis</a> ()</td></tr>
<tr class="memdesc:a73946a29efe8cf6f186a681296c8e943"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes.  <a href="#a73946a29efe8cf6f186a681296c8e943">More...</a><br /></td></tr>
<tr class="separator:a73946a29efe8cf6f186a681296c8e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcddf150ca7da40e20408928421b0086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#adcddf150ca7da40e20408928421b0086">CanonicalizeOps</a> ()</td></tr>
<tr class="memdesc:adcddf150ca7da40e20408928421b0086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add.  <a href="#adcddf150ca7da40e20408928421b0086">More...</a><br /></td></tr>
<tr class="separator:adcddf150ca7da40e20408928421b0086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e0426cfa5887f11769a057c09ce8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a64e0426cfa5887f11769a057c09ce8ba">AlterOpLayout</a> ()</td></tr>
<tr class="memdesc:a64e0426cfa5887f11769a057c09ce8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layouts of operators or replace primitive operators with other expressions.  <a href="#a64e0426cfa5887f11769a057c09ce8ba">More...</a><br /></td></tr>
<tr class="separator:a64e0426cfa5887f11769a057c09ce8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12225e2ad26ae24fca669e180026689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#ad12225e2ad26ae24fca669e180026689">ConvertLayout</a> (const std::string &amp;desired_layout)</td></tr>
<tr class="memdesc:ad12225e2ad26ae24fca669e180026689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end.  <a href="#ad12225e2ad26ae24fca669e180026689">More...</a><br /></td></tr>
<tr class="separator:ad12225e2ad26ae24fca669e180026689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459fec81f00a7a17c5cf7dabe5e4e363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a459fec81f00a7a17c5cf7dabe5e4e363">Legalize</a> (const std::string &amp;legalize_map_attr_name=&quot;FTVMLegalize&quot;)</td></tr>
<tr class="memdesc:a459fec81f00a7a17c5cf7dabe5e4e363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalizes an expr with another expression.  <a href="#a459fec81f00a7a17c5cf7dabe5e4e363">More...</a><br /></td></tr>
<tr class="separator:a459fec81f00a7a17c5cf7dabe5e4e363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a93bbf7ab3f612d4f38a6832d6b53b4fd">CanonicalizeCast</a> ()</td></tr>
<tr class="memdesc:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalize cast expressions to make operator fusion more efficient.  <a href="#a93bbf7ab3f612d4f38a6832d6b53b4fd">More...</a><br /></td></tr>
<tr class="separator:a93bbf7ab3f612d4f38a6832d6b53b4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e515696ecc9ff4222af99fef361de4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a6e515696ecc9ff4222af99fef361de4e">EtaExpand</a> (bool expand_constructor, bool expand_global_var)</td></tr>
<tr class="memdesc:a6e515696ecc9ff4222af99fef361de4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add abstraction over a constructor or global variable bound to a function.  <a href="#a6e515696ecc9ff4222af99fef361de4e">More...</a><br /></td></tr>
<tr class="separator:a6e515696ecc9ff4222af99fef361de4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065b5d8be6fd8dbfcef44dfa48adeb29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#a065b5d8be6fd8dbfcef44dfa48adeb29">PrintIR</a> (bool show_meta_data=true)</td></tr>
<tr class="memdesc:a065b5d8be6fd8dbfcef44dfa48adeb29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the IR for a module to help debugging.  <a href="#a065b5d8be6fd8dbfcef44dfa48adeb29">More...</a><br /></td></tr>
<tr class="separator:a065b5d8be6fd8dbfcef44dfa48adeb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0bfdaf6d09b360602243c81abe05a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aac0bfdaf6d09b360602243c81abe05a1">PartitionGraph</a> ()</td></tr>
<tr class="memdesc:aac0bfdaf6d09b360602243c81abe05a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition a Relay program into regions that can be executed on different backends.  <a href="#aac0bfdaf6d09b360602243c81abe05a1">More...</a><br /></td></tr>
<tr class="separator:aac0bfdaf6d09b360602243c81abe05a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5e588279a3b19a119c9aa28c364bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#aba5e588279a3b19a119c9aa28c364bbe">Inline</a> ()</td></tr>
<tr class="memdesc:aba5e588279a3b19a119c9aa28c364bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#aba5e588279a3b19a119c9aa28c364bbe">More...</a><br /></td></tr>
<tr class="separator:aba5e588279a3b19a119c9aa28c364bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdccee126a74a602e3669bdfaf0f259c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#abdccee126a74a602e3669bdfaf0f259c">RemoveUnusedFunctions</a> (<a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a> &gt; entry_functions)</td></tr>
<tr class="memdesc:abdccee126a74a602e3669bdfaf0f259c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>.  <a href="#abdccee126a74a602e3669bdfaf0f259c">More...</a><br /></td></tr>
<tr class="separator:abdccee126a74a602e3669bdfaf0f259c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="afa666ade112e9955059095d695238a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">tvm::relay::transform::Pass</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Pass.html">tvm::transform::Pass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a744a05f8bba3c2ac238ba4569d926184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">tvm::relay::transform::PassContext</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContext.html">tvm::transform::PassContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a72900733e0d3510ae61a1c287c2ec125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a72900733e0d3510ae61a1c287c2ec125">tvm::relay::transform::PassContextNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassContextNode.html">tvm::transform::PassContextNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa405b5f11938fb8c4fa2ca21926edc9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa405b5f11938fb8c4fa2ca21926edc9d">tvm::relay::transform::PassInfo</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfo.html">tvm::transform::PassInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae88cd0ad69cf64c7e9caf0a0c8ebb45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aae88cd0ad69cf64c7e9caf0a0c8ebb45">tvm::relay::transform::PassInfoNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassInfoNode.html">tvm::transform::PassInfoNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa695a8dfc3d5b087018ddd4ef1eb2487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#aa695a8dfc3d5b087018ddd4ef1eb2487">tvm::relay::transform::PassNode</a> = typedef <a class="el" href="classtvm_1_1transform_1_1PassNode.html">tvm::transform::PassNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3ae923037d22b4640b450c06e6c1e33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a3ae923037d22b4640b450c06e6c1e33e">tvm::relay::transform::Sequential</a> = typedef <a class="el" href="classtvm_1_1transform_1_1Sequential.html">tvm::transform::Sequential</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a64e0426cfa5887f11769a057c09ce8ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::AlterOpLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layouts of operators or replace primitive operators with other expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bde64d7774dcda7735f73a4e2ebecf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::BackwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a93bbf7ab3f612d4f38a6832d6b53b4fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeCast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize cast expressions to make operator fusion more efficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="adcddf150ca7da40e20408928421b0086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CanonicalizeOps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalize some operators to the simplified operators. For example, bias_add can be canonicalized to expand_dims and broadcast_add. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b8f4cbf0bd699d2ca0ab92c534c867d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelConv2D </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a186d1029887d7b33d002798d414f4d31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CombineParallelDense </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_num_branches</em> = <code>3</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine parallel dense ops into a single batch_matmul if the number of branches of this dense operator is not less than <code>min_num_branch</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_num_branches</td><td>The minimun number of branches.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ad12225e2ad26ae24fca669e180026689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ConvertLayout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>desired_layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end. </p>
<p>This pass is not a part of relay.build and is expected to be called between framework-relay parser and relay.build call. This is very helpful for hardware backends that support/prefer only type of data layout.</p>
<p>RFC - <a href="https://discuss.tvm.ai/t/layout-conversion-pass/4009">https://discuss.tvm.ai/t/layout-conversion-pass/4009</a></p>
<p>This pass uses most of the AlterOpLayout and InferCorrectLayout infrastructure. We can define new layouts for conv2d ops for now. Most of the other operators try to adapt to their input layout using the InferCorrectLayout infrastructure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_layout</td><td>The desired layout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="aba687537c5fd54db0012c745bba74a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::CreateFunctionPass </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>(<a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>, <a class="el" href="classtvm_1_1IRModule.html">IRModule</a>, <a class="el" href="namespacetvm_1_1relay_1_1transform.html#a744a05f8bba3c2ac238ba4569d926184">PassContext</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>pass_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opt_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa08e0ced82fc7efe515d610104b070c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::DeadCodeElimination </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inline_once</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove expressions which does not effect the program result. </p>
<p>It will remove let bindings which are not referenced, and inline let bindings that are only used once.</p>
<p>For example, this pass should turn <code>let a = 1 in 2</code> into <code>2</code>, as the value of the expression does not depend on a.</p>
<p>As another example, <code>let a = 1 in a</code> will be optimized into 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inline_once</td><td>whether or not to inline binding used one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="adf21ade01969835b155241d277a94d1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EliminateCommonSubexpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a>&#160;</td>
          <td class="paramname"><em>fskip</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fskip</td><td>The callback argument that allows to skip certain expressions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e515696ecc9ff4222af99fef361de4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::EtaExpand </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_constructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_global_var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add abstraction over a constructor or global variable bound to a function. </p>
<p>For example: <code>square</code> is transformed to <code>fn (x: int32) -&gt; int32 { square(x) }</code>.</p>
<p>See <a href="https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion">https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expand_constructor</td><td>Whether to expand constructors. </td></tr>
    <tr><td class="paramname">expand_global_var</td><td>Whether to expand global variables.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a22870dd16693b2e3edb5fba7cb5dc3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FastMath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces non linear activation functions with their fast but approximate counterparts. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a41656c71a440f1f9c9eae0aa409d2b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldConstant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold constant expressions. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a73946a29efe8cf6f186a681296c8e943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A sequential pass that executes ForwardFoldScaleAxis and BackwardFoldScaleAxis passes. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="aab7f62610e05ed0211f17d452ee37f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ForwardFoldScaleAxis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward fold axis scaling into weights of conv/dense operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a6be6024a96a84f7230faa2519f1a97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::FuseOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fuse_opt_level</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuse operations into expr into seperate functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fuse_opt_level</td><td>Optimization level. <a class="el" href="classtvm_1_1relay_1_1If.html">If</a> it is -1 it will be inferred from pass context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a4fe2161bf32a60bc2e57debab083ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::InferType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of an expression. </p>
<p>The result of type checking is a new expression with unambigous type information filled in, as well as it's checked type field populated with the result type.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="aba5e588279a3b19a119c9aa28c364bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Inline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inline the global functions marked as <code>inline</code> in a given Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e60251741cca1e811564b2f03a4a5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::LazyGradientInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert all expressions of <a class="el" href="classtvm_1_1TensorType.html" title="Managed reference to TensorTypeNode. ">TensorType</a> into GradCell, an algebraic data type defined in gradient.rly. </p>
<p>This will delay or decrease memory usage. All calls to ones, ones_like, zeros, zeros_like will not immediately instantiate a tensor in memory, rather only instantiate if needed. It also defines + and * operation between GradCell types which can increase performance when using zero-filled or one-filled tensors, which is the case in reverse mode ad.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass </dd></dl>

</div>
</div>
<a class="anchor" id="a459fec81f00a7a17c5cf7dabe5e4e363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::Legalize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>legalize_map_attr_name</em> = <code>&quot;FTVMLegalize&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalizes an expr with another expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">legalize_map_attr_name</td><td>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>'s attr name which corresponds to the legalize rule function. One can collect and isolate similar type of legalize transformations using this param. For example, transformations that only apply to Dialects can be isolated into a FTVMDialectLegalize string. This pass calls only those transformations that have been registered using the supplied legalize_map_attr_name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="aa270d98da5518969e005c7e30d6eb6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartialEval </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggressive constant propagation/constant folding/inlining. </p>
<p>It will do as much computation in compile time as possible. It has two benefit: remove runtime overhead, and allow more optimization (typically fusion). As a side effect, code size will explode.</p>
<dl class="section return"><dt>Returns</dt><dd>the optimized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aac0bfdaf6d09b360602243c81abe05a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PartitionGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition a Relay program into regions that can be executed on different backends. </p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a065b5d8be6fd8dbfcef44dfa48adeb29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::PrintIR </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_meta_data</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the IR for a module to help debugging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">show_meta_data</td><td>The flag to control if meta data needs to be printed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="abdccee126a74a602e3669bdfaf0f259c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RemoveUnusedFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>entry_functions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the unused functions in the Relay <a class="el" href="classtvm_1_1IRModule.html" title="Managed reference class to IRModuleNode. ">IRModule</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_functions</td><td>The entry functions used to search the functions that are being used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a03b053f3d99d5c420ddc8492e6b987bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="add13a2ad7b216ad4683141bbbb4f6943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::SimplifyInference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify certain operators during inference. For example, batch norm will be unpacked into a number of simplified operators. </p>
<dl class="section return"><dt>Returns</dt><dd>The Pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cb03cf00b2ddf25f183ab837cde713c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToANormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>turn a dataflow graph into Administrative Normal Form, or A-Normal Form (ANF). </p>
<p>It will turn an expression that is in a graph form (with sharing implicit), to an expression with explicit sharing (A-Normal Form).</p>
<p>The scope of the root expression is the global scope.</p>
<p>The scope of any non root expression is the least common ancestor of all it's scope.</p>
<p>Values are ordered by post-DFS order in each scope.</p>
<dl class="section return"><dt>Returns</dt><dd>The pass. </dd></dl>

</div>
</div>
<a class="anchor" id="ad90e4d6ac08b62ef553755e759d398fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToCPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression into continuation passing style(CPS). </p>
<p>CPS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.</p>
<p>Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).</p>
<p>Similarly, all other compute will be wrapped and call the continuation as well.</p>
<dl class="section return"><dt>Returns</dt><dd>the pass. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cfef0e02cca22f3e0e85e0a10a82f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay_1_1transform.html#afa666ade112e9955059095d695238a9a">Pass</a> tvm::relay::transform::ToGraphNormalForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove let binding and directly share via pointer instead. </p>
<p>It will remove all let binding, and turn all of the variable bound by let into direct pointer reference.</p>
<dl class="section return"><dt>Returns</dt><dd>the expression in graph normal form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
