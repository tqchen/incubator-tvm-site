<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: topi::nn Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetopi.html">topi</a></li><li class="navelem"><a class="el" href="namespacetopi_1_1nn.html">nn</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">topi::nn Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> : int { <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95babbfb6c4315c8b57e558600af1515d3d8">kAvgPool</a>, 
<a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95ba3a406a1361a3c7ca311d3c514842c2f4">kMaxPool</a>
 }<tr class="memdesc:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pooling type.  <a href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac531cfce9c3a031fa25cfb6ed1f9b95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a607b758a01a9350507e44670cecfbbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a607b758a01a9350507e44670cecfbbb1">batch_matmul</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;y)</td></tr>
<tr class="memdesc:a607b758a01a9350507e44670cecfbbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation that calculates matrix multiplication in batch.  <a href="#a607b758a01a9350507e44670cecfbbb1">More...</a><br /></td></tr>
<tr class="separator:a607b758a01a9350507e44670cecfbbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff898fc8b6170d953782a01f6fc0e63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#aff898fc8b6170d953782a01f6fc0e63f">bias_add</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;data, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;bias, int axis)</td></tr>
<tr class="memdesc:aff898fc8b6170d953782a01f6fc0e63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation that calculates data + bias.  <a href="#aff898fc8b6170d953782a01f6fc0e63f">More...</a><br /></td></tr>
<tr class="separator:aff898fc8b6170d953782a01f6fc0e63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01028bdee00ceef9f58fd29e4fceeaad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a01028bdee00ceef9f58fd29e4fceeaad">binarize_pack</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;data, int axis, std::string name=&quot;PackedInput&quot;, std::string tag=&quot;binarize_pack&quot;)</td></tr>
<tr class="memdesc:a01028bdee00ceef9f58fd29e4fceeaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binarization and bit-packing along a certain axis.  <a href="#a01028bdee00ceef9f58fd29e4fceeaad">More...</a><br /></td></tr>
<tr class="separator:a01028bdee00ceef9f58fd29e4fceeaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedfa473f37183df3c8188b667bb7594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#acedfa473f37183df3c8188b667bb7594">binary_dense</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;data, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;weight)</td></tr>
<tr class="memdesc:acedfa473f37183df3c8188b667bb7594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary matrix multiplication using xor and bit-count.  <a href="#acedfa473f37183df3c8188b667bb7594">More...</a><br /></td></tr>
<tr class="separator:acedfa473f37183df3c8188b667bb7594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe55c065905a614f105da095a7f036ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#abe55c065905a614f105da095a7f036ea">dense</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;data, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;weight, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;bias, const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;out_dtype)</td></tr>
<tr class="memdesc:abe55c065905a614f105da095a7f036ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operation that calculates data * weight^T + bias.  <a href="#abe55c065905a614f105da095a7f036ea">More...</a><br /></td></tr>
<tr class="separator:abe55c065905a614f105da095a7f036ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ccdad6f841aaafa2f64062f249a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ad57ccdad6f841aaafa2f64062f249a47">all</a> (<a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; args)</td></tr>
<tr class="memdesc:ad57ccdad6f841aaafa2f64062f249a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new expression of the logical and of all conditions in the arguments.  <a href="#ad57ccdad6f841aaafa2f64062f249a47">More...</a><br /></td></tr>
<tr class="separator:ad57ccdad6f841aaafa2f64062f249a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac795264be73287d92fcd7be8943ddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a6ac795264be73287d92fcd7be8943ddc">dilate</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; strides, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a>)</td></tr>
<tr class="memdesc:a6ac795264be73287d92fcd7be8943ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dilate data with zeros.  <a href="#a6ac795264be73287d92fcd7be8943ddc">More...</a><br /></td></tr>
<tr class="separator:a6ac795264be73287d92fcd7be8943ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84054f5c8010db45e80365c3c2c6e1d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a84054f5c8010db45e80365c3c2c6e1d4">flatten</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a>)</td></tr>
<tr class="memdesc:a84054f5c8010db45e80365c3c2c6e1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the input tensor into a 2-D tensor by collapsing higher dimensions. This requires the input tensor to have constant sized dimensions.  <a href="#a84054f5c8010db45e80365c3c2c6e1d4">More...</a><br /></td></tr>
<tr class="separator:a84054f5c8010db45e80365c3c2c6e1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ded232c2572637db6adc7cf5f0b35b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a0ded232c2572637db6adc7cf5f0b35b2">lrn</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;data, int size, int axis=1, float alpha=0.0001, float beta=0.75, float bias=2, std::string name=&quot;tensor&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:a0ded232c2572637db6adc7cf5f0b35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local response normalization inference operator.  <a href="#a0ded232c2572637db6adc7cf5f0b35b2">More...</a><br /></td></tr>
<tr class="separator:a0ded232c2572637db6adc7cf5f0b35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9516b844130a2189ad2989b646ec2b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ae9516b844130a2189ad2989b646ec2b1">scale_shift_nchw</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;scale, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:ae9516b844130a2189ad2989b646ec2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and shift with NCHW order.  <a href="#ae9516b844130a2189ad2989b646ec2b1">More...</a><br /></td></tr>
<tr class="separator:ae9516b844130a2189ad2989b646ec2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ab19179f1b4a73a42b17ddf2f5fea46fc">scale_shift_nhwc</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;scale, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;shift, std::string name=&quot;ScaleShift&quot;, std::string tag=<a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a>)</td></tr>
<tr class="memdesc:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale and shift with NHWC order.  <a href="#ab19179f1b4a73a42b17ddf2f5fea46fc">More...</a><br /></td></tr>
<tr class="separator:ab19179f1b4a73a42b17ddf2f5fea46fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51533b09956d7bc8de2537adf3b6b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ad51533b09956d7bc8de2537adf3b6b77">pool_impl</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const size_t height_axis, const size_t width_axis, bool count_include_pad)</td></tr>
<tr class="memdesc:ad51533b09956d7bc8de2537adf3b6b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on height and width dimension of data.  <a href="#ad51533b09956d7bc8de2537adf3b6b77">More...</a><br /></td></tr>
<tr class="separator:ad51533b09956d7bc8de2537adf3b6b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c25e8b3ab3cac1c2896cb750838337"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#af2c25e8b3ab3cac1c2896cb750838337">pool_grad_impl</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;out_grad, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const size_t height_axis, const size_t width_axis, bool count_include_pad)</td></tr>
<tr class="separator:af2c25e8b3ab3cac1c2896cb750838337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e81a7938a1e3f273e184e2373d9138d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a2e81a7938a1e3f273e184e2373d9138d">find_depth_height_width</a> (const std::string &amp;layout, int *depth_axis, int *height_axis, int *width_axis)</td></tr>
<tr class="separator:a2e81a7938a1e3f273e184e2373d9138d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428e0ba6800ef89b8c1f97f0245e244d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a428e0ba6800ef89b8c1f97f0245e244d">find_height_width</a> (const std::string &amp;layout, int *height_axis, int *width_axis)</td></tr>
<tr class="separator:a428e0ba6800ef89b8c1f97f0245e244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f1f9f86723b30bb8997615e1d63ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ab1f1f9f86723b30bb8997615e1d63ca8">find_width</a> (const std::string &amp;layout, int *width_axis)</td></tr>
<tr class="separator:ab1f1f9f86723b30bb8997615e1d63ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1708b3aa1a677f56a4063a568945d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac1708b3aa1a677f56a4063a568945d98">pool</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCHW&quot;, bool count_include_pad=true)</td></tr>
<tr class="memdesc:ac1708b3aa1a677f56a4063a568945d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#ac1708b3aa1a677f56a4063a568945d98">More...</a><br /></td></tr>
<tr class="separator:ac1708b3aa1a677f56a4063a568945d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f915567f195ade4a17743a5e7654e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a4f915567f195ade4a17743a5e7654e88">pool_grad</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;out_grad, const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCHW&quot;, bool count_include_pad=true)</td></tr>
<tr class="memdesc:a4f915567f195ade4a17743a5e7654e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate gradient of pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#a4f915567f195ade4a17743a5e7654e88">More...</a><br /></td></tr>
<tr class="separator:a4f915567f195ade4a17743a5e7654e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b52c68356d23123474ebf10f9b0140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a91b52c68356d23123474ebf10f9b0140">start_index</a> (const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;out_index, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;odim, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;idim)</td></tr>
<tr class="separator:a91b52c68356d23123474ebf10f9b0140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbaaec56f0b485262bf5199bbe3dcb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#aadbaaec56f0b485262bf5199bbe3dcb3">end_index</a> (const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;out_index, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;odim, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;idim)</td></tr>
<tr class="separator:aadbaaec56f0b485262bf5199bbe3dcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f34df5cfa8dc75843116bc39f06066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ad4f34df5cfa8dc75843116bc39f06066">adaptive_pool_impl</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;output_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, const std::vector&lt; int &gt; &amp;axes)</td></tr>
<tr class="memdesc:ad4f34df5cfa8dc75843116bc39f06066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform adaptive pooling on N dimensional data.  <a href="#ad4f34df5cfa8dc75843116bc39f06066">More...</a><br /></td></tr>
<tr class="separator:ad4f34df5cfa8dc75843116bc39f06066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af721a019c13f1f99dc43d5d49cc71388"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#af721a019c13f1f99dc43d5d49cc71388">adaptive_pool</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;output_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, const std::string &amp;layout=&quot;NCHW&quot;)</td></tr>
<tr class="memdesc:af721a019c13f1f99dc43d5d49cc71388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptively perform pooling on height and width dimension of data. The pooling kernel and stride sizes are automatically chosen for desired output sizes. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#af721a019c13f1f99dc43d5d49cc71388">More...</a><br /></td></tr>
<tr class="separator:af721a019c13f1f99dc43d5d49cc71388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48c57c26ce6bb02576555a4cb11bcd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ad48c57c26ce6bb02576555a4cb11bcd3">adaptive_pool3d</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;output_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, const std::string &amp;layout=&quot;NCDHW&quot;)</td></tr>
<tr class="memdesc:ad48c57c26ce6bb02576555a4cb11bcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptively perform pooling on three dimensional data. See the two dimensional version above for details.  <a href="#ad48c57c26ce6bb02576555a4cb11bcd3">More...</a><br /></td></tr>
<tr class="separator:ad48c57c26ce6bb02576555a4cb11bcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#ac5fe64687aa8bffee420bf282f2b8f8c">global_pool</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, const std::string &amp;layout=&quot;NCHW&quot;)</td></tr>
<tr class="memdesc:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform global pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, ... are valid for global_pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#ac5fe64687aa8bffee420bf282f2b8f8c">More...</a><br /></td></tr>
<tr class="separator:ac5fe64687aa8bffee420bf282f2b8f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2681e29b1f733835ffe2e6b3b69c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a0b2681e29b1f733835ffe2e6b3b69c13">pool_impl_nd</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::vector&lt; int &gt; &amp;axis, bool count_include_pad)</td></tr>
<tr class="memdesc:a0b2681e29b1f733835ffe2e6b3b69c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on N-dimension of data.  <a href="#a0b2681e29b1f733835ffe2e6b3b69c13">More...</a><br /></td></tr>
<tr class="separator:a0b2681e29b1f733835ffe2e6b3b69c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379dfcc1d33774fb4ce998550dda187c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a379dfcc1d33774fb4ce998550dda187c">pool1d</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCW&quot;, bool count_include_pad=true)</td></tr>
<tr class="memdesc:a379dfcc1d33774fb4ce998550dda187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on the width dimension of data. Width axis is determined by the layout string in which 'W' means width. Width dimension cannot be split. For example, NCW, NCW16c, etc. are valid for pool, while NCW16w is not. See <em>layout</em> for more information of the layout string convention.  <a href="#a379dfcc1d33774fb4ce998550dda187c">More...</a><br /></td></tr>
<tr class="separator:a379dfcc1d33774fb4ce998550dda187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84c2ac0c1fd4ec7db5c9bc661bd5aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#af84c2ac0c1fd4ec7db5c9bc661bd5aab">pool3d</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;kernel_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;stride_size, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;padding_size, <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a> pool_type, bool ceil_mode, const std::string &amp;layout=&quot;NCDHW&quot;, bool count_include_pad=true)</td></tr>
<tr class="memdesc:af84c2ac0c1fd4ec7db5c9bc661bd5aab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform pooling on depth, height and width dimension of data. It decides the depth, height and width dimension according to the layout string, in which 'D', 'W' and 'H' means depth, width and height respectively. Depth, Width and height dimension cannot be split. For example, NCDHW, NCDHW16c, etc. are valid for pool, while NCDHW16d, NCDHW16w or NCDHW16h are not. See <em>layout</em> for more information of the layout string convention.  <a href="#af84c2ac0c1fd4ec7db5c9bc661bd5aab">More...</a><br /></td></tr>
<tr class="separator:af84c2ac0c1fd4ec7db5c9bc661bd5aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c845f2e02a677c556929d41a399e729"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a1c845f2e02a677c556929d41a399e729">softmax</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, int axis=-1, std::string name=&quot;tensor&quot;, std::string tag=&quot;softmax_output&quot;)</td></tr>
<tr class="memdesc:a1c845f2e02a677c556929d41a399e729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Softmax activation.  <a href="#a1c845f2e02a677c556929d41a399e729">More...</a><br /></td></tr>
<tr class="separator:a1c845f2e02a677c556929d41a399e729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetopi_1_1nn.html#a667b9b98da3fd9a918a603d1b8aad5d7">log_softmax</a> (const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;x, std::string name=&quot;tensor&quot;, std::string tag=&quot;log_softmax_output&quot;)</td></tr>
<tr class="memdesc:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log softmax activation.  <a href="#a667b9b98da3fd9a918a603d1b8aad5d7">More...</a><br /></td></tr>
<tr class="separator:a667b9b98da3fd9a918a603d1b8aad5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">topi::nn::PoolType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pooling type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95babbfb6c4315c8b57e558600af1515d3d8"></a>kAvgPool&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac531cfce9c3a031fa25cfb6ed1f9b95ba3a406a1361a3c7ca311d3c514842c2f4"></a>kMaxPool&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af721a019c13f1f99dc43d5d49cc71388"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::adaptive_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adaptively perform pooling on height and width dimension of data. The pooling kernel and stride sizes are automatically chosen for desired output sizes. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">output_size</td><td>Vector of two ints: {output_height, output_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout order </dd></dl>

</div>
</div>
<a class="anchor" id="ad48c57c26ce6bb02576555a4cb11bcd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::adaptive_pool3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCDHW&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adaptively perform pooling on three dimensional data. See the two dimensional version above for details. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">output_size</td><td>Vector of three ints: {output_depth, output_height, output_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. The default is "NCDHW". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4f34df5cfa8dc75843116bc39f06066"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::adaptive_pool_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform adaptive pooling on N dimensional data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">output_size</td><td>int vector of size in each dimension </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">axes</td><td>indices of each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout order </dd></dl>

</div>
</div>
<a class="anchor" id="ad57ccdad6f841aaafa2f64062f249a47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> topi::nn::all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new expression of the logical and of all conditions in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to find the logical conjunction of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The logical conjunction expression </dd></dl>

</div>
</div>
<a class="anchor" id="a607b758a01a9350507e44670cecfbbb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> topi::nn::batch_matmul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operation that calculates matrix multiplication in batch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Tensor with shape [batch, M, K] </td></tr>
    <tr><td class="paramname">y</td><td>Tensor with shape [batch, N, K]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, M, N] </dd></dl>

</div>
</div>
<a class="anchor" id="aff898fc8b6170d953782a01f6fc0e63f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> topi::nn::bias_add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operation that calculates data + bias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Tensor with shape [batch, in_dim] </td></tr>
    <tr><td class="paramname">bias</td><td>Tensor with shape [batch]. </td></tr>
    <tr><td class="paramname">axis</td><td>The axis to add the bias to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, in_dim] </dd></dl>

</div>
</div>
<a class="anchor" id="a01028bdee00ceef9f58fd29e4fceeaad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> topi::nn::binarize_pack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;PackedInput&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;binarize_pack&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binarization and bit-packing along a certain axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>N-D tensor, can be any layout </td></tr>
    <tr><td class="paramname">axis</td><td>The axis along which to do binarization and bit-packing. This axis must have a size equal to an integer multiple of 32. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output tensor with dtype uint32 </dd></dl>

</div>
</div>
<a class="anchor" id="acedfa473f37183df3c8188b667bb7594"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> topi::nn::binary_dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary matrix multiplication using xor and bit-count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Tensor with shape [batch, in_dim], dtype is uint32 </td></tr>
    <tr><td class="paramname">weight</td><td>Tensor with shape [out_dim, in_dim], dtype is uint32</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, out_dim], dtype is float32 </dd></dl>

</div>
</div>
<a class="anchor" id="abe55c065905a614f105da095a7f036ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> topi::nn::dense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">tvm::te::Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> &amp;&#160;</td>
          <td class="paramname"><em>out_dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an operation that calculates data * weight^T + bias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Tensor with shape [batch, in_dim] </td></tr>
    <tr><td class="paramname">weight</td><td>Tensor with shape [out_dim, in_dim] </td></tr>
    <tr><td class="paramname">bias</td><td>Tensor with shape [out_dim]. Optional; to omit bias, pass Tensor() </td></tr>
    <tr><td class="paramname">out_dtype</td><td>Output data type. Used for mixed precision.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Tensor with shape [batch, out_dim] </dd></dl>

</div>
</div>
<a class="anchor" id="a6ac795264be73287d92fcd7be8943ddc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::dilate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dilate data with zeros. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor, this can have any number of dimensions and any layout. </td></tr>
    <tr><td class="paramname">strides</td><td>Dilation stride for each dimension. Stride 1 means no dilation. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="aadbaaec56f0b485262bf5199bbe3dcb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> topi::nn::end_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>out_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>odim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>idim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e81a7938a1e3f273e184e2373d9138d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool topi::nn::find_depth_height_width </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>depth_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a428e0ba6800ef89b8c1f97f0245e244d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool topi::nn::find_height_width </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1f1f9f86723b30bb8997615e1d63ca8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool topi::nn::find_width </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84054f5c8010db45e80365c3c2c6e1d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::flatten </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a60f05ec416e4618d25ad00dd9f536934">kInjective</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flattens the input tensor into a 2-D tensor by collapsing higher dimensions. This requires the input tensor to have constant sized dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2-D tensor. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5fe64687aa8bffee420bf282f2b8f8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::global_pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform global pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, ... are valid for global_pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor represent as layout </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. global-pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the sub-dimension. For example, <code>NCHW16c</code> can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout with height and width dimension size of 1. e.g., for NCHW, the output shape will be [batch, channel, 1, 1] </dd></dl>

</div>
</div>
<a class="anchor" id="a667b9b98da3fd9a918a603d1b8aad5d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::log_softmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;log_softmax_output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log softmax activation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. 2-D where log softmax is performed along the second dimension </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the log softmax operation </dd></dl>

</div>
</div>
<a class="anchor" id="a0ded232c2572637db6adc7cf5f0b35b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::lrn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.0001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bias</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Local response normalization inference operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input tensor. 4-D shape NCHW or NHWC </td></tr>
    <tr><td class="paramname">size</td><td>Integer to define normalisation window size </td></tr>
    <tr><td class="paramname">axis</td><td>Input data layout channel axis </td></tr>
    <tr><td class="paramname">alpha</td><td>Float scaling factor </td></tr>
    <tr><td class="paramname">beta</td><td>Exponent value </td></tr>
    <tr><td class="paramname">bias</td><td>Offset to avoid dividing by zero </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the Local response normalization operation </dd></dl>

</div>
</div>
<a class="anchor" id="ac1708b3aa1a677f56a4063a568945d98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of two ints: {kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of two ints: {stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of two ints: {padding_height, padding_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well. </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation when pool_type is 'avg'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in the same layout </dd></dl>

</div>
</div>
<a class="anchor" id="a379dfcc1d33774fb4ce998550dda187c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool1d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on the width dimension of data. Width axis is determined by the layout string in which 'W' means width. Width dimension cannot be split. For example, NCW, NCW16c, etc. are valid for pool, while NCW16w is not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of three ints: {kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of three ints: {stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of six ints: {head_pad_width, tail_pad_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'W' appears. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCW16c can describe a 4-D tensor of [batch_size, channel, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>W</code>, one can pass <code>NCWc</code> as well. </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation when pool_type is 'avg'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in the same layout </dd></dl>

</div>
</div>
<a class="anchor" id="af84c2ac0c1fd4ec7db5c9bc661bd5aab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCDHW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on depth, height and width dimension of data. It decides the depth, height and width dimension according to the layout string, in which 'D', 'W' and 'H' means depth, width and height respectively. Depth, Width and height dimension cannot be split. For example, NCDHW, NCDHW16c, etc. are valid for pool, while NCDHW16d, NCDHW16w or NCDHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of three ints: {kernel_depth, kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of three ints: {stride_depth, stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of six ints: {head_pad_depth, head_pad_height, head_pad_width, tail_pad_depth, tail_pad_height, tail_pad_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'D', 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCDHW16c can describe a 6-D tensor of [batch_size, channel, depth, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>D</code>, <code>H</code> and <code>W</code>, one can pass <code>NCDHWc</code> as well. </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation when pool_type is 'avg'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in the same layout </dd></dl>

</div>
</div>
<a class="anchor" id="a4f915567f195ade4a17743a5e7654e88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool_grad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>out_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>layout</em> = <code>&quot;NCHW&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate gradient of pooling on height and width dimension of data. It decides the height and width dimension according to the layout string, in which 'W' and 'H' means width and height respectively. Width and height dimension cannot be split. For example, NCHW, NCHW16c, etc. are valid for pool, while NCHW16w, NCHW16h are not. See <em>layout</em> for more information of the layout string convention. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_grad</td><td>The output gradient tensor. </td></tr>
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of two ints: {kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of two ints: {stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of two ints: {padding_height, padding_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">layout</td><td>The input layout. Pooling supports any layout as long as 'H' and 'W' appear. The layout is supposed to be composed of upper cases, lower cases and (optional) numbers, where upper case indicates a dimension and the corresponding lower case (with factor size) indicates the split dimension. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. (in which factor size <code>16</code> will not be used in pooling but for other operators, it can be used to decide the output shape). Since pooling does not care about the factor size of dimensions other than <code>H</code> and <code>W</code>, one can pass <code>NCHWc</code> as well. </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation when pool_type is 'avg'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in the same layout </dd></dl>

</div>
</div>
<a class="anchor" id="af2c25e8b3ab3cac1c2896cb750838337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool_grad_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>out_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad51533b09956d7bc8de2537adf3b6b77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>height_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>width_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on height and width dimension of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of two ints: {kernel_height, kernel_width} </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of two ints: {stride_height, stride_width} </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of two ints: {padding_height, padding_width} </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">height_axis</td><td>index of the height dimension </td></tr>
    <tr><td class="paramname">width_axis</td><td>index of the width dimension </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout order </dd></dl>

</div>
</div>
<a class="anchor" id="a0b2681e29b1f733835ffe2e6b3b69c13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::pool_impl_nd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>stride_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>padding_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetopi_1_1nn.html#ac531cfce9c3a031fa25cfb6ed1f9b95b">PoolType</a>&#160;</td>
          <td class="paramname"><em>pool_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ceil_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_include_pad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform pooling on N-dimension of data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor </td></tr>
    <tr><td class="paramname">kernel_size</td><td>Vector of N ints </td></tr>
    <tr><td class="paramname">stride_size</td><td>Vector of N ints </td></tr>
    <tr><td class="paramname">padding_size</td><td>Vector of N*2 ints [head_pad_d1, head_pad_d2, ..., head_pad_dN, tail_pad_d1, tail_pad_d2, ..., tail_pad_dN] </td></tr>
    <tr><td class="paramname">pool_type</td><td>The type of pooling operator </td></tr>
    <tr><td class="paramname">ceil_mode</td><td>Whether to use ceil when calculating the output size </td></tr>
    <tr><td class="paramname">axis</td><td>Vector of indices for the N dimensions </td></tr>
    <tr><td class="paramname">count_include_pad</td><td>Whether include padding in the calculation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output tensor in same layout order </dd></dl>

</div>
</div>
<a class="anchor" id="ae9516b844130a2189ad2989b646ec2b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::scale_shift_nchw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ScaleShift&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and shift with NCHW order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">shift</td><td>Shift tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the scale shift operation </dd></dl>

</div>
</div>
<a class="anchor" id="ab19179f1b4a73a42b17ddf2f5fea46fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::scale_shift_nhwc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;ScaleShift&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code><a class="el" href="namespacetopi.html#a794b9155e9ba9d1c9c42a1cff1fb645f">kBroadcast</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scale and shift with NHWC order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. </td></tr>
    <tr><td class="paramname">scale</td><td>Scale tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">shift</td><td>Shift tensor, 1-D of size channel </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the scale shift operation </dd></dl>

</div>
</div>
<a class="anchor" id="a1c845f2e02a677c556929d41a399e729"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> topi::nn::softmax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1te_1_1Tensor.html">Tensor</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;tensor&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tag</em> = <code>&quot;softmax_output&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Softmax activation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input tensor. Can be any dimension </td></tr>
    <tr><td class="paramname">axis</td><td>The channel axis along which softmax is performed </td></tr>
    <tr><td class="paramname">name</td><td>The name of the operation </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to mark the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Tensor whose op member is the softmax operation </dd></dl>

</div>
</div>
<a class="anchor" id="a91b52c68356d23123474ebf10f9b0140"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> topi::nn::start_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>out_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>odim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>idim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
