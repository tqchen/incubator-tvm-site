<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: include/tvm/tir/stmt.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_b4c7d8e826c599ba55146c099a14beb5.html">tvm</a></li><li class="navelem"><a class="el" href="dir_72c2f11201cd7636dc7624de0754daa5.html">tir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stmt.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>TIR statements.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="tir_2expr_8h_source.html">tvm/tir/expr.h</a>&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for stmt.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="stmt_8h__incl.svg" width="3308" height="1127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="stmt_8h__dep__incl.svg" width="3910" height="842"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="stmt_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtNode.html">tvm::tir::StmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of all statements.  <a href="classtvm_1_1tir_1_1StmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">tvm::tir::Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all statements.  <a href="classtvm_1_1tir_1_1Stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html">tvm::tir::LetStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let binding, bind var to value, then run body.  <a href="classtvm_1_1tir_1_1LetStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html">tvm::tir::AttrStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body.  <a href="classtvm_1_1tir_1_1AttrStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html">tvm::tir::AssertStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert condition, if an error occurs, return the error message.  <a href="classtvm_1_1tir_1_1AssertStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerConsumerNode.html">tvm::tir::ProducerConsumerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">annotation node of producer/consumer relation.  <a href="classtvm_1_1tir_1_1ProducerConsumerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StoreNode.html">tvm::tir::StoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value to the buffer.  <a href="classtvm_1_1tir_1_1StoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProvideNode.html">tvm::tir::ProvideNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value into mult-dimensional array defined by func.  <a href="classtvm_1_1tir_1_1ProvideNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateNode.html">tvm::tir::AllocateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FreeNode.html">tvm::tir::FreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources in the buffer before the scope ends.  <a href="classtvm_1_1tir_1_1FreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RealizeNode.html">tvm::tir::RealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the bounds where func need to be written and read in body. We will need to allocate space for the corresponding regions.  <a href="classtvm_1_1tir_1_1RealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">tvm::tir::SeqStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container of seq statement. Represent a sequence of statements.  <a href="classtvm_1_1tir_1_1SeqStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt.html">tvm::tir::SeqStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence statement.  <a href="classtvm_1_1tir_1_1SeqStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt_1_1Flattener.html">tvm::tir::SeqStmt::Flattener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to flatten sequence of arguments into <a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a>.  <a href="classtvm_1_1tir_1_1SeqStmt_1_1Flattener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html">tvm::tir::IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IfThenElse statment.  <a href="classtvm_1_1tir_1_1IfThenElseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html">tvm::tir::EvaluateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression. This is mostly used for putting a Call node into <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="classtvm_1_1tir_1_1EvaluateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ForNode.html">tvm::tir::ForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop, with poissible type annotations.  <a href="classtvm_1_1tir_1_1ForNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html">tvm::tir::PrefetchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prefetch hint of func.  <a href="classtvm_1_1tir_1_1PrefetchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1TensorKey.html">tvm::tir::TensorKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data structure used in IR Pass to indicate a tensor.  <a href="structtvm_1_1tir_1_1TensorKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm.html">tvm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html">tvm::tir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">tvm::tir::attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">tvm::tir::ForType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493">tvm::tir::ForType::Serial</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131">tvm::tir::ForType::Parallel</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725">tvm::tir::ForType::Vectorized</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac">tvm::tir::ForType::Unrolled</a> = 3
 }<tr class="memdesc:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional annotation of for loop.  <a href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed067b57db2923a07913239b2165e019"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019">tvm::tir::DeviceAPI</a> : int { <a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754">tvm::tir::DeviceAPI::None</a> = 0
 }</td></tr>
<tr class="separator:aed067b57db2923a07913239b2165e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a385e883a7cecc309d063786e5fdf2c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a385e883a7cecc309d063786e5fdf2c4b">tvm::tir::attr::IsPragmaKey</a> (const std::string &amp;attr_key)</td></tr>
<tr class="memdesc:a385e883a7cecc309d063786e5fdf2c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if attr_key is a pragma key extension.  <a href="namespacetvm_1_1tir_1_1attr.html#a385e883a7cecc309d063786e5fdf2c4b">More...</a><br /></td></tr>
<tr class="separator:a385e883a7cecc309d063786e5fdf2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1743e78389c4beaf0b788c631d424e"><td class="memItemLeft" align="right" valign="top">PrimExpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afb1743e78389c4beaf0b788c631d424e">tvm::tir::TypeAnnotation</a> (DataType dtype)</td></tr>
<tr class="memdesc:afb1743e78389c4beaf0b788c631d424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="namespacetvm_1_1tir.html#afb1743e78389c4beaf0b788c631d424e">More...</a><br /></td></tr>
<tr class="separator:afb1743e78389c4beaf0b788c631d424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a12a98cd1a8440b18d6bac0ad3eaa42ed">tvm::tir::operator&lt;&lt;</a> (std::ostream &amp;os, ForType for_type)</td></tr>
<tr class="separator:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a399eed804ecc482a607f0f65f07b78dd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a399eed804ecc482a607f0f65f07b78dd">tvm::tir::attr::thread_extent</a> = &quot;thread_extent&quot;</td></tr>
<tr class="memdesc:a399eed804ecc482a607f0f65f07b78dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching extent of thread, used by device API.  <a href="namespacetvm_1_1tir_1_1attr.html#a399eed804ecc482a607f0f65f07b78dd">More...</a><br /></td></tr>
<tr class="separator:a399eed804ecc482a607f0f65f07b78dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464533c1560ace5e0b5071ba6902482e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a464533c1560ace5e0b5071ba6902482e">tvm::tir::attr::virtual_thread</a> = &quot;virtual_thread&quot;</td></tr>
<tr class="memdesc:a464533c1560ace5e0b5071ba6902482e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark launching of a virtual thread.  <a href="namespacetvm_1_1tir_1_1attr.html#a464533c1560ace5e0b5071ba6902482e">More...</a><br /></td></tr>
<tr class="separator:a464533c1560ace5e0b5071ba6902482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a341bfebe5448f290aa54b0f84cac"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac62a341bfebe5448f290aa54b0f84cac">tvm::tir::attr::coproc_scope</a> = &quot;coproc_scope&quot;</td></tr>
<tr class="memdesc:ac62a341bfebe5448f290aa54b0f84cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is processed by a co-proccesor.  <a href="namespacetvm_1_1tir_1_1attr.html#ac62a341bfebe5448f290aa54b0f84cac">More...</a><br /></td></tr>
<tr class="separator:ac62a341bfebe5448f290aa54b0f84cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d3379e8d6486e79853e254ea9a724e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae1d3379e8d6486e79853e254ea9a724e">tvm::tir::attr::coproc_uop_scope</a> = &quot;coproc_uop_scope&quot;</td></tr>
<tr class="memdesc:ae1d3379e8d6486e79853e254ea9a724e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent.  <a href="namespacetvm_1_1tir_1_1attr.html#ae1d3379e8d6486e79853e254ea9a724e">More...</a><br /></td></tr>
<tr class="separator:ae1d3379e8d6486e79853e254ea9a724e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14c2370f3a08792a6aaf70d7a3c773e4">tvm::tir::attr::volatile_scope</a> = &quot;volatile_scope&quot;</td></tr>
<tr class="memdesc:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as volatile access for certain handle.  <a href="namespacetvm_1_1tir_1_1attr.html#a14c2370f3a08792a6aaf70d7a3c773e4">More...</a><br /></td></tr>
<tr class="separator:a14c2370f3a08792a6aaf70d7a3c773e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd38b620e1e9907216f3e583839dea3"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a4bd38b620e1e9907216f3e583839dea3">tvm::tir::attr::extern_scope</a> = &quot;extern_scope&quot;</td></tr>
<tr class="memdesc:a4bd38b620e1e9907216f3e583839dea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program.  <a href="namespacetvm_1_1tir_1_1attr.html#a4bd38b620e1e9907216f3e583839dea3">More...</a><br /></td></tr>
<tr class="separator:a4bd38b620e1e9907216f3e583839dea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a6b89838348f152d844cead81b5016"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a00a6b89838348f152d844cead81b5016">tvm::tir::attr::compute_scope</a> = &quot;compute_scope&quot;</td></tr>
<tr class="memdesc:a00a6b89838348f152d844cead81b5016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute.  <a href="namespacetvm_1_1tir_1_1attr.html#a00a6b89838348f152d844cead81b5016">More...</a><br /></td></tr>
<tr class="separator:a00a6b89838348f152d844cead81b5016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f015503117e6b781ade61e103b074a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a04f015503117e6b781ade61e103b074a">tvm::tir::attr::storage_scope</a> = &quot;storage_scope&quot;</td></tr>
<tr class="memdesc:a04f015503117e6b781ade61e103b074a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of buffers.  <a href="namespacetvm_1_1tir_1_1attr.html#a04f015503117e6b781ade61e103b074a">More...</a><br /></td></tr>
<tr class="separator:a04f015503117e6b781ade61e103b074a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27d464f2065dc5f77408df7b94d4bb6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af27d464f2065dc5f77408df7b94d4bb6">tvm::tir::attr::storage_alignment</a> = &quot;storage_alignment&quot;</td></tr>
<tr class="memdesc:af27d464f2065dc5f77408df7b94d4bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage alignement requirement of buffers.  <a href="namespacetvm_1_1tir_1_1attr.html#af27d464f2065dc5f77408df7b94d4bb6">More...</a><br /></td></tr>
<tr class="separator:af27d464f2065dc5f77408df7b94d4bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf70bbdafa7344811d336422bf95cdc5"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#acf70bbdafa7344811d336422bf95cdc5">tvm::tir::attr::realize_scope</a> = &quot;realize_scope&quot;</td></tr>
<tr class="memdesc:acf70bbdafa7344811d336422bf95cdc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark storage scope of realization.  <a href="namespacetvm_1_1tir_1_1attr.html#acf70bbdafa7344811d336422bf95cdc5">More...</a><br /></td></tr>
<tr class="separator:acf70bbdafa7344811d336422bf95cdc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3aac4e433fcd6d93f8982540960263"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a5f3aac4e433fcd6d93f8982540960263">tvm::tir::attr::device_context_id</a> = &quot;device_context_id&quot;</td></tr>
<tr class="memdesc:a5f3aac4e433fcd6d93f8982540960263"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocation context for global malloc in host.  <a href="namespacetvm_1_1tir_1_1attr.html#a5f3aac4e433fcd6d93f8982540960263">More...</a><br /></td></tr>
<tr class="separator:a5f3aac4e433fcd6d93f8982540960263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e64432b8b1b9323c5ad18957ba88b23"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9e64432b8b1b9323c5ad18957ba88b23">tvm::tir::attr::device_context_type</a> = &quot;device_context_type&quot;</td></tr>
<tr class="memdesc:a9e64432b8b1b9323c5ad18957ba88b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The device type.  <a href="namespacetvm_1_1tir_1_1attr.html#a9e64432b8b1b9323c5ad18957ba88b23">More...</a><br /></td></tr>
<tr class="separator:a9e64432b8b1b9323c5ad18957ba88b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9125ab905a93924ee79269aa808ed517"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9125ab905a93924ee79269aa808ed517">tvm::tir::attr::loop_scope</a> = &quot;loop_scope&quot;</td></tr>
<tr class="memdesc:a9125ab905a93924ee79269aa808ed517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of loop scope.  <a href="namespacetvm_1_1tir_1_1attr.html#a9125ab905a93924ee79269aa808ed517">More...</a><br /></td></tr>
<tr class="separator:a9125ab905a93924ee79269aa808ed517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a50fc9633b9cfbcefa2393dbb2ece1846">tvm::tir::attr::reduce_scope</a> = &quot;reduce_scope&quot;</td></tr>
<tr class="memdesc:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of reduce scope.  <a href="namespacetvm_1_1tir_1_1attr.html#a50fc9633b9cfbcefa2393dbb2ece1846">More...</a><br /></td></tr>
<tr class="separator:a50fc9633b9cfbcefa2393dbb2ece1846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af08d3d2b645a914f1a64d81e45f3b86a">tvm::tir::attr::pragma_scope_prefix</a> = &quot;pragma_&quot;</td></tr>
<tr class="memdesc:af08d3d2b645a914f1a64d81e45f3b86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark region is guarded by the pragma extension.  <a href="namespacetvm_1_1tir_1_1attr.html#af08d3d2b645a914f1a64d81e45f3b86a">More...</a><br /></td></tr>
<tr class="separator:af08d3d2b645a914f1a64d81e45f3b86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af00ba402645b1def7c543af3c48be80d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af00ba402645b1def7c543af3c48be80d">tvm::tir::attr::pragma_import_llvm</a> = &quot;pragma_import_llvm&quot;</td></tr>
<tr class="memdesc:af00ba402645b1def7c543af3c48be80d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import llvm source or file into the final code gen module.  <a href="namespacetvm_1_1tir_1_1attr.html#af00ba402645b1def7c543af3c48be80d">More...</a><br /></td></tr>
<tr class="separator:af00ba402645b1def7c543af3c48be80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96774004fd5b6411f6c37b8923b71834"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a96774004fd5b6411f6c37b8923b71834">tvm::tir::attr::pragma_tensor_core</a> = &quot;pragma_tensor_core&quot;</td></tr>
<tr class="memdesc:a96774004fd5b6411f6c37b8923b71834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to modify the AST to support Tensor Core.  <a href="namespacetvm_1_1tir_1_1attr.html#a96774004fd5b6411f6c37b8923b71834">More...</a><br /></td></tr>
<tr class="separator:a96774004fd5b6411f6c37b8923b71834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac95fbd1c09a60b10c7a5d07f6c4b68a6">tvm::tir::attr::prefetch_scope</a> = &quot;prefetch_scope&quot;</td></tr>
<tr class="memdesc:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope.  <a href="namespacetvm_1_1tir_1_1attr.html#ac95fbd1c09a60b10c7a5d07f6c4b68a6">More...</a><br /></td></tr>
<tr class="separator:ac95fbd1c09a60b10c7a5d07f6c4b68a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9231fc0afe37a8d46a90a1c5fdf522bb">tvm::tir::attr::double_buffer_scope</a> = &quot;double_buffer_scope&quot;</td></tr>
<tr class="memdesc:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks production of double buffer data.  <a href="namespacetvm_1_1tir_1_1attr.html#a9231fc0afe37a8d46a90a1c5fdf522bb">More...</a><br /></td></tr>
<tr class="separator:a9231fc0afe37a8d46a90a1c5fdf522bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84871a6d841168f8501f141676dfaeb"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af84871a6d841168f8501f141676dfaeb">tvm::tir::attr::double_buffer_write</a> = &quot;double_buffer_write&quot;</td></tr>
<tr class="memdesc:af84871a6d841168f8501f141676dfaeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks region used by double buffer write.  <a href="namespacetvm_1_1tir_1_1attr.html#af84871a6d841168f8501f141676dfaeb">More...</a><br /></td></tr>
<tr class="separator:af84871a6d841168f8501f141676dfaeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a84f5d42e968fd8f4cdd7a4aac7ba2137">tvm::tir::attr::scan_update_scope</a> = &quot;scan_update_scope&quot;</td></tr>
<tr class="memdesc:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan update scope.  <a href="namespacetvm_1_1tir_1_1attr.html#a84f5d42e968fd8f4cdd7a4aac7ba2137">More...</a><br /></td></tr>
<tr class="separator:a84f5d42e968fd8f4cdd7a4aac7ba2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18e3a9ba11d436e02b55e420647b22b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#af18e3a9ba11d436e02b55e420647b22b">tvm::tir::attr::scan_init_scope</a> = &quot;scan_init_scope&quot;</td></tr>
<tr class="memdesc:af18e3a9ba11d436e02b55e420647b22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark of scan init scope.  <a href="namespacetvm_1_1tir_1_1attr.html#af18e3a9ba11d436e02b55e420647b22b">More...</a><br /></td></tr>
<tr class="separator:af18e3a9ba11d436e02b55e420647b22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0ff3c4642eebe20842b1c26e98288a5d">tvm::tir::attr::buffer_dim_align</a> = &quot;buffer_dim_align&quot;</td></tr>
<tr class="memdesc:a0ff3c4642eebe20842b1c26e98288a5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark alignment of buffer dimension stmt.node is Tensor stmt.value is tvm_tuple(dim, align, offset) This gives hint to require stride of dim to be k * align + offset.  <a href="namespacetvm_1_1tir_1_1attr.html#a0ff3c4642eebe20842b1c26e98288a5d">More...</a><br /></td></tr>
<tr class="separator:a0ff3c4642eebe20842b1c26e98288a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ac76fd8d0227265617e2f2bb8402d1e19">tvm::tir::attr::buffer_bound</a> = &quot;buffer_bound&quot;</td></tr>
<tr class="memdesc:ac76fd8d0227265617e2f2bb8402d1e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark stores/loads with theirs bounds.  <a href="namespacetvm_1_1tir_1_1attr.html#ac76fd8d0227265617e2f2bb8402d1e19">More...</a><br /></td></tr>
<tr class="separator:ac76fd8d0227265617e2f2bb8402d1e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0497d7cff1d672920c2fbd4d92869e62"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a0497d7cff1d672920c2fbd4d92869e62">tvm::tir::attr::buffer_bind_scope</a> = &quot;buffer_bind_scope&quot;</td></tr>
<tr class="memdesc:a0497d7cff1d672920c2fbd4d92869e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the buffer specification to the region of the op When this scope occurs, the stmt.node is a Array&lt;NodeRef&gt; = [buffer, tensor] stmt.value is a tvm_tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase.  <a href="namespacetvm_1_1tir_1_1attr.html#a0497d7cff1d672920c2fbd4d92869e62">More...</a><br /></td></tr>
<tr class="separator:a0497d7cff1d672920c2fbd4d92869e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad39d05bd13aeed7af51e9f8e323d263b">tvm::tir::attr::channel_read_scope</a> = &quot;channel_read_scope&quot;</td></tr>
<tr class="memdesc:ad39d05bd13aeed7af51e9f8e323d263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel read scope  <a href="namespacetvm_1_1tir_1_1attr.html#ad39d05bd13aeed7af51e9f8e323d263b">More...</a><br /></td></tr>
<tr class="separator:ad39d05bd13aeed7af51e9f8e323d263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14632ed9597f1c21a0dbd23949e5916e"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a14632ed9597f1c21a0dbd23949e5916e">tvm::tir::attr::channel_read_advance</a> = &quot;channel_read_advance&quot;</td></tr>
<tr class="memdesc:a14632ed9597f1c21a0dbd23949e5916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="namespacetvm_1_1tir_1_1attr.html#a14632ed9597f1c21a0dbd23949e5916e">More...</a><br /></td></tr>
<tr class="separator:a14632ed9597f1c21a0dbd23949e5916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a52f378fc437bd4f7f6508c8e2e9b3e05">tvm::tir::attr::channel_write_scope</a> = &quot;channel_write_scope&quot;</td></tr>
<tr class="memdesc:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">channel write scope  <a href="namespacetvm_1_1tir_1_1attr.html#a52f378fc437bd4f7f6508c8e2e9b3e05">More...</a><br /></td></tr>
<tr class="separator:a52f378fc437bd4f7f6508c8e2e9b3e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ad8886f0bca07d9fa56db9edea67b1a8d">tvm::tir::attr::channel_write_advance</a> = &quot;channel_write_advance&quot;</td></tr>
<tr class="memdesc:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance step of channel after end of scope.  <a href="namespacetvm_1_1tir_1_1attr.html#ad8886f0bca07d9fa56db9edea67b1a8d">More...</a><br /></td></tr>
<tr class="separator:ad8886f0bca07d9fa56db9edea67b1a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ecbf068afc115a2282e533c0fe518d"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a19ecbf068afc115a2282e533c0fe518d">tvm::tir::attr::pipeline_stage_scope</a> = &quot;pipeline_stage_scope&quot;</td></tr>
<tr class="memdesc:a19ecbf068afc115a2282e533c0fe518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline stage scope, implies always execution  <a href="namespacetvm_1_1tir_1_1attr.html#a19ecbf068afc115a2282e533c0fe518d">More...</a><br /></td></tr>
<tr class="separator:a19ecbf068afc115a2282e533c0fe518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14d4d24b86179fd19938a02bc15512"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#aee14d4d24b86179fd19938a02bc15512">tvm::tir::attr::pipeline_exec_scope</a> = &quot;pipeline_exec_scope&quot;</td></tr>
<tr class="memdesc:aee14d4d24b86179fd19938a02bc15512"><td class="mdescLeft">&#160;</td><td class="mdescRight">pipeline execution scope, implies the scope can be pipelined.  <a href="namespacetvm_1_1tir_1_1attr.html#aee14d4d24b86179fd19938a02bc15512">More...</a><br /></td></tr>
<tr class="separator:aee14d4d24b86179fd19938a02bc15512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae486f902462321bf26244a9c5b19098c"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#ae486f902462321bf26244a9c5b19098c">tvm::tir::attr::opengl_stage_scope</a> = &quot;opengl_stage_scope&quot;</td></tr>
<tr class="memdesc:ae486f902462321bf26244a9c5b19098c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that this stage is an OpenGL shader. Since OpenGL shader only allows writing out to one element of the output texture, the Provide node gets translated to a special Call::glsl_texture_store statement instead of a Store statement.  <a href="namespacetvm_1_1tir_1_1attr.html#ae486f902462321bf26244a9c5b19098c">More...</a><br /></td></tr>
<tr class="separator:ae486f902462321bf26244a9c5b19098c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36db026f638ad3d951c302796ddcae24"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a36db026f638ad3d951c302796ddcae24">tvm::tir::attr::device_scope</a> = &quot;device_scope&quot;</td></tr>
<tr class="memdesc:a36db026f638ad3d951c302796ddcae24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that it is in the device scope.  <a href="namespacetvm_1_1tir_1_1attr.html#a36db026f638ad3d951c302796ddcae24">More...</a><br /></td></tr>
<tr class="separator:a36db026f638ad3d951c302796ddcae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d76d80fd7252d66991dc650693c0ef"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a93d76d80fd7252d66991dc650693c0ef">tvm::tir::attr::fragment_shape</a> = &quot;fragment_shape&quot;</td></tr>
<tr class="memdesc:a93d76d80fd7252d66991dc650693c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the shape of TensorCore fragment.  <a href="namespacetvm_1_1tir_1_1attr.html#a93d76d80fd7252d66991dc650693c0ef">More...</a><br /></td></tr>
<tr class="separator:a93d76d80fd7252d66991dc650693c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b33cc65f756817e691b49782ee103bd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html#a9b33cc65f756817e691b49782ee103bd">tvm::tir::attr::fragment_layout</a> = &quot;fragment_layout&quot;</td></tr>
<tr class="memdesc:a9b33cc65f756817e691b49782ee103bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark that the layout of TensorCore fragment.  <a href="namespacetvm_1_1tir_1_1attr.html#a9b33cc65f756817e691b49782ee103bd">More...</a><br /></td></tr>
<tr class="separator:a9b33cc65f756817e691b49782ee103bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TIR statements. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
