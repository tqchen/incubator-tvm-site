<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::tir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1tir.html">tir</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tvm::tir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html" title="Managed reference to PrimFuncNode. ">PrimFunc</a> specific attribute names. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1intrinsic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1intrinsic.html">intrinsic</a></td></tr>
<tr class="memdesc:namespacetvm_1_1tir_1_1intrinsic"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of TVM Intrinsic functions <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1tir_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AddNode.html">AddNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a + b  <a href="classtvm_1_1tir_1_1AddNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AllocateNode.html">AllocateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer that can be used in body.  <a href="classtvm_1_1tir_1_1AllocateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AndNode.html">AndNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &amp;&amp; b  <a href="classtvm_1_1tir_1_1AndNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AnyNode.html">AnyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Any shape.  <a href="classtvm_1_1tir_1_1AnyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AssertStmtNode.html">AssertStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert condition, if an error occurs, return the error message.  <a href="classtvm_1_1tir_1_1AssertStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1AttrStmtNode.html">AttrStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body.  <a href="classtvm_1_1tir_1_1AttrStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html">BijectiveLayout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bijective function mapping for data layout transformation. Given two <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">Layout</a>, <a class="el" href="classtvm_1_1tir_1_1BijectiveLayout.html" title="Bijective function mapping for data layout transformation. Given two Layout, BijectiveLayout build an...">BijectiveLayout</a> build and store the mapping rules, provides API to transform N-dimention tensor from the source indices (i0, i1, …, im) to the destination indices (j0, j1, … jm).  <a href="classtvm_1_1tir_1_1BijectiveLayout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BijectiveLayoutNode.html">BijectiveLayoutNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BinaryOpNode.html">BinaryOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement binary ops.  <a href="classtvm_1_1tir_1_1BinaryOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BroadcastNode.html">BroadcastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector where all the elements are value.  <a href="classtvm_1_1tir_1_1BroadcastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> is a symbolic n-darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input.  <a href="classtvm_1_1tir_1_1Buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1BufferNode.html">BufferNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node to represent a buffer.  <a href="classtvm_1_1tir_1_1BufferNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call node.  <a href="classtvm_1_1tir_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CastNode.html">CastNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast value from one data type to another.  <a href="classtvm_1_1tir_1_1CastNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CmpOpNode.html">CmpOpNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template to implement comparison ops.  <a href="classtvm_1_1tir_1_1CmpOpNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducer.html">CommReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1CommReducerNode.html">CommReducerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A commutative reducer node to represent a commutative binary operator with identity element.  <a href="classtvm_1_1tir_1_1CommReducerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1DivNode.html">DivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a / b in the C semnatics.  <a href="classtvm_1_1tir_1_1DivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EQNode.html">EQNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a == b  <a href="classtvm_1_1tir_1_1EQNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1EvaluateNode.html">EvaluateNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates an expression. This is mostly used for putting a Call node into <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="classtvm_1_1tir_1_1EvaluateNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function.  <a href="classtvm_1_1tir_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const PrimExpr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprMutator.html" title="ExprMutator that mutates expressions. ">ExprMutator</a> that mutates expressions.  <a href="classtvm_1_1tir_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1ExprVisitor.html" title="ExprVisitor. ">ExprVisitor</a>.  <a href="classtvm_1_1tir_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorDivNode.html">FloorDivNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor division, floor(a/b)  <a href="classtvm_1_1tir_1_1FloorDivNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FloorModNode.html">FloorModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the floordiv.  <a href="classtvm_1_1tir_1_1FloorModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ForNode.html">ForNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A for loop, with poissible type annotations.  <a href="classtvm_1_1tir_1_1ForNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FreeNode.html">FreeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources in the buffer before the scope ends.  <a href="classtvm_1_1tir_1_1FreeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FunctionBaseNode.html">FunctionBaseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of internal functions.  <a href="classtvm_1_1tir_1_1FunctionBaseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1FunctionRef.html">FunctionRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">reference to a function  <a href="classtvm_1_1tir_1_1FunctionRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GENode.html">GENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt;= b  <a href="classtvm_1_1tir_1_1GENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1GTNode.html">GTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &gt; b  <a href="classtvm_1_1tir_1_1GTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IfThenElseNode.html">IfThenElseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IfThenElse statment.  <a href="classtvm_1_1tir_1_1IfThenElseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration Variable, represents an iteration over an integer interval.  <a href="classtvm_1_1tir_1_1IterVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1IterVarNode.html">IterVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iteration variable representing an iteration over a one dimensional interval.  <a href="classtvm_1_1tir_1_1IterVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Layout.html">Layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">Layout</a> is to describe how data is organized within an N-dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. For example, NCHW16c can describe a 5-D tensor of [batch_size, channel, height, width, channel_block]. Here subordinate axis channel_block=16 is the factor size of the primal axis C (channel). <a class="el" href="classtvm_1_1tir_1_1Layout.html" title="Layout is to describe how data is organized within an N-dimention tensor. It is composed of upper cas...">Layout</a> for scalar is defined, while both its name and axes have size 0.  <a href="classtvm_1_1tir_1_1Layout.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutAxis.html">LayoutAxis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LayoutNode.html">LayoutNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1LENode.html">LENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt;= b  <a href="structtvm_1_1tir_1_1LENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let binding. Bind var to value then evaluate body.  <a href="classtvm_1_1tir_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LetStmtNode.html">LetStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Let binding, bind var to value, then run body.  <a href="classtvm_1_1tir_1_1LetStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoadNode.html">LoadNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the value from buffer_var.  <a href="classtvm_1_1tir_1_1LoadNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a> represents function after lowering. This is the final IR representation before codegen.  <a href="classtvm_1_1tir_1_1LoweredFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LoweredFuncNode.html">LoweredFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node container of <a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a>.  <a href="classtvm_1_1tir_1_1LoweredFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1LTNode.html">LTNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a &lt; b  <a href="classtvm_1_1tir_1_1LTNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MaxNode.html">MaxNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">max(a, b)  <a href="classtvm_1_1tir_1_1MaxNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MinNode.html">MinNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">min(a, b)  <a href="classtvm_1_1tir_1_1MinNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ModNode.html">ModNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a % b in the C semnatics.  <a href="classtvm_1_1tir_1_1ModNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1MulNode.html">MulNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a * b  <a href="classtvm_1_1tir_1_1MulNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NENode.html">NENode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a != b  <a href="classtvm_1_1tir_1_1NENode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1NotNode.html">NotNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">!a  <a href="classtvm_1_1tir_1_1NotNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1OrNode.html">OrNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a || b  <a href="classtvm_1_1tir_1_1OrNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrefetchNode.html">PrefetchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prefetch hint of func.  <a href="classtvm_1_1tir_1_1PrefetchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html" title="Primitive functions that contains TIR statements. ">PrimFuncNode</a>.  <a href="classtvm_1_1tir_1_1PrimFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1PrimFuncNode.html">PrimFuncNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primitive functions that contains TIR statements.  <a href="classtvm_1_1tir_1_1PrimFuncNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProducerConsumerNode.html">ProducerConsumerNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">annotation node of producer/consumer relation.  <a href="classtvm_1_1tir_1_1ProducerConsumerNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ProvideNode.html">ProvideNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value into mult-dimensional array defined by func.  <a href="classtvm_1_1tir_1_1ProvideNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RampNode.html">RampNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with lanes elements where its i-th element equals base + i * stride. This is useful to construct a index for a continuous vector load.  <a href="classtvm_1_1tir_1_1RampNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1RealizeNode.html">RealizeNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate the bounds where func need to be written and read in body. We will need to allocate space for the corresponding regions.  <a href="classtvm_1_1tir_1_1RealizeNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ReduceNode.html">ReduceNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduction operator operator.  <a href="classtvm_1_1tir_1_1ReduceNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SelectNode.html">SelectNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true_value if condition is true, otherwise return false_value.  <a href="classtvm_1_1tir_1_1SelectNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmt.html">SeqStmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence statement.  <a href="classtvm_1_1tir_1_1SeqStmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SeqStmtNode.html">SeqStmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container of seq statement. Represent a sequence of statements.  <a href="classtvm_1_1tir_1_1SeqStmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1ShuffleNode.html">ShuffleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffle instruction. vec = concat(vectors) result = (vec[indices[0]], vec[indices[1]] ...)  <a href="classtvm_1_1tir_1_1ShuffleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVar.html">SizeVar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable represents a tensor index size  <a href="classtvm_1_1tir_1_1SizeVar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SizeVarNode.html">SizeVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node represent a tensor index size, whose value must be non-negative.  <a href="classtvm_1_1tir_1_1SizeVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container of all statements.  <a href="classtvm_1_1tir_1_1Stmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprMutator.html">StmtExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutator that recursively mutates stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtExprVisitor.html">StmtExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor that recursively visit stmts and exprs on them.  <a href="classtvm_1_1tir_1_1StmtExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor.html">StmtFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classtvm_1_1tir_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> except it is applied on statements.  <a href="classtvm_1_1tir_1_1StmtFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4.html">StmtFunctor&lt; R(const Stmt &amp;n, Args...args)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html">StmtMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtMutator.html" title="StmtMutator that mutates the statements. ">StmtMutator</a> that mutates the statements.  <a href="classtvm_1_1tir_1_1StmtMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtNode.html">StmtNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base node of all statements.  <a href="classtvm_1_1tir_1_1StmtNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html">StmtVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1tir_1_1StmtVisitor.html" title="StmtVisitor. ">StmtVisitor</a>.  <a href="classtvm_1_1tir_1_1StmtVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StoreNode.html">StoreNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store value to the buffer.  <a href="classtvm_1_1tir_1_1StoreNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1StringImmNode.html">StringImmNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">String constants, only used in asserts.  <a href="classtvm_1_1tir_1_1StringImmNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1SubNode.html">SubNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a - b  <a href="classtvm_1_1tir_1_1SubNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1tir_1_1TensorKey.html">TensorKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary data structure used in IR Pass to indicate a tensor.  <a href="structtvm_1_1tir_1_1TensorKey.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a named variable in TVM  <a href="classtvm_1_1tir_1_1Var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable node in the IR.  <a href="classtvm_1_1tir_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8277e2a3d81a80a4776705673df51e0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">Region</a> = <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;</td></tr>
<tr class="separator:a8277e2a3d81a80a4776705673df51e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa177c432dd27540d34b22c05559324ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aa177c432dd27540d34b22c05559324ab">Domain</a> = <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;</td></tr>
<tr class="separator:aa177c432dd27540d34b22c05559324ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">IntImmNode</a> = <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td></tr>
<tr class="separator:ae8c7db788e840dc1c2ed1f365d5ea829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb123be81447d2871f4c716ce2d1dc00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">FloatImmNode</a> = <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td></tr>
<tr class="separator:adb123be81447d2871f4c716ce2d1dc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">BufferType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39">kDefault</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663">kAutoBroadcast</a> = 2
 }<tr class="memdesc:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer type  <a href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9ac05a14db42ca73da1d3945e7ce2fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422">kDataPar</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0">kThreadIndex</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4">kCommReduce</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b">kOrdered</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c">kOpaque</a> = 4, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403">kUnrolled</a> = 5, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd">kVectorized</a> = 6, 
<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652">kParallelized</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47">kTensorized</a> = 8
<br />
 }<tr class="memdesc:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of iteration variable. Each IterVar have a specific type.  <a href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:add7d0a6b1dd91f0c3c5dd2f4cf64358e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f0089a367b98e377b652186fa7dc66"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66">LoweredFuncType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9">kMixedFunc</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858">kHostFunc</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628">kDeviceFunc</a> = 2
 }<tr class="memdesc:a69f0089a367b98e377b652186fa7dc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">specific type of lowered function  <a href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a69f0089a367b98e377b652186fa7dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a> : int { <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493">ForType::Serial</a> = 0, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131">ForType::Parallel</a> = 1, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725">ForType::Vectorized</a> = 2, 
<a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac">ForType::Unrolled</a> = 3
 }<tr class="memdesc:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional annotation of for loop.  <a href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ae35cce8e3f1e8d7366dc0d9b15536736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed067b57db2923a07913239b2165e019"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019">DeviceAPI</a> : int { <a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754">DeviceAPI::None</a> = 0
 }</td></tr>
<tr class="separator:aed067b57db2923a07913239b2165e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b3692f3f081d3b5b84a24cf8082141e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9b3692f3f081d3b5b84a24cf8082141e">decl_buffer</a> (<a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; shape, <a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype=<a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32), std::string name=&quot;buffer&quot;)</td></tr>
<tr class="memdesc:a9b3692f3f081d3b5b84a24cf8082141e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new buffer given shape, and dtype.  <a href="#a9b3692f3f081d3b5b84a24cf8082141e">More...</a><br /></td></tr>
<tr class="separator:a9b3692f3f081d3b5b84a24cf8082141e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fdee9fc81462318d59dbe64c8df26"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afc0fdee9fc81462318d59dbe64c8df26">IterVarType2String</a> (<a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a> t)</td></tr>
<tr class="separator:afc0fdee9fc81462318d59dbe64c8df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:abb777c4f4d61883c0cbdf9116458b70d"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abb777c4f4d61883c0cbdf9116458b70d">as_unordered_map</a> (const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; K, V &gt; &amp;dmap)</td></tr>
<tr class="separator:abb777c4f4d61883c0cbdf9116458b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923d1bb833c984008772782e90cda37a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a923d1bb833c984008772782e90cda37a">Simplify</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=<a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a923d1bb833c984008772782e90cda37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the expression.  <a href="#a923d1bb833c984008772782e90cda37a">More...</a><br /></td></tr>
<tr class="separator:a923d1bb833c984008772782e90cda37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49287db98b766f8900dbbfcc466cb596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a49287db98b766f8900dbbfcc466cb596">Simplify</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=<a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a49287db98b766f8900dbbfcc466cb596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the statement.  <a href="#a49287db98b766f8900dbbfcc466cb596">More...</a><br /></td></tr>
<tr class="separator:a49287db98b766f8900dbbfcc466cb596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f7ea11fa82b0cb4a990f51beaa5203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae3f7ea11fa82b0cb4a990f51beaa5203">CanonicalSimplify</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=<a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:ae3f7ea11fa82b0cb4a990f51beaa5203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify by applying canonical form.  <a href="#ae3f7ea11fa82b0cb4a990f51beaa5203">More...</a><br /></td></tr>
<tr class="separator:ae3f7ea11fa82b0cb4a990f51beaa5203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a22160396635ce8b681f3aaed32df5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a6a22160396635ce8b681f3aaed32df5b">CanonicalSimplify</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt; vrange=<a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;())</td></tr>
<tr class="memdesc:a6a22160396635ce8b681f3aaed32df5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify by applying canonical form.  <a href="#a6a22160396635ce8b681f3aaed32df5b">More...</a><br /></td></tr>
<tr class="separator:a6a22160396635ce8b681f3aaed32df5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b75fe00e0f29e2cc8e2b3ffe541ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae9b75fe00e0f29e2cc8e2b3ffe541ff4">Equal</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;lhs, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:ae9b75fe00e0f29e2cc8e2b3ffe541ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#ae9b75fe00e0f29e2cc8e2b3ffe541ff4">More...</a><br /></td></tr>
<tr class="separator:ae9b75fe00e0f29e2cc8e2b3ffe541ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7135e786c567aacc96fa95bac4dae4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#af7135e786c567aacc96fa95bac4dae4b">Equal</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;lhs, const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;rhs)</td></tr>
<tr class="memdesc:af7135e786c567aacc96fa95bac4dae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#af7135e786c567aacc96fa95bac4dae4b">More...</a><br /></td></tr>
<tr class="separator:af7135e786c567aacc96fa95bac4dae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388b768f462e6699d061b5ea3ca87616"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a388b768f462e6699d061b5ea3ca87616">Compare</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;lhs, const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;rhs)</td></tr>
<tr class="memdesc:a388b768f462e6699d061b5ea3ca87616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep compare lhs and rhs.  <a href="#a388b768f462e6699d061b5ea3ca87616">More...</a><br /></td></tr>
<tr class="separator:a388b768f462e6699d061b5ea3ca87616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4506ebe76b8f44653dafdf0aef263f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae4506ebe76b8f44653dafdf0aef263f1">VerifySSA</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;ir)</td></tr>
<tr class="memdesc:ae4506ebe76b8f44653dafdf0aef263f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies whether the IR stmt or Expr is in SSA form. That is: each VarExpr is defined and assigned once(in Let/For)  <a href="#ae4506ebe76b8f44653dafdf0aef263f1">More...</a><br /></td></tr>
<tr class="separator:ae4506ebe76b8f44653dafdf0aef263f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a2b6c1ea585d4cfd12539e65f48fdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a93a2b6c1ea585d4cfd12539e65f48fdb">HasSideEffect</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e)</td></tr>
<tr class="memdesc:a93a2b6c1ea585d4cfd12539e65f48fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the expression have side effect.  <a href="#a93a2b6c1ea585d4cfd12539e65f48fdb">More...</a><br /></td></tr>
<tr class="separator:a93a2b6c1ea585d4cfd12539e65f48fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a95f59679b6acbb47ab488a1e2c6b09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2a95f59679b6acbb47ab488a1e2c6b09">ExprUseVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;v)</td></tr>
<tr class="memdesc:a2a95f59679b6acbb47ab488a1e2c6b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used var.  <a href="#a2a95f59679b6acbb47ab488a1e2c6b09">More...</a><br /></td></tr>
<tr class="separator:a2a95f59679b6acbb47ab488a1e2c6b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82ce8b3c5f0cd3a8213b90153637177"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae82ce8b3c5f0cd3a8213b90153637177">ExprUseVar</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;e, const std::unordered_set&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> * &gt; &amp;vset)</td></tr>
<tr class="memdesc:ae82ce8b3c5f0cd3a8213b90153637177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether e expression used any var in variable set..  <a href="#ae82ce8b3c5f0cd3a8213b90153637177">More...</a><br /></td></tr>
<tr class="separator:ae82ce8b3c5f0cd3a8213b90153637177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbcd71b66872684f3dc873b9380520f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afdbcd71b66872684f3dc873b9380520f">ConvertSSA</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:afdbcd71b66872684f3dc873b9380520f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a IR node to be SSA form.  <a href="#afdbcd71b66872684f3dc873b9380520f">More...</a><br /></td></tr>
<tr class="separator:afdbcd71b66872684f3dc873b9380520f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b122873fd63b721684ffb4cd9913bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4b122873fd63b721684ffb4cd9913bb4">Substitute</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a4b122873fd63b721684ffb4cd9913bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a4b122873fd63b721684ffb4cd9913bb4">More...</a><br /></td></tr>
<tr class="separator:a4b122873fd63b721684ffb4cd9913bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1753495736a7c0ab703ed01c673ec5d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1753495736a7c0ab703ed01c673ec5d0">Substitute</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a1753495736a7c0ab703ed01c673ec5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a1753495736a7c0ab703ed01c673ec5d0">More...</a><br /></td></tr>
<tr class="separator:a1753495736a7c0ab703ed01c673ec5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc79c4131e8b95c4ae4be56d4ab3c494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abc79c4131e8b95c4ae4be56d4ab3c494">Substitute</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:abc79c4131e8b95c4ae4be56d4ab3c494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#abc79c4131e8b95c4ae4be56d4ab3c494">More...</a><br /></td></tr>
<tr class="separator:abc79c4131e8b95c4ae4be56d4ab3c494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6a1e27339fcc255f664dd14e7c6cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a34e6a1e27339fcc255f664dd14e7c6cc">Substitute</a> (<a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> expr, const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;value_map)</td></tr>
<tr class="memdesc:a34e6a1e27339fcc255f664dd14e7c6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitute the var specified in key-&gt;var to be value.  <a href="#a34e6a1e27339fcc255f664dd14e7c6cc">More...</a><br /></td></tr>
<tr class="separator:a34e6a1e27339fcc255f664dd14e7c6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96379de32bcde10449bdb01b9b816e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a96379de32bcde10449bdb01b9b816e99">Inline</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1tir_1_1FunctionRef.html">FunctionRef</a> f, <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; args, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> body)</td></tr>
<tr class="memdesc:a96379de32bcde10449bdb01b9b816e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline all calls of f in stmt.  <a href="#a96379de32bcde10449bdb01b9b816e99">More...</a><br /></td></tr>
<tr class="separator:a96379de32bcde10449bdb01b9b816e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63e0decac1e98ee375d32dee15526e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2c63e0decac1e98ee375d32dee15526e">StorageFlatten</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; extern_buffer, int cache_line_size, bool create_bound_attribute=false)</td></tr>
<tr class="memdesc:a2c63e0decac1e98ee375d32dee15526e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the multi-dimensional read/write to single dimensional Load/Store.  <a href="#a2c63e0decac1e98ee375d32dee15526e">More...</a><br /></td></tr>
<tr class="separator:a2c63e0decac1e98ee375d32dee15526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e711fe4801fd2d11f85cb64bc64d56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a00e711fe4801fd2d11f85cb64bc64d56">RewriteForTensorCore</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a> schedule, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt; extern_buffer)</td></tr>
<tr class="memdesc:a00e711fe4801fd2d11f85cb64bc64d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to modify the AST to support TensorCore.  <a href="#a00e711fe4801fd2d11f85cb64bc64d56">More...</a><br /></td></tr>
<tr class="separator:a00e711fe4801fd2d11f85cb64bc64d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae892521d99d9475a59e2d01df9413b49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae892521d99d9475a59e2d01df9413b49">VerifyCompactBuffer</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:ae892521d99d9475a59e2d01df9413b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if there is any argument bound to compact buffer.  <a href="#ae892521d99d9475a59e2d01df9413b49">More...</a><br /></td></tr>
<tr class="separator:ae892521d99d9475a59e2d01df9413b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64dd52c904c2944a4771b81a2cf8f08a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a64dd52c904c2944a4771b81a2cf8f08a">RemoveNoOp</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a64dd52c904c2944a4771b81a2cf8f08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>.  <a href="#a64dd52c904c2944a4771b81a2cf8f08a">More...</a><br /></td></tr>
<tr class="separator:a64dd52c904c2944a4771b81a2cf8f08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c8f6b65c8c053c87b429d6d791343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a319c8f6b65c8c053c87b429d6d791343">UnrollLoop</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, int auto_max_step, int auto_max_depth, int auto_max_extent, bool explicit_unroll)</td></tr>
<tr class="memdesc:a319c8f6b65c8c053c87b429d6d791343"><td class="mdescLeft">&#160;</td><td class="mdescRight">unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard.  <a href="#a319c8f6b65c8c053c87b429d6d791343">More...</a><br /></td></tr>
<tr class="separator:a319c8f6b65c8c053c87b429d6d791343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd6d56877b9dd03803f433352b09060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abdd6d56877b9dd03803f433352b09060">VectorizeLoop</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:abdd6d56877b9dd03803f433352b09060"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectorize the constant loops  <a href="#abdd6d56877b9dd03803f433352b09060">More...</a><br /></td></tr>
<tr class="separator:abdd6d56877b9dd03803f433352b09060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8fc7370ebc9a6b0de19ae9e597576f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2f8fc7370ebc9a6b0de19ae9e597576f">SkipVectorize</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a2f8fc7370ebc9a6b0de19ae9e597576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert vectorized loops into serialized loops  <a href="#a2f8fc7370ebc9a6b0de19ae9e597576f">More...</a><br /></td></tr>
<tr class="separator:a2f8fc7370ebc9a6b0de19ae9e597576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604c5a3e5e7fad62a912b1d3bb41c3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a604c5a3e5e7fad62a912b1d3bb41c3fa">InstrumentBoundCheckers</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a604c5a3e5e7fad62a912b1d3bb41c3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">instruments bound checkers.  <a href="#a604c5a3e5e7fad62a912b1d3bb41c3fa">More...</a><br /></td></tr>
<tr class="separator:a604c5a3e5e7fad62a912b1d3bb41c3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9c2135e4a2a674c7ffe1f414d9b362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8c9c2135e4a2a674c7ffe1f414d9b362">InjectVirtualThread</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a8c9c2135e4a2a674c7ffe1f414d9b362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject virtual thread loops into stmt.  <a href="#a8c9c2135e4a2a674c7ffe1f414d9b362">More...</a><br /></td></tr>
<tr class="separator:a8c9c2135e4a2a674c7ffe1f414d9b362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d45de8cf5b6053ab16dde307a00238d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1d45de8cf5b6053ab16dde307a00238d">InjectPrefetch</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a1d45de8cf5b6053ab16dde307a00238d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject prefetch instructions into stmt.  <a href="#a1d45de8cf5b6053ab16dde307a00238d">More...</a><br /></td></tr>
<tr class="separator:a1d45de8cf5b6053ab16dde307a00238d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde051e07d9c7ba41d5676ce64208766"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abde051e07d9c7ba41d5676ce64208766">InjectDoubleBuffer</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, int split_loop)</td></tr>
<tr class="memdesc:abde051e07d9c7ba41d5676ce64208766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject double buffer into stmt.  <a href="#abde051e07d9c7ba41d5676ce64208766">More...</a><br /></td></tr>
<tr class="separator:abde051e07d9c7ba41d5676ce64208766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3550907081d6332c5a4b0849e1948c79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a3550907081d6332c5a4b0849e1948c79">InjectCopyIntrin</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, const std::string &amp;pragma_key, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;fintrin)</td></tr>
<tr class="memdesc:a3550907081d6332c5a4b0849e1948c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject copy intrinsics with optional pad.  <a href="#a3550907081d6332c5a4b0849e1948c79">More...</a><br /></td></tr>
<tr class="separator:a3550907081d6332c5a4b0849e1948c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b70ca88f988211332570160c82e3026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5b70ca88f988211332570160c82e3026">StorageRewrite</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a5b70ca88f988211332570160c82e3026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible.  <a href="#a5b70ca88f988211332570160c82e3026">More...</a><br /></td></tr>
<tr class="separator:a5b70ca88f988211332570160c82e3026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0606ab38faf2f31d42759f217fdec93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae0606ab38faf2f31d42759f217fdec93">LoopPartition</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, bool split_const_loop)</td></tr>
<tr class="memdesc:ae0606ab38faf2f31d42759f217fdec93"><td class="mdescLeft">&#160;</td><td class="mdescRight">partition loops in the stmt  <a href="#ae0606ab38faf2f31d42759f217fdec93">More...</a><br /></td></tr>
<tr class="separator:ae0606ab38faf2f31d42759f217fdec93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a890acc3681867fe74ad2207d17278f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9a890acc3681867fe74ad2207d17278f">CoProcSync</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a9a890acc3681867fe74ad2207d17278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and insert sync points to co-processor.  <a href="#a9a890acc3681867fe74ad2207d17278f">More...</a><br /></td></tr>
<tr class="separator:a9a890acc3681867fe74ad2207d17278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799dff4f3a280576d6838694c151e657"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a799dff4f3a280576d6838694c151e657">LiftAttrScope</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, std::string attr_key)</td></tr>
<tr class="memdesc:a799dff4f3a280576d6838694c151e657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lift common attrs with attr_key to outer scope.  <a href="#a799dff4f3a280576d6838694c151e657">More...</a><br /></td></tr>
<tr class="separator:a799dff4f3a280576d6838694c151e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3a142f48991df5a96ee1791685ca64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a2c3a142f48991df5a96ee1791685ca64">RewriteUnsafeSelect</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a2c3a142f48991df5a96ee1791685ca64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect and rewrite unsafe select that contains memory access.  <a href="#a2c3a142f48991df5a96ee1791685ca64">More...</a><br /></td></tr>
<tr class="separator:a2c3a142f48991df5a96ee1791685ca64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6c7e53cce5184e897b0bd24adb06b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a3b6c7e53cce5184e897b0bd24adb06b6">LowerStorageAccessInfo</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a3b6c7e53cce5184e897b0bd24adb06b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower attached storage access information. Do this pass after all storage access analysis finish.  <a href="#a3b6c7e53cce5184e897b0bd24adb06b6">More...</a><br /></td></tr>
<tr class="separator:a3b6c7e53cce5184e897b0bd24adb06b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89ddc934004f9e58b2e6ac3a260e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1f89ddc934004f9e58b2e6ac3a260e3d">DecorateDeviceScope</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a1f89ddc934004f9e58b2e6ac3a260e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks.  <a href="#a1f89ddc934004f9e58b2e6ac3a260e3d">More...</a><br /></td></tr>
<tr class="separator:a1f89ddc934004f9e58b2e6ac3a260e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803eaac5980c445a9ff8e38fb2c595fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a803eaac5980c445a9ff8e38fb2c595fa">HoistIfThenElse</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt)</td></tr>
<tr class="memdesc:a803eaac5980c445a9ff8e38fb2c595fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop invariant code motion which locates and hoists if statements.  <a href="#a803eaac5980c445a9ff8e38fb2c595fa">More...</a><br /></td></tr>
<tr class="separator:a803eaac5980c445a9ff8e38fb2c595fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d44994c14f11c500586a007c782c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab2d44994c14f11c500586a007c782c84">MakeAPI</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> body, std::string name, <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; ObjectRef &gt; api_args, int num_unpacked_args, bool is_restricted)</td></tr>
<tr class="memdesc:ab2d44994c14f11c500586a007c782c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an user callable API <a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a>.  <a href="#ab2d44994c14f11c500586a007c782c84">More...</a><br /></td></tr>
<tr class="separator:ab2d44994c14f11c500586a007c782c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac3af6813bf02262470992a3980a25a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1ac3af6813bf02262470992a3980a25a">BindDeviceType</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> func, int device_type)</td></tr>
<tr class="memdesc:a1ac3af6813bf02262470992a3980a25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the device type of host function to be device_type.  <a href="#a1ac3af6813bf02262470992a3980a25a">More...</a><br /></td></tr>
<tr class="separator:a1ac3af6813bf02262470992a3980a25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae110e02855d8bc12eb8b6f92ed391844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae110e02855d8bc12eb8b6f92ed391844">UndefinedVars</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;stmt, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;defs)</td></tr>
<tr class="memdesc:ae110e02855d8bc12eb8b6f92ed391844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find undefined vars in the statment.  <a href="#ae110e02855d8bc12eb8b6f92ed391844">More...</a><br /></td></tr>
<tr class="separator:ae110e02855d8bc12eb8b6f92ed391844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f5e04aea66d87ad42baf957768c451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac7f5e04aea66d87ad42baf957768c451">SplitHostDevice</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> func)</td></tr>
<tr class="memdesc:ac7f5e04aea66d87ad42baf957768c451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the function into a host function and device functions.  <a href="#ac7f5e04aea66d87ad42baf957768c451">More...</a><br /></td></tr>
<tr class="separator:ac7f5e04aea66d87ad42baf957768c451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0df6d882d69f4ec8e1b146a0d8728f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab0df6d882d69f4ec8e1b146a0d8728f9">ThreadSync</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> stmt, std::string storage_scope)</td></tr>
<tr class="memdesc:ab0df6d882d69f4ec8e1b146a0d8728f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert sync between parallel read/write of shared buffers.  <a href="#ab0df6d882d69f4ec8e1b146a0d8728f9">More...</a><br /></td></tr>
<tr class="separator:ab0df6d882d69f4ec8e1b146a0d8728f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438729b72b0e38a28289d763b48995b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a438729b72b0e38a28289d763b48995b1">LowerThreadAllreduce</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f, int warp_size)</td></tr>
<tr class="memdesc:a438729b72b0e38a28289d763b48995b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower cross thread alleduce in the stmt.  <a href="#a438729b72b0e38a28289d763b48995b1">More...</a><br /></td></tr>
<tr class="separator:a438729b72b0e38a28289d763b48995b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5111eb3e9b9d2f52998c5db4b4e3ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#af5111eb3e9b9d2f52998c5db4b4e3ae9">LowerWarpMemory</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f, int warp_size)</td></tr>
<tr class="memdesc:af5111eb3e9b9d2f52998c5db4b4e3ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower warp memory in stmt.  <a href="#af5111eb3e9b9d2f52998c5db4b4e3ae9">More...</a><br /></td></tr>
<tr class="separator:af5111eb3e9b9d2f52998c5db4b4e3ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55f17f026155f1424b3d0fdd3f86435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad55f17f026155f1424b3d0fdd3f86435">RemapThreadAxis</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt; axis_map)</td></tr>
<tr class="memdesc:ad55f17f026155f1424b3d0fdd3f86435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remap the thread axis.  <a href="#ad55f17f026155f1424b3d0fdd3f86435">More...</a><br /></td></tr>
<tr class="separator:ad55f17f026155f1424b3d0fdd3f86435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d59ba0cb48da1661593b7eeb2e96821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9d59ba0cb48da1661593b7eeb2e96821">LowerTVMBuiltin</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:a9d59ba0cb48da1661593b7eeb2e96821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower packed function call.  <a href="#a9d59ba0cb48da1661593b7eeb2e96821">More...</a><br /></td></tr>
<tr class="separator:a9d59ba0cb48da1661593b7eeb2e96821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2b224ff5bb292b1b7e677d50576b38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5c2b224ff5bb292b1b7e677d50576b38">CombineContextCall</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:a5c2b224ff5bb292b1b7e677d50576b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine context function calls.  <a href="#a5c2b224ff5bb292b1b7e677d50576b38">More...</a><br /></td></tr>
<tr class="separator:a5c2b224ff5bb292b1b7e677d50576b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2814a5568d2e1329a5c5aab2e35091e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ad2814a5568d2e1329a5c5aab2e35091e">PointerValueTypeRewrite</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:ad2814a5568d2e1329a5c5aab2e35091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible.  <a href="#ad2814a5568d2e1329a5c5aab2e35091e">More...</a><br /></td></tr>
<tr class="separator:ad2814a5568d2e1329a5c5aab2e35091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2681c6850628b3c9b213298f056b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#abbf2681c6850628b3c9b213298f056b3">PointerValueTypeRewrite</a> (<a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> f)</td></tr>
<tr class="memdesc:abbf2681c6850628b3c9b213298f056b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible.  <a href="#abbf2681c6850628b3c9b213298f056b3">More...</a><br /></td></tr>
<tr class="separator:abbf2681c6850628b3c9b213298f056b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbd367b40fe2cd31d101c88a63a0b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afcbd367b40fe2cd31d101c88a63a0b25">LowerDeviceStorageAccessInfo</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> func)</td></tr>
<tr class="memdesc:afcbd367b40fe2cd31d101c88a63a0b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower attached storage access information on device. Do this pass after all storage access analysis finish.  <a href="#afcbd367b40fe2cd31d101c88a63a0b25">More...</a><br /></td></tr>
<tr class="separator:afcbd367b40fe2cd31d101c88a63a0b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b5d13c11411299808c564adda2713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adb8b5d13c11411299808c564adda2713">LowerIntrin</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f, const std::string &amp;target)</td></tr>
<tr class="memdesc:adb8b5d13c11411299808c564adda2713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower intrinsic function calls.  <a href="#adb8b5d13c11411299808c564adda2713">More...</a><br /></td></tr>
<tr class="separator:adb8b5d13c11411299808c564adda2713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8725d2ad12962353ec11b6285cc6b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac8725d2ad12962353ec11b6285cc6b3d">LowerCustomDatatypes</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f, const std::string &amp;target)</td></tr>
<tr class="memdesc:ac8725d2ad12962353ec11b6285cc6b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lower custom datatypes.  <a href="#ac8725d2ad12962353ec11b6285cc6b3d">More...</a><br /></td></tr>
<tr class="separator:ac8725d2ad12962353ec11b6285cc6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd928ded601486ae3a3b787df3f09688"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#acd928ded601486ae3a3b787df3f09688">InferFragment</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:acd928ded601486ae3a3b787df3f09688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the TensorCore fragment infomation using tensor intrinsics.  <a href="#acd928ded601486ae3a3b787df3f09688">More...</a><br /></td></tr>
<tr class="separator:acd928ded601486ae3a3b787df3f09688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9968b6563c42117a9a1cd4576054400f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9968b6563c42117a9a1cd4576054400f">SkipAssert</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> f)</td></tr>
<tr class="memdesc:a9968b6563c42117a9a1cd4576054400f"><td class="mdescLeft">&#160;</td><td class="mdescRight">skip assert stmt generation  <a href="#a9968b6563c42117a9a1cd4576054400f">More...</a><br /></td></tr>
<tr class="separator:a9968b6563c42117a9a1cd4576054400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa649448c69d8324ba1fd7ec5e3e54731"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#aa649448c69d8324ba1fd7ec5e3e54731">VerifyMemory</a> (<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> func, int device_type)</td></tr>
<tr class="memdesc:aa649448c69d8324ba1fd7ec5e3e54731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify if memory accesses are legal for a specific target device type.  <a href="#aa649448c69d8324ba1fd7ec5e3e54731">More...</a><br /></td></tr>
<tr class="separator:aa649448c69d8324ba1fd7ec5e3e54731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705b3e58180a12eba5297cb2442fd1a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a705b3e58180a12eba5297cb2442fd1a2">VerifyGPUCode</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> stmt, <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; std::string, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; constraints)</td></tr>
<tr class="memdesc:a705b3e58180a12eba5297cb2442fd1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit.  <a href="#a705b3e58180a12eba5297cb2442fd1a2">More...</a><br /></td></tr>
<tr class="separator:a705b3e58180a12eba5297cb2442fd1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea566597880d04bd62fbec687e338b5"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4ea566597880d04bd62fbec687e338b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4ea566597880d04bd62fbec687e338b5">make_const</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value)</td></tr>
<tr class="memdesc:a4ea566597880d04bd62fbec687e338b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const value with certain data type.  <a href="#a4ea566597880d04bd62fbec687e338b5">More...</a><br /></td></tr>
<tr class="separator:a4ea566597880d04bd62fbec687e338b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4408508a413fb7f3b2567f8d847dbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#adc4408508a413fb7f3b2567f8d847dbb">make_zero</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t)</td></tr>
<tr class="memdesc:adc4408508a413fb7f3b2567f8d847dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a const zero expr.  <a href="#adc4408508a413fb7f3b2567f8d847dbb">More...</a><br /></td></tr>
<tr class="separator:adc4408508a413fb7f3b2567f8d847dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40c127b53bca09d4c39f806a98dfdf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ac40c127b53bca09d4c39f806a98dfdf8">const_true</a> (int lanes=1)</td></tr>
<tr class="memdesc:ac40c127b53bca09d4c39f806a98dfdf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant true expression.  <a href="#ac40c127b53bca09d4c39f806a98dfdf8">More...</a><br /></td></tr>
<tr class="separator:ac40c127b53bca09d4c39f806a98dfdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11cb5c6f810546e5aa4e08a0684071a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ae11cb5c6f810546e5aa4e08a0684071a">const_false</a> (int lanes=1)</td></tr>
<tr class="memdesc:ae11cb5c6f810546e5aa4e08a0684071a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant false expression.  <a href="#ae11cb5c6f810546e5aa4e08a0684071a">More...</a><br /></td></tr>
<tr class="separator:ae11cb5c6f810546e5aa4e08a0684071a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe8f225faaf34c540194921a7ee6a66"><td class="memItemLeft" align="right" valign="top">const int64_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#acbe8f225faaf34c540194921a7ee6a66">as_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:acbe8f225faaf34c540194921a7ee6a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get x as constant int expression.  <a href="#acbe8f225faaf34c540194921a7ee6a66">More...</a><br /></td></tr>
<tr class="separator:acbe8f225faaf34c540194921a7ee6a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c414d5e54c099ad7287be302aac8f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a5c414d5e54c099ad7287be302aac8f02">is_const_int</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int64_t value)</td></tr>
<tr class="memdesc:a5c414d5e54c099ad7287be302aac8f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer expression.  <a href="#a5c414d5e54c099ad7287be302aac8f02">More...</a><br /></td></tr>
<tr class="separator:a5c414d5e54c099ad7287be302aac8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a8de8f843c6eb433b6ddfbf34e24099ef">is_no_op</a> (const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;stmt)</td></tr>
<tr class="memdesc:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether stmt is nop.  <a href="#a8de8f843c6eb433b6ddfbf34e24099ef">More...</a><br /></td></tr>
<tr class="separator:a8de8f843c6eb433b6ddfbf34e24099ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5104dcf0933da31329bb0b2580a947"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a9b5104dcf0933da31329bb0b2580a947">is_one</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a9b5104dcf0933da31329bb0b2580a947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 1.  <a href="#a9b5104dcf0933da31329bb0b2580a947">More...</a><br /></td></tr>
<tr class="separator:a9b5104dcf0933da31329bb0b2580a947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bad3db162b334837716bf8e7ba9285"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a48bad3db162b334837716bf8e7ba9285">is_zero</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:a48bad3db162b334837716bf8e7ba9285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant integer 0.  <a href="#a48bad3db162b334837716bf8e7ba9285">More...</a><br /></td></tr>
<tr class="separator:a48bad3db162b334837716bf8e7ba9285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab706ef9860459b25068f3440d88a7193"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#ab706ef9860459b25068f3440d88a7193">is_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x)</td></tr>
<tr class="memdesc:ab706ef9860459b25068f3440d88a7193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant.  <a href="#ab706ef9860459b25068f3440d88a7193">More...</a><br /></td></tr>
<tr class="separator:ab706ef9860459b25068f3440d88a7193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a246623a4a0c9cd8f8a209ec952a8d1c3">is_const_power_of_two_integer</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;x, int *shift)</td></tr>
<tr class="memdesc:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether x is a constant power of two If x is power of two, write the power to the shift.  <a href="#a246623a4a0c9cd8f8a209ec952a8d1c3">More...</a><br /></td></tr>
<tr class="separator:a246623a4a0c9cd8f8a209ec952a8d1c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782dc226f8b2b537efdc56b1f76351d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a782dc226f8b2b537efdc56b1f76351d1">is_positive_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a782dc226f8b2b537efdc56b1f76351d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d552441331effb387b7c8fb241c454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a51d552441331effb387b7c8fb241c454">is_negative_const</a> (const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;a)</td></tr>
<tr class="separator:a51d552441331effb387b7c8fb241c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca71170aca9d397c2125eb4f55c197"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:af2ca71170aca9d397c2125eb4f55c197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#af2ca71170aca9d397c2125eb4f55c197">MakeConstScalar</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> t, ValueType value)</td></tr>
<tr class="separator:af2ca71170aca9d397c2125eb4f55c197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1743e78389c4beaf0b788c631d424e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#afb1743e78389c4beaf0b788c631d424e">TypeAnnotation</a> (<a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a> dtype)</td></tr>
<tr class="memdesc:afb1743e78389c4beaf0b788c631d424e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a type annotation expression.  <a href="#afb1743e78389c4beaf0b788c631d424e">More...</a><br /></td></tr>
<tr class="separator:afb1743e78389c4beaf0b788c631d424e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a12a98cd1a8440b18d6bac0ad3eaa42ed">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a> for_type)</td></tr>
<tr class="separator:a12a98cd1a8440b18d6bac0ad3eaa42ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1217dd1b57e84b5901cf755251b9e164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a1217dd1b57e84b5901cf755251b9e164">IRTransform</a> (<a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> node, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;preorder, const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;postorder, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;only_enable={})</td></tr>
<tr class="memdesc:a1217dd1b57e84b5901cf755251b9e164"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, and transform it  <a href="#a1217dd1b57e84b5901cf755251b9e164">More...</a><br /></td></tr>
<tr class="separator:a1217dd1b57e84b5901cf755251b9e164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5067fa233d111c9db9cc402ed599c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1tir.html#a4b5067fa233d111c9db9cc402ed599c3">PostOrderVisit</a> (const ObjectRef &amp;node, std::function&lt; void(const ObjectRef &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a4b5067fa233d111c9db9cc402ed599c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a4b5067fa233d111c9db9cc402ed599c3">More...</a><br /></td></tr>
<tr class="separator:a4b5067fa233d111c9db9cc402ed599c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa177c432dd27540d34b22c05559324ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#aa177c432dd27540d34b22c05559324ab">tvm::tir::Domain</a> = typedef <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adb123be81447d2871f4c716ce2d1dc00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#adb123be81447d2871f4c716ce2d1dc00">tvm::tir::FloatImmNode</a> = typedef <a class="el" href="classtvm_1_1FloatImmNode.html">tvm::FloatImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8c7db788e840dc1c2ed1f365d5ea829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#ae8c7db788e840dc1c2ed1f365d5ea829">tvm::tir::IntImmNode</a> = typedef <a class="el" href="classtvm_1_1IntImmNode.html">tvm::IntImmNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8277e2a3d81a80a4776705673df51e0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1tir.html#a8277e2a3d81a80a4776705673df51e0a">tvm::tir::Region</a> = typedef <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1Range.html">Range</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a9ac05a14db42ca73da1d3945e7ce2fd1">tvm::tir::BufferType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer type </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39"></a>kDefault&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663"></a>kAutoBroadcast&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aed067b57db2923a07913239b2165e019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#aed067b57db2923a07913239b2165e019">tvm::tir::DeviceAPI</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">tvm::tir::ForType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Additional annotation of for loop. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493"></a>Serial&#160;</td><td class="fielddoc">
<p>serial execution. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc">
<p>parallel execution on CPU. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725"></a>Vectorized&#160;</td><td class="fielddoc">
<p>Vector SIMD loop annotaion. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac"></a>Unrolled&#160;</td><td class="fielddoc">
<p>Unroll annotation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">tvm::tir::IterVarType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a> of iteration variable. Each <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> have a specific type. </p>
<p>The type of iter var can be overriden via stage.iter_var_attrs given they are compatible. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422"></a>kDataPar&#160;</td><td class="fielddoc">
<p>Data parallel iteration. This normally corresponds to axis of Tensor. Allow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations. </p>
<dl class="section note"><dt>Note</dt><dd>This does not mean the loop have to be executed in parallel fashion. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0"></a>kThreadIndex&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> itself is a thread-index of a fixed thread launching group. Note that this is already assumed to be paralellized. </p>
<p>Disallow: split/fuse/vectorize/parallel </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4"></a>kCommReduce&#160;</td><td class="fielddoc">
<p>Communicative reduction. Cannot be directly parallelized. </p>
<p>Disallow: parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b"></a>kOrdered&#160;</td><td class="fielddoc">
<p>Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-ordered. </p>
<p>Disallow: reorder/parallel/vectorize </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c"></a>kOpaque&#160;</td><td class="fielddoc">
<p><a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> is opaque,. </p>
<p>May not corresponds to any generated loop Disallow all <a class="el" href="classtvm_1_1tir_1_1IterVar.html" title="Iteration Variable, represents an iteration over an integer interval. ">IterVar</a> manipulations and compute_at</p>
<dl class="section note"><dt>Note</dt><dd>This is usually used to implement composite op or external op, where the </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403"></a>kUnrolled&#160;</td><td class="fielddoc">
<p>The execution is unrolled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd"></a>kVectorized&#160;</td><td class="fielddoc">
<p>The loop is vectorized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652"></a>kParallelized&#160;</td><td class="fielddoc">
<p>The loop is parallelized. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47"></a>kTensorized&#160;</td><td class="fielddoc">
<p>Marks boundary of tensorization intrinsic. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a69f0089a367b98e377b652186fa7dc66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1tir.html#a69f0089a367b98e377b652186fa7dc66">tvm::tir::LoweredFuncType</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specific type of lowered function </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9"></a>kMixedFunc&#160;</td><td class="fielddoc">
<p>Function that can mix device and host calls. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858"></a>kHostFunc&#160;</td><td class="fielddoc">
<p>Only contains host code. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628"></a>kDeviceFunc&#160;</td><td class="fielddoc">
<p>Only contains device code. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acbe8f225faaf34c540194921a7ee6a66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t* tvm::tir::as_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get x as constant int expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the address to the int expression, return nullptr, if x is not <a class="el" href="classtvm_1_1IntImm.html" title="Managed reference class to IntImmNode. ">IntImm</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abb777c4f4d61883c0cbdf9116458b70d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;K, V&gt; tvm::tir::as_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>dmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ac3af6813bf02262470992a3980a25a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::BindDeviceType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the device type of host function to be device_type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be binded. </td></tr>
    <tr><td class="paramname">device_type</td><td>The device type to be binded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The binded function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f7ea11fa82b0cb4a990f51beaa5203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::CanonicalSimplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;&#160;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify by applying canonical form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be canonically simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a22160396635ce8b681f3aaed32df5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::CanonicalSimplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;&#160;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify by applying canonical form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The statement to be canonically simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2b224ff5bb292b1b7e677d50576b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::CombineContextCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combine context function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The host function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a388b768f462e6699d061b5ea3ca87616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tvm::tir::Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<p>If you only want equality comparison, use Equal which will also tie definitions. The compare mode will give order of expression in total order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="ae11cb5c6f810546e5aa4e08a0684071a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_false </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant false expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ac40c127b53bca09d4c39f806a98dfdf8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::const_true </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lanes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a constant true expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lanes</td><td>The number of lanes in the bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="afdbcd71b66872684f3dc873b9380520f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::ConvertSSA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a IR node to be SSA form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a890acc3681867fe74ad2207d17278f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::CoProcSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and insert sync points to co-processor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b3692f3f081d3b5b84a24cf8082141e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> tvm::tir::decl_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em> = <code><a class="el" href="classtvm_1_1runtime_1_1DataType.html#a237a714a6a16e14aa01fa4ac52426551">DataType::Float</a>(32)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;buffer&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new buffer given shape, and dtype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The shape of the buffer, </td></tr>
    <tr><td class="paramname">dtype</td><td>The content data type. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created buffer. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtvm_1_1tir_1_1BufferNode.html#abdf17916660dd43932e3f72958ca297d">BufferNode::make</a> for complete constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f89ddc934004f9e58b2e6ac3a260e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::DecorateDeviceScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9b75fe00e0f29e2cc8e2b3ffe541ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="af7135e786c567aacc96fa95bac4dae4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deep compare lhs and rhs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left operand </td></tr>
    <tr><td class="paramname">rhs</td><td>The right operand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The comparison result. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a95f59679b6acbb47ab488a1e2c6b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether e expression used var. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">v</td><td>The variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses v. </dd></dl>

</div>
</div>
<a class="anchor" id="ae82ce8b3c5f0cd3a8213b90153637177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::ExprUseVar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether e expression used any var in variable set.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The expression to be checked. </td></tr>
    <tr><td class="paramname">vset</td><td>The variable set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether e uses vset. </dd></dl>

</div>
</div>
<a class="anchor" id="a93a2b6c1ea585d4cfd12539e65f48fdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::HasSideEffect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether the expression have side effect. </p>
<dl class="section return"><dt>Returns</dt><dd>whether expression have side effect </dd></dl>

</div>
</div>
<a class="anchor" id="a803eaac5980c445a9ff8e38fb2c595fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::HoistIfThenElse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loop invariant code motion which locates and hoists if statements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to do if statement hoisting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="acd928ded601486ae3a3b787df3f09688"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::InferFragment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the TensorCore fragment infomation using tensor intrinsics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3550907081d6332c5a4b0849e1948c79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::InjectCopyIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pragma_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>fintrin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject copy intrinsics with optional pad. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be transformed. </td></tr>
    <tr><td class="paramname">pragma_key</td><td>The pragma key for hint of copy. </td></tr>
    <tr><td class="paramname">fintrin</td><td>The function with signature</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a> fintrin(<a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> src, <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> dst, Array&lt;Expr&gt; pad_before, Array&lt;Expr&gt; pad_after, Expr pad_value) </p><dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="abde051e07d9c7ba41d5676ce64208766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::InjectDoubleBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>split_loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject double buffer into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be transformed. </td></tr>
    <tr><td class="paramname">split_loop</td><td>Loop splitting factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d45de8cf5b6053ab16dde307a00238d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::InjectPrefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject prefetch instructions into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9c2135e4a2a674c7ffe1f414d9b362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::InjectVirtualThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject virtual thread loops into stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a96379de32bcde10449bdb01b9b816e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Inline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1FunctionRef.html">FunctionRef</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inline all calls of f in stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to apply inline optimization. </td></tr>
    <tr><td class="paramname">f</td><td>The function reference to be inlined </td></tr>
    <tr><td class="paramname">args</td><td>The arguments variable of the function. </td></tr>
    <tr><td class="paramname">body</td><td>The definition body of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result stmt</dd></dl>
<dl class="section note"><dt>Note</dt><dd>All the passes in this file uses SSA form and outputs SSA form. </dd></dl>

</div>
</div>
<a class="anchor" id="a604c5a3e5e7fad62a912b1d3bb41c3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::InstrumentBoundCheckers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>instruments bound checkers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be instrumented. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Instrumented stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a1217dd1b57e84b5901cf755251b9e164"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::IRTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>preorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1runtime_1_1PackedFunc.html">runtime::PackedFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>postorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>only_enable</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, and transform it </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be transformed. </td></tr>
    <tr><td class="paramname">preorder</td><td>The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/Expr, the transformer will simply return it and won't do further recursion. </td></tr>
    <tr><td class="paramname">postorder</td><td>The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. </td></tr>
    <tr><td class="paramname">only_enable</td><td>List of <a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a>. If it is empty, all IRNode will call preorder/postorder If it is not empty, preorder/postorder will only be called when the IRNode's type key is in the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab706ef9860459b25068f3440d88a7193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant. </p>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant </dd></dl>

</div>
</div>
<a class="anchor" id="a5c414d5e54c099ad7287be302aac8f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_int </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
    <tr><td class="paramname">value</td><td>the value to be compared against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a246623a4a0c9cd8f8a209ec952a8d1c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_const_power_of_two_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether x is a constant power of two If x is power of two, write the power to the shift. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input expression. </td></tr>
    <tr><td class="paramname">shift</td><td>The output shift if x is power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant power of two </dd></dl>

</div>
</div>
<a class="anchor" id="a51d552441331effb387b7c8fb241c454"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_negative_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8de8f843c6eb433b6ddfbf34e24099ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_no_op </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">tir::Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether stmt is nop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The input statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether stmt is nop </dd></dl>

</div>
</div>
<a class="anchor" id="a9b5104dcf0933da31329bb0b2580a947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 1 </dd></dl>

</div>
</div>
<a class="anchor" id="a782dc226f8b2b537efdc56b1f76351d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_positive_const </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a48bad3db162b334837716bf8e7ba9285"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::is_zero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether x is a constant integer 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether x is constant 0 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This only return true for integer types. </dd></dl>

</div>
</div>
<a class="anchor" id="afc0fdee9fc81462318d59dbe64c8df26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* tvm::tir::IterVarType2String </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#add7d0a6b1dd91f0c3c5dd2f4cf64358e">IterVarType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a799dff4f3a280576d6838694c151e657"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::LiftAttrScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>attr_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lift common attrs with attr_key to outer scope. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be transformed </td></tr>
    <tr><td class="paramname">attr_key</td><td>The attribute key to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0606ab38faf2f31d42759f217fdec93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::LoopPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>split_const_loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partition loops in the stmt </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to do loop partition </td></tr>
    <tr><td class="paramname">split_const_loop</td><td>flag to enable partition for const loop </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8725d2ad12962353ec11b6285cc6b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerCustomDatatypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower custom datatypes. </p>
<p>See tvm::datatypes::Registry for more information on adding custom datatypes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">target</td><td>The target device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="afcbd367b40fe2cd31d101c88a63a0b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerDeviceStorageAccessInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower attached storage access information on device. Do this pass after all storage access analysis finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The device function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="adb8b5d13c11411299808c564adda2713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerIntrin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower intrinsic function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">target</td><td>The target device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b6c7e53cce5184e897b0bd24adb06b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::LowerStorageAccessInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower attached storage access information. Do this pass after all storage access analysis finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a438729b72b0e38a28289d763b48995b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerThreadAllreduce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower cross thread alleduce in the stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">warp_size</td><td>the size of warp where no sync is needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d59ba0cb48da1661593b7eeb2e96821"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerTVMBuiltin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower packed function call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be lowered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="af5111eb3e9b9d2f52998c5db4b4e3ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::LowerWarpMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>warp_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lower warp memory in stmt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">warp_size</td><td>the size of warp where no sync is needed. this function will only take in effect if warp_size is bigger than one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ea566597880d04bd62fbec687e338b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename  = typename std::enable_if&lt;std::is_pod&lt;ValueType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const value with certain data type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
    <tr><td class="paramname">value</td><td>The input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The constant value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc4408508a413fb7f3b2567f8d847dbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::make_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a const zero expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2d44994c14f11c500586a007c782c84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::MakeAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>body</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; ObjectRef &gt;&#160;</td>
          <td class="paramname"><em>api_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_unpacked_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_restricted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an user callable API <a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a>. </p>
<p>The main task of this function is to create code to :</p><ul>
<li><a class="el" href="classtvm_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> the values in the api_args to <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TVM ">Var</a> that is required by body.</li>
<li>Insert assertions to check type/value of the passed arguments.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">body</td><td>The body of the function. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the function. </td></tr>
    <tr><td class="paramname">api_args</td><td>Arguments to the function, can be either <a class="el" href="classtvm_1_1tir_1_1Var.html" title="a named variable in TVM ">Var</a>, or <a class="el" href="classtvm_1_1tir_1_1Buffer.html" title="Buffer is a symbolic n-darray structure. It is a composition of primitive symbolic types...">Buffer</a> </td></tr>
    <tr><td class="paramname">num_unpacked_args</td><td>Number of arguments that are processed in plain form instead of packed form. </td></tr>
    <tr><td class="paramname">is_restricted</td><td>Whether the caller can guarantee that each buffer argument do not overlap. It is recommended to set to true for optimized code if such invariant holds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html" title="LoweredFunc represents function after lowering. This is the final IR representation before codegen...">LoweredFunc</a> with the specified signiture.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function signature have two cases</dd></dl>
<p>let num_packed_args = len(api_args) - num_unpacked_args;</p>
<p>if num_packed_args is zero: f(api_arg_0, api_arg_1, .., api_arg_n) where n == len(api_args)</p>
<p>if num_packed_args is not zero: f(TVMArg* packed_args, int* packed_arg_type_ids, int num_packed_args, api_arg_k, api_arg_k+1, ... api_arg_n, TVMValue* out_ret_val, int* out_ret_tcode)</p>
<p>where n == len(api_args), k == num_packed_args</p>
<p>There is no thread_axis in generated function. </p>

</div>
</div>
<a class="anchor" id="af2ca71170aca9d397c2125eb4f55c197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::MakeConstScalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12a98cd1a8440b18d6bac0ad3eaa42ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tvm::tir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetvm_1_1tir.html#ae35cce8e3f1e8d7366dc0d9b15536736">ForType</a>&#160;</td>
          <td class="paramname"><em>for_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad2814a5568d2e1329a5c5aab2e35091e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::PointerValueTypeRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </p>
<dl class="section note"><dt>Note</dt><dd>implemeneted in storage_rewrite.cc </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="abbf2681c6850628b3c9b213298f056b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a> tvm::tir::PointerValueTypeRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1PrimFunc.html">PrimFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. </p>
<dl class="section note"><dt>Note</dt><dd>implemeneted in storage_rewrite.cc </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5067fa233d111c9db9cc402ed599c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::tir::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const ObjectRef &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const ObjectRef &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad55f17f026155f1424b3d0fdd3f86435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::RemapThreadAxis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>, <a class="el" href="classtvm_1_1tir_1_1IterVar.html">IterVar</a> &gt;&#160;</td>
          <td class="paramname"><em>axis_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remap the thread axis. </p>
<p>This can be used to get equivalent program which uses threadIdx.y in place of threadIdx.x by passing {"threadIdx.x": thread_axis("threadIdx.y")}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The device function to be lowered. </td></tr>
    <tr><td class="paramname">axis_map</td><td>The map from <a class="el" href="classtvm_1_1tir_1_1StringImm.html">StringImm</a> -&gt; ItrVar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a64dd52c904c2944a4771b81a2cf8f08a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::RemoveNoOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove No <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a> from the <a class="el" href="classtvm_1_1tir_1_1Stmt.html" title="Container of all statements. ">Stmt</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a00e711fe4801fd2d11f85cb64bc64d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::RewriteForTensorCore </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>&#160;</td>
          <td class="paramname"><em>schedule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>extern_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to modify the AST to support TensorCore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed. </td></tr>
    <tr><td class="paramname">schedule</td><td>The original schedule. </td></tr>
    <tr><td class="paramname">extern_buffer</td><td><a class="el" href="classtvm_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> specifies external buffer assignment of input and outputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3a142f48991df5a96ee1791685ca64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::RewriteUnsafeSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detect and rewrite unsafe select that contains memory access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be rewritten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a923d1bb833c984008772782e90cda37a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;&#160;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression to be simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="a49287db98b766f8900dbbfcc466cb596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Simplify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>vrange</em> = <code><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;&#160;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>,&#160;<a class="el" href="classtvm_1_1Range.html">Range</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be simplifed. </td></tr>
    <tr><td class="paramname">vrange</td><td>The range information about the variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Canonicalized statement. </dd></dl>

</div>
</div>
<a class="anchor" id="a9968b6563c42117a9a1cd4576054400f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::SkipAssert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>skip assert stmt generation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to be transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed function. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f8fc7370ebc9a6b0de19ae9e597576f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::SkipVectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert vectorized loops into serialized loops </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to skip vectorization on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7f5e04aea66d87ad42baf957768c451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&gt; tvm::tir::SplitHostDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the function into a host function and device functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be splitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> of functions, the first one is host function, the others are device functions. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c63e0decac1e98ee375d32dee15526e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::StorageFlatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>, <a class="el" href="classtvm_1_1tir_1_1Buffer.html">Buffer</a> &gt;&#160;</td>
          <td class="paramname"><em>extern_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cache_line_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>create_bound_attribute</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the multi-dimensional read/write to single dimensional Load/Store. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed. </td></tr>
    <tr><td class="paramname">extern_buffer</td><td><a class="el" href="classtvm_1_1Map.html" title="Map container of NodeRef-&gt;NodeRef in DSL graph. Map implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. ">Map</a> specifies external buffer assignment of input and outputs. </td></tr>
    <tr><td class="paramname">cache_line_size</td><td>The size of CPU cache line. </td></tr>
    <tr><td class="paramname">create_bound_attribute</td><td>Whether to create bound attributes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b70ca88f988211332570160c82e3026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::StorageRewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b122873fd63b721684ffb4cd9913bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a1753495736a7c0ab703ed01c673ec5d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; const <a class="el" href="classtvm_1_1tir_1_1VarNode.html">VarNode</a> *, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source expression to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted expression. </dd></dl>

</div>
</div>
<a class="anchor" id="abc79c4131e8b95c4ae4be56d4ab3c494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The source statement to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted form. </dd></dl>

</div>
</div>
<a class="anchor" id="a34e6a1e27339fcc255f664dd14e7c6cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::Substitute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Substitute the var specified in key-&gt;var to be value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The source expression to be substituted </td></tr>
    <tr><td class="paramname">value_map</td><td>The map of new values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The converted expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0df6d882d69f4ec8e1b146a0d8728f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a> tvm::tir::ThreadSync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>storage_scope</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert sync between parallel read/write of shared buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be trasnformed. </td></tr>
    <tr><td class="paramname">storage_scope</td><td>The storage scope considered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb1743e78389c4beaf0b788c631d424e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> tvm::tir::TypeAnnotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetvm.html#a41918af1a1dc386388639a9d3ad06c5d">DataType</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a type annotation expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dtype</td><td>The data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expr a expression with dtype. </dd></dl>

</div>
</div>
<a class="anchor" id="ae110e02855d8bc12eb8b6f92ed391844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a>&gt; tvm::tir::UndefinedVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1tir_1_1Var.html">Var</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>defs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find undefined vars in the statment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The function to be checked. </td></tr>
    <tr><td class="paramname">defs</td><td>The vars that is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> of undefined vars. </dd></dl>

</div>
</div>
<a class="anchor" id="a319c8f6b65c8c053c87b429d6d791343"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::UnrollLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>auto_max_extent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>explicit_unroll</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statment to be unrolled. </td></tr>
    <tr><td class="paramname">auto_max_step</td><td>The maximum step before stop attach automatic unroll </td></tr>
    <tr><td class="paramname">auto_max_depth</td><td>The maximum depth before stop attach automatic unroll </td></tr>
    <tr><td class="paramname">auto_max_extent</td><td>The maximum extent of the loop we can unroll, this is an legacy option that do not take the loop total steps into account. </td></tr>
    <tr><td class="paramname">explicit_unroll</td><td>Whether explicitly unroll the loop, or leave unroll annotation to codegen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="abdd6d56877b9dd03803f433352b09060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> tvm::tir::VectorizeLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vectorize the constant loops </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be vectorized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transformed stmt. </dd></dl>

</div>
</div>
<a class="anchor" id="ae892521d99d9475a59e2d01df9413b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyCompactBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if there is any argument bound to compact buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The stmt to be verified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any buffer_bind_scope attribute found, otherwise, false. </dd></dl>

</div>
</div>
<a class="anchor" id="a705b3e58180a12eba5297cb2442fd1a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyGPUCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a>&#160;</td>
          <td class="paramname"><em>stmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; std::string, <a class="el" href="classtvm_1_1PrimExpr.html">PrimExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify the correctness of a GPU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stmt</td><td>The statement to be checked </td></tr>
    <tr><td class="paramname">constraints</td><td>The dict to specify constraints to check. Possible keys are</td></tr>
  </table>
  </dd>
</dl>
<p>"max_local_memory_per_block": Total amount of local memory per block (in bytes). "max_shared_memory_per_block": Total amount of shared memory per block (in bytes). "max_threads_per_block": Maximum number of threads per block. "max_thread_x": Maximum length of threadIdx.x. "max_thread_y": Maximum length of threadIdx.y. "max_thread_z": Maximum length of threadIdx.z.</p>
<p>If one key is missing in this argument, the pass won't check for that item. </p><dl class="section return"><dt>Returns</dt><dd>valid Whether it is a valid GPU code </dd></dl>

</div>
</div>
<a class="anchor" id="aa649448c69d8324ba1fd7ec5e3e54731"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifyMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1tir_1_1LoweredFunc.html">LoweredFunc</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verify if memory accesses are legal for a specific target device type. </p>
<p>In the case that tgt is cuda, if not all workload is bound with threads, CPU code is generated that tries to access GPU memory, which is illegal. This pass performs verification for this case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to be verified. </td></tr>
    <tr><td class="paramname">device_type</td><td>The target device type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Success of memory verification. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4506ebe76b8f44653dafdf0aef263f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::tir::VerifySSA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1tir_1_1Stmt.html">Stmt</a> &amp;&#160;</td>
          <td class="paramname"><em>ir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verifies whether the IR stmt or Expr is in SSA form. That is: each VarExpr is defined and assigned once(in Let/For) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ir</td><td>The root of the IR DAG. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether IR is in SSA form. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>All the passes in this file uses SSA form and outputs SSA form. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
