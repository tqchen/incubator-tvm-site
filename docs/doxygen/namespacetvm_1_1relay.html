<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::relay Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="namespacetvm_1_1relay.html">relay</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tvm::relay Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Relay: a high level functional IR for TVM.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1attr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1attr.html">attr</a></td></tr>
<tr class="memdesc:namespacetvm_1_1relay_1_1attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace of the attributes that can be attached to a <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">relay::Function</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1qnn"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1qnn.html">qnn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetvm_1_1relay_1_1transform"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay_1_1transform.html">transform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AdaptivePool2DAttrs.html">AdaptivePool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for adaptive pool operator.  <a href="structtvm_1_1relay_1_1AdaptivePool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AdaptivePool3DAttrs.html">AdaptivePool3DAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AllocTensorAttrs.html">AllocTensorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for allocating tensors.  <a href="structtvm_1_1relay_1_1AllocTensorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArangeAttrs.html">ArangeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in arange operators.  <a href="structtvm_1_1relay_1_1ArangeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ArgsortAttrs.html">ArgsortAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in argsort operators.  <a href="structtvm_1_1relay_1_1ArgsortAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool1DAttrs.html">AvgPool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1D avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool2DAttrs.html">AvgPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1AvgPool3DAttrs.html">AvgPool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3D avg pool operator.  <a href="structtvm_1_1relay_1_1AvgPool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BatchNormAttrs.html">BatchNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in batch_norm operator.  <a href="structtvm_1_1relay_1_1BatchNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BiasAddAttrs.html">BiasAddAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a 1D Tensor to an axis of a data.  <a href="structtvm_1_1relay_1_1BiasAddAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BinaryConv2DAttrs.html">BinaryConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribues used in bitserial convolution operators.  <a href="structtvm_1_1relay_1_1BinaryConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BinaryDenseAttrs.html">BinaryDenseAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1BitPackAttrs.html">BitPackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in bitpack operators.  <a href="structtvm_1_1relay_1_1BitPackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1CallNode.html">CallNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> container.  <a href="classtvm_1_1relay_1_1CallNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CastAttrs.html">CastAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">data type cast  <a href="structtvm_1_1relay_1_1CastAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CastHintAttrs.html">CastHintAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotate an expression to be cast into specific data type.  <a href="structtvm_1_1relay_1_1CastHintAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ClauseNode.html">ClauseNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Clause.html">Clause</a> container node.  <a href="classtvm_1_1relay_1_1ClauseNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ClipAttrs.html">ClipAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Clip operator.  <a href="structtvm_1_1relay_1_1ClipAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CompilerAttrs.html">CompilerAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the operators used to annotate a compiler.  <a href="structtvm_1_1relay_1_1CompilerAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConcatenateAttrs.html">ConcatenateAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in concatenate operators.  <a href="structtvm_1_1relay_1_1ConcatenateAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstantNode.html">ConstantNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Constant.html">Constant</a> tensor type.  <a href="classtvm_1_1relay_1_1ConstantNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ConstructorValue.html">ConstructorValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ConstructorValueObj.html">ConstructorValueObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv1DAttrs.html">Conv1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in 1D convolution operators.  <a href="structtvm_1_1relay_1_1Conv1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv1DTransposeAttrs.html">Conv1DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in 1D transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv1DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DAttrs.html">Conv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators.  <a href="structtvm_1_1relay_1_1Conv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html">Conv2DTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transposed convolution operator.  <a href="structtvm_1_1relay_1_1Conv2DTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html">Conv2DWinogradAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators with winograd algorithm.  <a href="structtvm_1_1relay_1_1Conv2DWinogradAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html">Conv2DWinogradNNPACKWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs.html">Conv2DWinogradWeightTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in winograd weight transformation operators.  <a href="structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Conv3DAttrs.html">Conv3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in convolution operators.  <a href="structtvm_1_1relay_1_1Conv3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1CropAndResizeAttrs.html">CropAndResizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image crop_and_resize operator.  <a href="structtvm_1_1relay_1_1CropAndResizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DebugAttrs.html">DebugAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the debug operators.  <a href="structtvm_1_1relay_1_1DebugAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html">DeformableConv2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for DeformableConv2D operator.  <a href="structtvm_1_1relay_1_1DeformableConv2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DenseAttrs.html">DenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for dense operator.  <a href="structtvm_1_1relay_1_1DenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DeviceCopyAttrs.html">DeviceCopyAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the device copy operators.  <a href="structtvm_1_1relay_1_1DeviceCopyAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1Dilation2DAttrs.html">Dilation2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dilation operators.  <a href="structtvm_1_1relay_1_1Dilation2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1DropoutAttrs.html">DropoutAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in dropout operator.  <a href="structtvm_1_1relay_1_1DropoutAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ExpandDimsAttrs.html">ExpandDimsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in expand_dims operators.  <a href="structtvm_1_1relay_1_1ExpandDimsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html">ExprFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>.  <a href="classtvm_1_1relay_1_1ExprFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4.html">ExprFunctor&lt; R(const Expr &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprMutator.html">ExprMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1ExprMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1ExprVisitor.html">ExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a>. Recursively visit the content.  <a href="classtvm_1_1relay_1_1ExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A finite set of Feature.  <a href="classtvm_1_1relay_1_1FeatureSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1FIFOBufferAttrs.html">FIFOBufferAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for FIFO buffer operator.  <a href="structtvm_1_1relay_1_1FIFOBufferAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Managed reference to <a class="el" href="classtvm_1_1relay_1_1FunctionNode.html" title="Relay Function container. ">FunctionNode</a>.  <a href="classtvm_1_1relay_1_1Function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1FunctionNode.html">FunctionNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relay <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> container.  <a href="classtvm_1_1relay_1_1FunctionNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GetValidCountsAttrs.html">GetValidCountsAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in get_valid_counts operator.  <a href="structtvm_1_1relay_1_1GetValidCountsAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html">GlobalPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for global pool operator.  <a href="structtvm_1_1relay_1_1GlobalPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Id.html">Id</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IdNode.html">IdNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unique identifier of variables.  <a href="classtvm_1_1relay_1_1IdNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1If.html">If</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1IfNode.html">IfNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">container of <a class="el" href="classtvm_1_1relay_1_1If.html">If</a>  <a href="classtvm_1_1relay_1_1IfNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1InitOpAttrs.html">InitOpAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes that specify a tensor.  <a href="structtvm_1_1relay_1_1InitOpAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1InstanceNormAttrs.html">InstanceNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in instance_norm operator.  <a href="structtvm_1_1relay_1_1InstanceNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1InterpreterClosure.html">InterpreterClosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1InterpreterClosureObj.html">InterpreterClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container type of Closures used by the interpreter.  <a href="classtvm_1_1relay_1_1InterpreterClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1L2NormalizeAttrs.html">L2NormalizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for L2Normalize operator.  <a href="structtvm_1_1relay_1_1L2NormalizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LayerNormAttrs.html">LayerNormAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in layer_norm operator.  <a href="structtvm_1_1relay_1_1LayerNormAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LayoutTransformAttrs.html">LayoutTransformAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LayoutTransform operator.  <a href="structtvm_1_1relay_1_1LayoutTransformAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LeakyReluAttrs.html">LeakyReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for leaky relu operator.  <a href="structtvm_1_1relay_1_1LeakyReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Let.html">Let</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1LetNode.html">LetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binding of a sub-network.  <a href="classtvm_1_1relay_1_1LetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1LRNAttrs.html">LRNAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for LRN operator.  <a href="structtvm_1_1relay_1_1LRNAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1MatchNode.html">MatchNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> container node.  <a href="classtvm_1_1relay_1_1MatchNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool1DAttrs.html">MaxPool1DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 1D max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool1DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool2DAttrs.html">MaxPool2DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool2DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MaxPool3DAttrs.html">MaxPool3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for 3D max pool operator.  <a href="structtvm_1_1relay_1_1MaxPool3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MirrorPadAttrs.html">MirrorPadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the MirrorPadding operator.  <a href="structtvm_1_1relay_1_1MirrorPadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html">MultiBoxPriorAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in multibox_prior operators.  <a href="structtvm_1_1relay_1_1MultiBoxPriorAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1MultiBoxTransformLocAttrs.html">MultiBoxTransformLocAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NdarraySizeAttrs.html">NdarraySizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for ndarray_size operator.  <a href="structtvm_1_1relay_1_1NdarraySizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html">NonMaximumSuppressionAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in non_maximum_suppression operator.  <a href="structtvm_1_1relay_1_1NonMaximumSuppressionAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1OnDeviceAttrs.html">OnDeviceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the device annotation operators.  <a href="structtvm_1_1relay_1_1OnDeviceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1OneHotAttrs.html">OneHotAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in one-hot operator.  <a href="structtvm_1_1relay_1_1OneHotAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpImplementation.html">OpImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation class.  <a href="classtvm_1_1relay_1_1OpImplementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpImplementationNode.html">OpImplementationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator implementation that includes compute and schedule function.  <a href="classtvm_1_1relay_1_1OpImplementationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpSpecialization.html">OpSpecialization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator specialization class.  <a href="classtvm_1_1relay_1_1OpSpecialization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpSpecializationNode.html">OpSpecializationNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized implementations for operators under certain conditions.  <a href="classtvm_1_1relay_1_1OpSpecializationNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpStrategy.html">OpStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator strategy class.  <a href="classtvm_1_1relay_1_1OpStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1OpStrategyNode.html">OpStrategyNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator strategy to choose implementation.  <a href="classtvm_1_1relay_1_1OpStrategyNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PadAttrs.html">PadAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used for the padding operator.  <a href="structtvm_1_1relay_1_1PadAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a> is the base type for an ADT match pattern in Relay.  <a href="classtvm_1_1relay_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructor.html">PatternConstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternConstructorNode.html">PatternConstructorNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternConstructorNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html">PatternFunctor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more powerful visitor, since it allows you to define the types of further arguments to VisitPattern.  <a href="classtvm_1_1relay_1_1PatternFunctor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternFunctor_3_01R_07const_01Pattern_01_6n_00_01Args_8_8_8_08_4.html">PatternFunctor&lt; R(const Pattern &amp;n, Args...)&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternMutator.html">PatternMutator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classtvm_1_1relay_1_1ExprFunctor.html" title="A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerfu...">ExprFunctor</a> which functionally updates the AST.  <a href="classtvm_1_1relay_1_1PatternMutator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternNode.html">PatternNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for declaring relay pattern.  <a href="classtvm_1_1relay_1_1PatternNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternTuple.html">PatternTuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternTupleNode.html">PatternTupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternTupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVarNode.html">PatternVarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternVar.html">PatternVar</a> container node.  <a href="classtvm_1_1relay_1_1PatternVarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternVisitor.html">PatternVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple visitor wrapper around <a class="el" href="classtvm_1_1relay_1_1PatternFunctor.html" title="A dynamical functor on ADT patterns that dispatches on its first argument. You can use this as a more...">PatternFunctor</a>.  <a href="classtvm_1_1relay_1_1PatternVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1PatternWildcardNode.html">PatternWildcardNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1PatternWildcard.html">PatternWildcard</a> container node.  <a href="classtvm_1_1relay_1_1PatternWildcardNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1PReluAttrs.html">PReluAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for prelu operator.  <a href="structtvm_1_1relay_1_1PReluAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ProposalAttrs.html">ProposalAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in proposal operators.  <a href="structtvm_1_1relay_1_1ProposalAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RecClosure.html">RecClosure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RecClosureObj.html">RecClosureObj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container type of <a class="el" href="classtvm_1_1relay_1_1RecClosure.html">RecClosure</a>.  <a href="classtvm_1_1relay_1_1RecClosureObj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReduceAttrs.html">ReduceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for Reduce operators.  <a href="structtvm_1_1relay_1_1ReduceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreate.html">RefCreate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefCreateNode.html">RefCreateNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefRead.html">RefRead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefReadNode.html">RefReadNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefValue.html">RefValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RefValueObj.html">RefValueObj</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWrite.html">RefWrite</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RefWriteNode.html">RefWriteNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1RelayNode.html">RelayNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base node container of all relay structures.  <a href="classtvm_1_1relay_1_1RelayNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1RepeatAttrs.html">RepeatAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in repeat operators.  <a href="structtvm_1_1relay_1_1RepeatAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReshapeAttrs.html">ReshapeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reshape operators.  <a href="structtvm_1_1relay_1_1ReshapeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ResizeAttrs.html">ResizeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in image resize operator.  <a href="structtvm_1_1relay_1_1ResizeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ReverseAttrs.html">ReverseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in reverse operators.  <a href="structtvm_1_1relay_1_1ReverseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIAlignAttrs.html">ROIAlignAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_align operators.  <a href="structtvm_1_1relay_1_1ROIAlignAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ROIPoolAttrs.html">ROIPoolAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in roi_pool operators.  <a href="structtvm_1_1relay_1_1ROIPoolAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SequenceMaskAttrs.html">SequenceMaskAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ShapeFuncAttrs.html">ShapeFuncAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for the shape function operator.  <a href="structtvm_1_1relay_1_1ShapeFuncAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1ShapeOfAttrs.html">ShapeOfAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for ShapeOf operator.  <a href="structtvm_1_1relay_1_1ShapeOfAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SliceLikeAttrs.html">SliceLikeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SoftmaxAttrs.html">SoftmaxAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in softmax operators.  <a href="structtvm_1_1relay_1_1SoftmaxAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseDenseAttrs.html">SparseDenseAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for sparse_dense operator.  <a href="structtvm_1_1relay_1_1SparseDenseAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SparseTransposeAttrs.html">SparseTransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for sparse_transpose operator.  <a href="structtvm_1_1relay_1_1SparseTransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SplitAttrs.html">SplitAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SqueezeAttrs.html">SqueezeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in squeeze operators.  <a href="structtvm_1_1relay_1_1SqueezeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StackAttrs.html">StackAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in stack operators.  <a href="structtvm_1_1relay_1_1StackAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1StridedSliceAttrs.html">StridedSliceAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for StridedSlice operator.  <a href="structtvm_1_1relay_1_1StridedSliceAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1SubPixelAttrs.html">SubPixelAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in subpixel operators.  <a href="structtvm_1_1relay_1_1SubPixelAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TakeAttrs.html">TakeAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TempExprNode.html">TempExprNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of the temporary expression.  <a href="classtvm_1_1relay_1_1TempExprNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TileAttrs.html">TileAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in tile operators.  <a href="structtvm_1_1relay_1_1TileAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TopKAttrs.html">TopKAttrs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1TransposeAttrs.html">TransposeAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in transpose operators.  <a href="structtvm_1_1relay_1_1TransposeAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItem.html">TupleGetItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleGetItemNode.html">TupleGetItemNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1TupleNode.html">TupleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtvm_1_1relay_1_1Tuple.html">Tuple</a> container.  <a href="classtvm_1_1relay_1_1TupleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UpSampling3DAttrs.html">UpSampling3DAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for upsampling3d operator.  <a href="structtvm_1_1relay_1_1UpSampling3DAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1UpSamplingAttrs.html">UpSamplingAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes for upsampling operator.  <a href="structtvm_1_1relay_1_1UpSamplingAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1relay_1_1VarNode.html">VarNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>.  <a href="classtvm_1_1relay_1_1VarNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1relay_1_1YoloReorgAttrs.html">YoloReorgAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes used in yolo reorg operators.  <a href="structtvm_1_1relay_1_1YoloReorgAttrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aec85bf097deda59bd22e88475c9165e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aec85bf097deda59bd22e88475c9165e9">Constructor</a> = <a class="el" href="classtvm_1_1Constructor.html">tvm::Constructor</a></td></tr>
<tr class="separator:aec85bf097deda59bd22e88475c9165e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b95f70a9b44cc1c96593201594d1345"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b95f70a9b44cc1c96593201594d1345">ConstructorNode</a> = <a class="el" href="classtvm_1_1ConstructorNode.html">tvm::ConstructorNode</a></td></tr>
<tr class="separator:a6b95f70a9b44cc1c96593201594d1345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e725a1cb4c83346e261eac7dc7292a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">TypeData</a> = <a class="el" href="classtvm_1_1TypeData.html">tvm::TypeData</a></td></tr>
<tr class="separator:a6e725a1cb4c83346e261eac7dc7292a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8c0d5920eaca88569907e92df6066f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2b8c0d5920eaca88569907e92df6066f">TypeDataNode</a> = <a class="el" href="classtvm_1_1TypeDataNode.html">tvm::TypeDataNode</a></td></tr>
<tr class="separator:a2b8c0d5920eaca88569907e92df6066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae153a27d81399fd266b8d598227764c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> = ::<a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a></td></tr>
<tr class="memdesc:ae153a27d81399fd266b8d598227764c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic expression for tensor shape.  <a href="#ae153a27d81399fd266b8d598227764c4">More...</a><br /></td></tr>
<tr class="separator:ae153a27d81399fd266b8d598227764c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14eacafcb803b0757e48654bb1bac655"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a14eacafcb803b0757e48654bb1bac655">SourceName</a> = <a class="el" href="classtvm_1_1SourceName.html">tvm::SourceName</a></td></tr>
<tr class="separator:a14eacafcb803b0757e48654bb1bac655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ca6124bc2e88f2323eeb79d326cc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">Span</a> = <a class="el" href="classtvm_1_1Span.html">tvm::Span</a></td></tr>
<tr class="separator:af40ca6124bc2e88f2323eeb79d326cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0fa6578e97d0d64b08865f94f04827"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7d0fa6578e97d0d64b08865f94f04827">SpanNode</a> = <a class="el" href="classtvm_1_1SpanNode.html">tvm::SpanNode</a></td></tr>
<tr class="separator:a7d0fa6578e97d0d64b08865f94f04827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b84e3790f89bb3fad5c7911eeb99531"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> = <a class="el" href="classtvm_1_1RelayExpr.html">tvm::RelayExpr</a></td></tr>
<tr class="separator:a5b84e3790f89bb3fad5c7911eeb99531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387f18e050d016c52ea6c4781e7cff6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a387f18e050d016c52ea6c4781e7cff6c">ExprNode</a> = <a class="el" href="classtvm_1_1RelayExprNode.html">tvm::RelayExprNode</a></td></tr>
<tr class="separator:a387f18e050d016c52ea6c4781e7cff6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbaff2ae7feec23fea55e025a9cc1b76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">BaseFunc</a> = <a class="el" href="classtvm_1_1BaseFunc.html">tvm::BaseFunc</a></td></tr>
<tr class="separator:acbaff2ae7feec23fea55e025a9cc1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edf28d1226abc08d28bc2fd90ce7b42"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4edf28d1226abc08d28bc2fd90ce7b42">BaseFuncNode</a> = <a class="el" href="classtvm_1_1BaseFuncNode.html">tvm::BaseFuncNode</a></td></tr>
<tr class="separator:a4edf28d1226abc08d28bc2fd90ce7b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac7c3d0824529fddce7849c9c66289"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a> = <a class="el" href="classtvm_1_1GlobalVar.html">tvm::GlobalVar</a></td></tr>
<tr class="separator:a81ac7c3d0824529fddce7849c9c66289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7144195dbbc914183189444ef6a347"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afe7144195dbbc914183189444ef6a347">GlobalVarNode</a> = <a class="el" href="classtvm_1_1GlobalVarNode.html">tvm::GlobalVarNode</a></td></tr>
<tr class="separator:afe7144195dbbc914183189444ef6a347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c46d15e80f1a9916b8e9c264a185c98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6c46d15e80f1a9916b8e9c264a185c98">Op</a> = <a class="el" href="classtvm_1_1Op.html">tvm::Op</a></td></tr>
<tr class="separator:a6c46d15e80f1a9916b8e9c264a185c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d4f2cf78a48659817a88d890e1d142"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac9d4f2cf78a48659817a88d890e1d142">OpNode</a> = <a class="el" href="classtvm_1_1OpNode.html">tvm::OpNode</a></td></tr>
<tr class="separator:ac9d4f2cf78a48659817a88d890e1d142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">TOpPattern</a> = int</td></tr>
<tr class="memdesc:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="mdescLeft">&#160;</td><td class="mdescRight">the operator pattern  <a href="#a5dab2ddae20ac7564a81ab3a0a9aba76">More...</a><br /></td></tr>
<tr class="separator:a5dab2ddae20ac7564a81ab3a0a9aba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">TOpIsStateful</a> = bool</td></tr>
<tr class="memdesc:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether operator is stateful or contain internal state.  <a href="#afb8a8d4dd43830d4ce7d566abcd1c450">More...</a><br /></td></tr>
<tr class="separator:afb8a8d4dd43830d4ce7d566abcd1c450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">TNonComputational</a> = bool</td></tr>
<tr class="memdesc:ab4c835287dfc5ec074ea8431bcebbb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator as non-computational.  <a href="#ab4c835287dfc5ec074ea8431bcebbb17">More...</a><br /></td></tr>
<tr class="separator:ab4c835287dfc5ec074ea8431bcebbb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75252d8d7e8d18b796074ffe4cc9f3ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a75252d8d7e8d18b796074ffe4cc9f3ff">TShapeDataDependant</a> = bool</td></tr>
<tr class="memdesc:a75252d8d7e8d18b796074ffe4cc9f3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the operator whether output shape is data dependant.  <a href="#a75252d8d7e8d18b796074ffe4cc9f3ff">More...</a><br /></td></tr>
<tr class="separator:a75252d8d7e8d18b796074ffe4cc9f3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a0893a8379998657ddff39a3162188"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a63a0893a8379998657ddff39a3162188">FTVMCompute</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;inputs, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;out_type)&gt;</td></tr>
<tr class="memdesc:a63a0893a8379998657ddff39a3162188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation description interface.  <a href="#a63a0893a8379998657ddff39a3162188">More...</a><br /></td></tr>
<tr class="separator:a63a0893a8379998657ddff39a3162188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f7c5928c79389da637c35df6c8557c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af8f7c5928c79389da637c35df6c8557c">FTVMSchedule</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;outs, const <a class="el" href="classtvm_1_1Target.html">Target</a> &amp;target)&gt;</td></tr>
<tr class="memdesc:af8f7c5928c79389da637c35df6c8557c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the computation schedule for op whose root is at current op.  <a href="#af8f7c5928c79389da637c35df6c8557c">More...</a><br /></td></tr>
<tr class="separator:af8f7c5928c79389da637c35df6c8557c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2eb2ad4e7a83e0a28e2ad073d7bf9305">FTVMStrategy</a> = <a class="el" href="classtvm_1_1GenericFunc.html">GenericFunc</a></td></tr>
<tr class="memdesc:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the strategy of operators. This function is a generic function and can be re-defined for different targets.  <a href="#a2eb2ad4e7a83e0a28e2ad073d7bf9305">More...</a><br /></td></tr>
<tr class="separator:a2eb2ad4e7a83e0a28e2ad073d7bf9305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36536541a0688d02f9172bf8a35813b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac36536541a0688d02f9172bf8a35813b">FTVMAlterOpLayout</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;tinfos, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;out_type)&gt;</td></tr>
<tr class="memdesc:ac36536541a0688d02f9172bf8a35813b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass.  <a href="#ac36536541a0688d02f9172bf8a35813b">More...</a><br /></td></tr>
<tr class="separator:ac36536541a0688d02f9172bf8a35813b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526f835aaefdc86a8faa7da39802ebd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a526f835aaefdc86a8faa7da39802ebd5">FTVMConvertOpLayout</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;tinfos, const std::string &amp;desired_layout)&gt;</td></tr>
<tr class="memdesc:a526f835aaefdc86a8faa7da39802ebd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the layout of operators or replace the operator with other expressions. This function will be invoked in ConvertLayout pass.  <a href="#a526f835aaefdc86a8faa7da39802ebd5">More...</a><br /></td></tr>
<tr class="separator:a526f835aaefdc86a8faa7da39802ebd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40770ea2c292eec7b9ebe4d310c67fb5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a40770ea2c292eec7b9ebe4d310c67fb5">FTVMLegalize</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a> &gt; &amp;arg_types)&gt;</td></tr>
<tr class="memdesc:a40770ea2c292eec7b9ebe4d310c67fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legalizes an expression with another expression. This function will be invoked in Legalize pass. It is a target-dependent pass.  <a href="#a40770ea2c292eec7b9ebe4d310c67fb5">More...</a><br /></td></tr>
<tr class="separator:a40770ea2c292eec7b9ebe4d310c67fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab140f1857d8471d98fe5371f8da68154"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab140f1857d8471d98fe5371f8da68154">FTVMAnnotateTarget</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; bool(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;args)&gt;</td></tr>
<tr class="memdesc:ab140f1857d8471d98fe5371f8da68154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Annotates an expression to indicate if an op should be compiled using the given compiler/target.  <a href="#ab140f1857d8471d98fe5371f8da68154">More...</a><br /></td></tr>
<tr class="separator:ab140f1857d8471d98fe5371f8da68154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04117f6f0a173924ff2f6d080c9265c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa04117f6f0a173924ff2f6d080c9265c">FForwardRewrite</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;ref_call, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;new_args, const ObjectRef &amp;ctx)&gt;</td></tr>
<tr class="memdesc:aa04117f6f0a173924ff2f6d080c9265c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward rewriting rule for a specific op.  <a href="#aa04117f6f0a173924ff2f6d080c9265c">More...</a><br /></td></tr>
<tr class="separator:aa04117f6f0a173924ff2f6d080c9265c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abada45a4f21ae750c1caba923f1059"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">FPrimalGradient</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt;(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;orig_call, const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;output_grad)&gt;</td></tr>
<tr class="memdesc:a9abada45a4f21ae750c1caba923f1059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient for a specific op.  <a href="#a9abada45a4f21ae750c1caba923f1059">More...</a><br /></td></tr>
<tr class="separator:a9abada45a4f21ae750c1caba923f1059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d64348ae2b75977e167109fb4af4409"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4d64348ae2b75977e167109fb4af4409">Shape</a> = <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> &gt;</td></tr>
<tr class="memdesc:a4d64348ae2b75977e167109fb4af4409"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime representation of shape.  <a href="#a4d64348ae2b75977e167109fb4af4409">More...</a><br /></td></tr>
<tr class="separator:a4d64348ae2b75977e167109fb4af4409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7012819c4abe61de2d52e4bf94cfbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6f7012819c4abe61de2d52e4bf94cfbd">FShapeFunc</a> = <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a> &amp;attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a> &gt; &amp;inputs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a> &gt; &amp;out_ndims)&gt;</td></tr>
<tr class="separator:a6f7012819c4abe61de2d52e4bf94cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b4b16b28a3cfd5052b2b4214a440d9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa6b4b16b28a3cfd5052b2b4214a440d9">Any</a> = <a class="el" href="classtvm_1_1tir_1_1AnyNode.html">tvm::tir::AnyNode</a></td></tr>
<tr class="separator:aa6b4b16b28a3cfd5052b2b4214a440d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44e35e7d791c8dd53bb00ddb6411b38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa44e35e7d791c8dd53bb00ddb6411b38">Kind</a> = <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">TypeKind</a></td></tr>
<tr class="separator:aa44e35e7d791c8dd53bb00ddb6411b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d95f170bca230773914caeef3fe52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> = <a class="el" href="classtvm_1_1Type.html">tvm::Type</a></td></tr>
<tr class="separator:a661d95f170bca230773914caeef3fe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6995f0c848d0d5cc4124a38f43aaf12"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af6995f0c848d0d5cc4124a38f43aaf12">TypeNode</a> = <a class="el" href="classtvm_1_1TypeNode.html">tvm::TypeNode</a></td></tr>
<tr class="separator:af6995f0c848d0d5cc4124a38f43aaf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63321eb51080f3f57dd7563a3ca0bfa6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> = <a class="el" href="classtvm_1_1TypeVar.html">tvm::TypeVar</a></td></tr>
<tr class="separator:a63321eb51080f3f57dd7563a3ca0bfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cbe31b81ebd71ea8028a8404a7c9f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab2cbe31b81ebd71ea8028a8404a7c9f3">TypeVarNode</a> = <a class="el" href="classtvm_1_1TypeVarNode.html">tvm::TypeVarNode</a></td></tr>
<tr class="separator:ab2cbe31b81ebd71ea8028a8404a7c9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235e350f9cd1eac3aa0177034976043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">GlobalTypeVar</a> = <a class="el" href="classtvm_1_1GlobalTypeVar.html">tvm::GlobalTypeVar</a></td></tr>
<tr class="separator:a2235e350f9cd1eac3aa0177034976043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a10e2305e3a50dd00e07b043b93b5e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a9a10e2305e3a50dd00e07b043b93b5e8">GlobalTypeVarNode</a> = <a class="el" href="classtvm_1_1GlobalTypeVarNode.html">tvm::GlobalTypeVarNode</a></td></tr>
<tr class="separator:a9a10e2305e3a50dd00e07b043b93b5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9102638dffea6747ae9fa9be9f00f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ace9102638dffea6747ae9fa9be9f00f2">TupleType</a> = <a class="el" href="classtvm_1_1TupleType.html">tvm::TupleType</a></td></tr>
<tr class="separator:ace9102638dffea6747ae9fa9be9f00f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916609c894ac1000b66f9582f338d965"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a916609c894ac1000b66f9582f338d965">TupleTypeNode</a> = <a class="el" href="classtvm_1_1TupleTypeNode.html">tvm::TupleTypeNode</a></td></tr>
<tr class="separator:a916609c894ac1000b66f9582f338d965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e2e93fe04716efd8334ab4e39c92ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a64e2e93fe04716efd8334ab4e39c92ce">TypeConstraint</a> = <a class="el" href="classtvm_1_1TypeConstraint.html">tvm::TypeConstraint</a></td></tr>
<tr class="separator:a64e2e93fe04716efd8334ab4e39c92ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565e027589acded20ca38df22be098dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a565e027589acded20ca38df22be098dc">TypeConstraintNode</a> = <a class="el" href="classtvm_1_1TypeConstraintNode.html">tvm::TypeConstraintNode</a></td></tr>
<tr class="separator:a565e027589acded20ca38df22be098dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475de90506d48a1bb04ef6d1bd99bfb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa475de90506d48a1bb04ef6d1bd99bfb">FuncType</a> = <a class="el" href="classtvm_1_1FuncType.html">tvm::FuncType</a></td></tr>
<tr class="separator:aa475de90506d48a1bb04ef6d1bd99bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab551714015417af28d5ca2b47722997e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab551714015417af28d5ca2b47722997e">FuncTypeNode</a> = <a class="el" href="classtvm_1_1FuncTypeNode.html">tvm::FuncTypeNode</a></td></tr>
<tr class="separator:ab551714015417af28d5ca2b47722997e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34535a1f05224c26db569bc134de7647"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a34535a1f05224c26db569bc134de7647">IncompleteType</a> = <a class="el" href="classtvm_1_1IncompleteType.html">tvm::IncompleteType</a></td></tr>
<tr class="separator:a34535a1f05224c26db569bc134de7647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517ebee34b82bdb80f74ffcdcf361940"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a517ebee34b82bdb80f74ffcdcf361940">IncompleteTypeNode</a> = <a class="el" href="classtvm_1_1IncompleteTypeNode.html">tvm::IncompleteTypeNode</a></td></tr>
<tr class="separator:a517ebee34b82bdb80f74ffcdcf361940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fd39dbc2a639262858e9b72e8fb37f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a13fd39dbc2a639262858e9b72e8fb37f">RelayRefType</a> = <a class="el" href="classtvm_1_1RelayRefType.html">tvm::RelayRefType</a></td></tr>
<tr class="separator:a13fd39dbc2a639262858e9b72e8fb37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae665239bd9119c8afb037d47781bf237"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae665239bd9119c8afb037d47781bf237">RelayRefTypeNode</a> = <a class="el" href="classtvm_1_1RelayRefTypeNode.html">tvm::RelayRefTypeNode</a></td></tr>
<tr class="separator:ae665239bd9119c8afb037d47781bf237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c13723bba53f4953dfd10c34d480f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">TensorType</a> = <a class="el" href="classtvm_1_1TensorType.html">tvm::TensorType</a></td></tr>
<tr class="separator:a52c13723bba53f4953dfd10c34d480f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeff91bc774a278a2e9f6103a04387d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acfeff91bc774a278a2e9f6103a04387d">TensorTypeNode</a> = <a class="el" href="classtvm_1_1TensorTypeNode.html">tvm::TensorTypeNode</a></td></tr>
<tr class="separator:acfeff91bc774a278a2e9f6103a04387d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406a37acee11226e3e2e119beee439e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab406a37acee11226e3e2e119beee439e">TypeCall</a> = <a class="el" href="classtvm_1_1TypeCall.html">tvm::TypeCall</a></td></tr>
<tr class="separator:ab406a37acee11226e3e2e119beee439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dccabc877b8fd7db47cb73fb93883e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af4dccabc877b8fd7db47cb73fb93883e">TypeCallNode</a> = <a class="el" href="classtvm_1_1TypeCallNode.html">tvm::TypeCallNode</a></td></tr>
<tr class="separator:af4dccabc877b8fd7db47cb73fb93883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab0d56fd993df71df3068dea0cd5456"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#adab0d56fd993df71df3068dea0cd5456">TypeRelation</a> = <a class="el" href="classtvm_1_1TypeRelation.html">tvm::TypeRelation</a></td></tr>
<tr class="separator:adab0d56fd993df71df3068dea0cd5456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d812eaf13520b04e89a9414c51748c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a89d812eaf13520b04e89a9414c51748c">TypeRelationNode</a> = <a class="el" href="classtvm_1_1TypeRelationNode.html">tvm::TypeRelationNode</a></td></tr>
<tr class="separator:a89d812eaf13520b04e89a9414c51748c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af253112249297a6cfb2a9b94cde0f235"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af253112249297a6cfb2a9b94cde0f235">TypeRelationFn</a> = <a class="el" href="namespacetvm.html#a72dcba4493adfcd8908663898ece3514">tvm::TypeRelationFn</a></td></tr>
<tr class="separator:af253112249297a6cfb2a9b94cde0f235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9be9990c2006832cbfc02ebb35e527"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#afa9be9990c2006832cbfc02ebb35e527">TypeReporter</a> = <a class="el" href="classtvm_1_1TypeReporter.html">tvm::TypeReporter</a></td></tr>
<tr class="separator:afa9be9990c2006832cbfc02ebb35e527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3b5700ea20db399f539cec1abcb12b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aaa3b5700ea20db399f539cec1abcb12b">TypeReporterNode</a> = <a class="el" href="classtvm_1_1TypeReporterNode.html">tvm::TypeReporterNode</a></td></tr>
<tr class="separator:aaa3b5700ea20db399f539cec1abcb12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a926750aeda977340aa82bceac863fc9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">Feature</a> : int { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea42a71e7934e2efe344713b17c426eecd">fVar</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eae9b152650b0ebe6dbc1b42e0f84d567f">fGlobalVar</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea29eacc09610a7fd43026682238aae25f">fConstant</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaa2fe12a180d97822c440e169dc287e66">fTuple</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4d2cb67f2e197880e0971286f2ffb498">fTupleGetItem</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea3b367d0501427ea782137266a2fb77fa">fFunction</a> = 5, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaca21bd0f67c01c6f7b82a1596cdfdf8b">fOp</a> = 6, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea5f3d3030d2ed56e5a47329e29f12ef02">fCall</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea07ce432e7b4b4c044af03e4dbd210ba4">fLet</a> = 8, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4e6b686fb15d50c4aef2316bef53a781">fIf</a> = 9, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea46daa677c87c05e68258acea3579443d">fRefCreate</a> = 10, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea7c9e5e3d738c26c3ed34099f44f66251">fRefRead</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea4737da29588504f7f31cf4fb52925d63">fRefWrite</a> = 12, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaff71be930d862c312a5ae263e71167a2">fConstructor</a> = 13, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9ea53a8eba57c4a3abd37b4c96fb98bf61b">fMatch</a> = 14, 
<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eac6392a0ecc7df38dbfa282a54d3718d1">fGraph</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9eaff508e399703958af46f99ee8eb7d1a5">fLetRec</a> = 16
<br />
 }<tr class="memdesc:a926750aeda977340aa82bceac863fc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different kinds of relay feature a program might use.  <a href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a926750aeda977340aa82bceac863fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">OpPatternKind</a> { <br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa">kElemWise</a> = 0, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245">kBroadcast</a> = 1, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00">kInjective</a> = 2, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738">kCommReduce</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4">kOutEWiseFusable</a> = 4, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578ae5610688419b90595a0701fe007a2ebb">kTuple</a> = 7, 
<a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1">kOpaque</a> = 8
<br />
 }<tr class="memdesc:ab5f4d382bf1bee69c3e484ea6c837578"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator pattern used in graph fusion  <a href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab5f4d382bf1bee69c3e484ea6c837578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab76fedc831b249d1c80d69c4a620a3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">AnyCodegenStrategy</a> { <a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3a1a3550732b0caf3981198af2c1373542">kVariableDimensions</a>
 }<tr class="memdesc:adab76fedc831b249d1c80d69c4a620a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The codegeneration strategy for dynamic dimensions.  <a href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adab76fedc831b249d1c80d69c4a620a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af73e45f453515df6f9c0bbbf189719d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af73e45f453515df6f9c0bbbf189719d6">KindCheck</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:af73e45f453515df6f9c0bbbf189719d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that types are well kinded by applying "kinding rules".  <a href="#af73e45f453515df6f9c0bbbf189719d6">More...</a><br /></td></tr>
<tr class="separator:af73e45f453515df6f9c0bbbf189719d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdade48285a63efffe743e73e41d3b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#abdade48285a63efffe743e73e41d3b35">ConstantCheck</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:abdade48285a63efffe743e73e41d3b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether an expression is constant.  <a href="#abdade48285a63efffe743e73e41d3b35">More...</a><br /></td></tr>
<tr class="separator:abdade48285a63efffe743e73e41d3b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dde25d981d5b506115dd4dba7f67b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a59dde25d981d5b506115dd4dba7f67b7">WellFormed</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a59dde25d981d5b506115dd4dba7f67b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once.  <a href="#a59dde25d981d5b506115dd4dba7f67b7">More...</a><br /></td></tr>
<tr class="separator:a59dde25d981d5b506115dd4dba7f67b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc32688b446d3574932554f6b8c2df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a0bcc32688b446d3574932554f6b8c2df">BoundVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a0bcc32688b446d3574932554f6b8c2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from expression expr.  <a href="#a0bcc32688b446d3574932554f6b8c2df">More...</a><br /></td></tr>
<tr class="separator:a0bcc32688b446d3574932554f6b8c2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcb2b290b4f80292eb34afefc41f0ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aedcb2b290b4f80292eb34afefc41f0ac">BoundVars</a> (const <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &amp;pat)</td></tr>
<tr class="memdesc:aedcb2b290b4f80292eb34afefc41f0ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound variables from pattern pat.  <a href="#aedcb2b290b4f80292eb34afefc41f0ac">More...</a><br /></td></tr>
<tr class="separator:aedcb2b290b4f80292eb34afefc41f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#af2c5771c67f06c0af32c7b4b4269e73f">FreeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:af2c5771c67f06c0af32c7b4b4269e73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free type parameters from expression expr.  <a href="#af2c5771c67f06c0af32c7b4b4269e73f">More...</a><br /></td></tr>
<tr class="separator:af2c5771c67f06c0af32c7b4b4269e73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a6b1e94cf8d97514fe4a9493a0dec1559">AllVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all variables from expression expr.  <a href="#a6b1e94cf8d97514fe4a9493a0dec1559">More...</a><br /></td></tr>
<tr class="separator:a6b1e94cf8d97514fe4a9493a0dec1559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc529cca9623ac81c8aa6e106cdb5850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#acc529cca9623ac81c8aa6e106cdb5850">FreeTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:acc529cca9623ac81c8aa6e106cdb5850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from expression expr.  <a href="#acc529cca9623ac81c8aa6e106cdb5850">More...</a><br /></td></tr>
<tr class="separator:acc529cca9623ac81c8aa6e106cdb5850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446e2b12f3e907336313004c3e0a0c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a446e2b12f3e907336313004c3e0a0c86">FreeTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a446e2b12f3e907336313004c3e0a0c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get free TypeVars from type t.  <a href="#a446e2b12f3e907336313004c3e0a0c86">More...</a><br /></td></tr>
<tr class="separator:a446e2b12f3e907336313004c3e0a0c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1e5aa65b13f8ca172009aa2ff3ba59d6">BoundTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from expression expr.  <a href="#a1e5aa65b13f8ca172009aa2ff3ba59d6">More...</a><br /></td></tr>
<tr class="separator:a1e5aa65b13f8ca172009aa2ff3ba59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419979c48a5e37cd969f6fd6d0fead4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a419979c48a5e37cd969f6fd6d0fead4b">BoundTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a419979c48a5e37cd969f6fd6d0fead4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all bound type variables from type t.  <a href="#a419979c48a5e37cd969f6fd6d0fead4b">More...</a><br /></td></tr>
<tr class="separator:a419979c48a5e37cd969f6fd6d0fead4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67484a25663dfe2f87cbad53075abbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae67484a25663dfe2f87cbad53075abbf">AllTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ae67484a25663dfe2f87cbad53075abbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in expression expr.  <a href="#ae67484a25663dfe2f87cbad53075abbf">More...</a><br /></td></tr>
<tr class="separator:ae67484a25663dfe2f87cbad53075abbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24361b252cdb636192641e6801f2666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad24361b252cdb636192641e6801f2666">AllTypeVars</a> (const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;t, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ad24361b252cdb636192641e6801f2666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all type variables in type t.  <a href="#ad24361b252cdb636192641e6801f2666">More...</a><br /></td></tr>
<tr class="separator:ad24361b252cdb636192641e6801f2666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e35e7086b1f79ae55651500f94116b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab6e35e7086b1f79ae55651500f94116b">CollectDeviceInfo</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:ab6e35e7086b1f79ae55651500f94116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the device mapping information of each expression.  <a href="#ab6e35e7086b1f79ae55651500f94116b">More...</a><br /></td></tr>
<tr class="separator:ab6e35e7086b1f79ae55651500f94116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e17d61a10c7781b004559a5b7430047"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a4e17d61a10c7781b004559a5b7430047">CollectDeviceAnnotationOps</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr)</td></tr>
<tr class="memdesc:a4e17d61a10c7781b004559a5b7430047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the device anntation operators.  <a href="#a4e17d61a10c7781b004559a5b7430047">More...</a><br /></td></tr>
<tr class="separator:a4e17d61a10c7781b004559a5b7430047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a8cace40f8056fd6412f39c3eaa605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#aa3a8cace40f8056fd6412f39c3eaa605">UnmatchedCases</a> (const <a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> &amp;match, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:aa3a8cace40f8056fd6412f39c3eaa605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds cases that the given match expression does not catch, if any.  <a href="#aa3a8cace40f8056fd6412f39c3eaa605">More...</a><br /></td></tr>
<tr class="separator:aa3a8cace40f8056fd6412f39c3eaa605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ede3d80c546097084cf98b60e600b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a5ede3d80c546097084cf98b60e600b80">PostOrderVisit</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;node, std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fvisit)</td></tr>
<tr class="memdesc:a5ede3d80c546097084cf98b60e600b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once.  <a href="#a5ede3d80c546097084cf98b60e600b80">More...</a><br /></td></tr>
<tr class="separator:a5ede3d80c546097084cf98b60e600b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b651084b386991221bc32c020cbef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a62b651084b386991221bc32c020cbef5">DetectFeature</a> (const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;expr)</td></tr>
<tr class="memdesc:a62b651084b386991221bc32c020cbef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a62b651084b386991221bc32c020cbef5">More...</a><br /></td></tr>
<tr class="separator:a62b651084b386991221bc32c020cbef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81978c82e1130854e575ccabc152ad70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a81978c82e1130854e575ccabc152ad70">DetectFeature</a> (const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a81978c82e1130854e575ccabc152ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a81978c82e1130854e575ccabc152ad70">More...</a><br /></td></tr>
<tr class="separator:a81978c82e1130854e575ccabc152ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191d5425083368521d49cc49cef65aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a191d5425083368521d49cc49cef65aba">DetectFeature</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:a191d5425083368521d49cc49cef65aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the feature of the program.  <a href="#a191d5425083368521d49cc49cef65aba">More...</a><br /></td></tr>
<tr class="separator:a191d5425083368521d49cc49cef65aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02b5b16803fc28a9d920b105074a17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; ObjectRef(<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad02b5b16803fc28a9d920b105074a17d">CreateInterpreter</a> (<a class="el" href="classtvm_1_1IRModule.html">IRModule</a> mod, DLContext context, <a class="el" href="classtvm_1_1Target.html">Target</a> target)</td></tr>
<tr class="memdesc:ad02b5b16803fc28a9d920b105074a17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Interpreter function that can evaluate an expression and produce a value.  <a href="#ad02b5b16803fc28a9d920b105074a17d">More...</a><br /></td></tr>
<tr class="separator:ad02b5b16803fc28a9d920b105074a17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cfa0b6a4537989b886d47767526726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ad7cfa0b6a4537989b886d47767526726">Bind</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="classtvm_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;binds)</td></tr>
<tr class="memdesc:ad7cfa0b6a4537989b886d47767526726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the free variables to a Relay expression. This is a helper function usually called by other pass functions to help optimizations.  <a href="#ad7cfa0b6a4537989b886d47767526726">More...</a><br /></td></tr>
<tr class="separator:ad7cfa0b6a4537989b886d47767526726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18141658f627685d55704609111f57be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a18141658f627685d55704609111f57be">InferType</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod, const <a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a> &amp;var)</td></tr>
<tr class="memdesc:a18141658f627685d55704609111f57be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infer the type of a function as if it is mapped to var in the mod.  <a href="#a18141658f627685d55704609111f57be">More...</a><br /></td></tr>
<tr class="separator:a18141658f627685d55704609111f57be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36059b06a538598a8f46257c0cb9fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac36059b06a538598a8f46257c0cb9fe0">ForwardRewrite</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const std::string &amp;rewrite_map_attr_name, std::function&lt; ObjectRef(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:ac36059b06a538598a8f46257c0cb9fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass.  <a href="#ac36059b06a538598a8f46257c0cb9fe0">More...</a><br /></td></tr>
<tr class="separator:ac36059b06a538598a8f46257c0cb9fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b8ec762f81290872d611c40cc72458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ae6b8ec762f81290872d611c40cc72458">ForwardRewrite</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, const <a class="el" href="namespacetvm_1_1relay.html#aa04117f6f0a173924ff2f6d080c9265c">FForwardRewrite</a> &amp;rewrite_func, std::function&lt; ObjectRef(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt; fcontext=nullptr, std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt; fmulti_ref_trigger=nullptr)</td></tr>
<tr class="memdesc:ae6b8ec762f81290872d611c40cc72458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass.  <a href="#ae6b8ec762f81290872d611c40cc72458">More...</a><br /></td></tr>
<tr class="separator:ae6b8ec762f81290872d611c40cc72458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7917e50fbb560a15995e8a617d65d1ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a7917e50fbb560a15995e8a617d65d1ab">RewriteAnnotatedOps</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;expr, int fallback_device)</td></tr>
<tr class="memdesc:a7917e50fbb560a15995e8a617d65d1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the annotated program.  <a href="#a7917e50fbb560a15995e8a617d65d1ab">More...</a><br /></td></tr>
<tr class="separator:a7917e50fbb560a15995e8a617d65d1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9548d99857f7698f4fe64d056dcd46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ab9548d99857f7698f4fe64d056dcd46a">ToCPS</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f, const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;mod)</td></tr>
<tr class="memdesc:ab9548d99857f7698f4fe64d056dcd46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn an expression into continuation passing style(CPS).  <a href="#ab9548d99857f7698f4fe64d056dcd46a">More...</a><br /></td></tr>
<tr class="separator:ab9548d99857f7698f4fe64d056dcd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1677d450d58078811f52fd70d67db515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1677d450d58078811f52fd70d67db515">UnCPS</a> (const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;f)</td></tr>
<tr class="memdesc:a1677d450d58078811f52fd70d67db515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the continuation argument of a CPS function.  <a href="#a1677d450d58078811f52fd70d67db515">More...</a><br /></td></tr>
<tr class="separator:a1677d450d58078811f52fd70d67db515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#a1ecbcbe35c7abd82b9eabf94f6b797d2">DeDup</a> (const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;e)</td></tr>
<tr class="memdesc:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduplicate the bound variables and type variables in the expression.  <a href="#a1ecbcbe35c7abd82b9eabf94f6b797d2">More...</a><br /></td></tr>
<tr class="separator:a1ecbcbe35c7abd82b9eabf94f6b797d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac3a576d7d192ce78bafb169c9aa882d1"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetvm_1_1relay.html#ac3a576d7d192ce78bafb169c9aa882d1">feature_count</a> = 17</td></tr>
<tr class="separator:ac3a576d7d192ce78bafb169c9aa882d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Relay: a high level functional IR for TVM. </p>
<p>This namespace contains the abstract syntax tree, and other essential data structures for the Relay IR.</p>
<p>You can find more about Relay by reading the language reference. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa6b4b16b28a3cfd5052b2b4214a440d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aa6b4b16b28a3cfd5052b2b4214a440d9">tvm::relay::Any</a> = typedef <a class="el" href="classtvm_1_1tir_1_1AnyNode.html">tvm::tir::AnyNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acbaff2ae7feec23fea55e025a9cc1b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#acbaff2ae7feec23fea55e025a9cc1b76">tvm::relay::BaseFunc</a> = typedef <a class="el" href="classtvm_1_1BaseFunc.html">tvm::BaseFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4edf28d1226abc08d28bc2fd90ce7b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4edf28d1226abc08d28bc2fd90ce7b42">tvm::relay::BaseFuncNode</a> = typedef <a class="el" href="classtvm_1_1BaseFuncNode.html">tvm::BaseFuncNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec85bf097deda59bd22e88475c9165e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aec85bf097deda59bd22e88475c9165e9">tvm::relay::Constructor</a> = typedef <a class="el" href="classtvm_1_1Constructor.html">tvm::Constructor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b95f70a9b44cc1c96593201594d1345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6b95f70a9b44cc1c96593201594d1345">tvm::relay::ConstructorNode</a> = typedef <a class="el" href="classtvm_1_1ConstructorNode.html">tvm::ConstructorNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5b84e3790f89bb3fad5c7911eeb99531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">tvm::relay::Expr</a> = typedef <a class="el" href="classtvm_1_1RelayExpr.html">tvm::RelayExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a387f18e050d016c52ea6c4781e7cff6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a387f18e050d016c52ea6c4781e7cff6c">tvm::relay::ExprNode</a> = typedef <a class="el" href="classtvm_1_1RelayExprNode.html">tvm::RelayExprNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa04117f6f0a173924ff2f6d080c9265c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aa04117f6f0a173924ff2f6d080c9265c">tvm::relay::FForwardRewrite</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a>&amp; ref_call, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; new_args, const ObjectRef&amp; ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forward rewriting rule for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ref_call</td><td>The reference old call type to be rewritten. We can make use of the op and type information. </td></tr>
    <tr><td class="paramname">new_args</td><td>The new arguments (some of them could be <a class="el" href="classtvm_1_1relay_1_1TempExpr.html">TempExpr</a>). </td></tr>
    <tr><td class="paramname">ctx</td><td>Optional context information about ref_call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewriten result call, can also return nullptr, which indicate the rewriter should use the default fallback rule that realizes all its input and compose the call.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When we register the function, we can register a different signature with ctx to be a specific node type. </dd></dl>

</div>
</div>
<a class="anchor" id="a9abada45a4f21ae750c1caba923f1059"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a9abada45a4f21ae750c1caba923f1059">tvm::relay::FPrimalGradient</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;<a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&amp; orig_call, const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&amp; output_grad)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gradient for a specific op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_call</td><td>the original Expr. </td></tr>
    <tr><td class="paramname">output_grad</td><td>the gradient of the Expr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the gradient for each parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f7012819c4abe61de2d52e4bf94cfbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6f7012819c4abe61de2d52e4bf94cfbd">tvm::relay::FShapeFunc</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; inputs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a>&gt;&amp; out_ndims)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac36536541a0688d02f9172bf8a35813b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac36536541a0688d02f9172bf8a35813b">tvm::relay::FTVMAlterOpLayout</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; tinfos, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&amp; out_type)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternate the layout of operators or replace the operator with other expressions. This function will be invoked in AlterOpLayout pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">args</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">tinfos</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab140f1857d8471d98fe5371f8da68154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab140f1857d8471d98fe5371f8da68154">tvm::relay::FTVMAnnotateTarget</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; bool(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Annotates an expression to indicate if an op should be compiled using the given compiler/target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original expr. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments of the original expr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this op should be registered to invoke a specific compiler for codegen, otherwise, false. </dd></dl>

</div>
</div>
<a class="anchor" id="a63a0893a8379998657ddff39a3162188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a63a0893a8379998657ddff39a3162188">tvm::relay::FTVMCompute</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; inputs, const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a>&amp; out_type)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computation description interface. </p>
<dl class="section note"><dt>Note</dt><dd>This function have a special convention for functions with tuple input/output.</dd></dl>
<p>So far we restrict tuple support to the following case:</p><ul>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> which takes a single tuple as input.</li>
<li><a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> which outputs a single tuple.</li>
</ul>
<p>In both cases, the tuple is flattened as array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the primitive </td></tr>
    <tr><td class="paramname">inputs</td><td>The input tensors. </td></tr>
    <tr><td class="paramname">out_type</td><td>The output type information &amp; these are always placeholders. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output compute description of the operator. </dd></dl>

</div>
</div>
<a class="anchor" id="a526f835aaefdc86a8faa7da39802ebd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a526f835aaefdc86a8faa7da39802ebd5">tvm::relay::FTVMConvertOpLayout</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; tinfos, const std::string&amp; desired_layout)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the layout of operators or replace the operator with other expressions. This function will be invoked in ConvertLayout pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">inputs</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">tinfos</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
    <tr><td class="paramname">desired_layout</td><td>The desired layout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a40770ea2c292eec7b9ebe4d310c67fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a40770ea2c292eec7b9ebe4d310c67fb5">tvm::relay::FTVMLegalize</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>&gt;&amp; args, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a>&gt;&amp; arg_types)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legalizes an expression with another expression. This function will be invoked in Legalize pass. It is a target-dependent pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the original node. </td></tr>
    <tr><td class="paramname">args</td><td>The input symbols of the original node. </td></tr>
    <tr><td class="paramname">arg_types</td><td>An array of placeholders, use for getting the inferred shape and dtype of the inputs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new_expr The modified expression. </dd></dl>

</div>
</div>
<a class="anchor" id="af8f7c5928c79389da637c35df6c8557c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af8f7c5928c79389da637c35df6c8557c">tvm::relay::FTVMSchedule</a> = typedef <a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt; <a class="el" href="classtvm_1_1te_1_1Schedule.html">te::Schedule</a>(const <a class="el" href="classtvm_1_1Attrs.html">Attrs</a>&amp; attrs, const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1te_1_1Tensor.html">te::Tensor</a>&gt;&amp; outs, const <a class="el" href="classtvm_1_1Target.html">Target</a>&amp; target)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the computation schedule for op whose root is at current op. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>The attribute of the node. </td></tr>
    <tr><td class="paramname">outs</td><td>The output tensors. </td></tr>
    <tr><td class="paramname">target</td><td>The build target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>schedule The computation schedule. </dd></dl>

</div>
</div>
<a class="anchor" id="a2eb2ad4e7a83e0a28e2ad073d7bf9305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2eb2ad4e7a83e0a28e2ad073d7bf9305">tvm::relay::FTVMStrategy</a> = typedef <a class="el" href="classtvm_1_1GenericFunc.html">GenericFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the strategy of operators. This function is a generic function and can be re-defined for different targets. </p>
<p>The function signature of generic function is: <a class="el" href="classtvm_1_1relay_1_1OpStrategy.html" title="Operator strategy class. ">OpStrategy</a>(const <a class="el" href="classtvm_1_1Attrs.html" title="Managed reference to BaseAttrsNode. ">Attrs</a>&amp; attrs, const Array&lt;Tensor&gt;&amp; inputs, const <a class="el" href="classtvm_1_1Type.html" title="Managed reference to TypeNode. ">Type</a>&amp; out_type, const <a class="el" href="classtvm_1_1Target.html" title="Managed reference class to TargetNode. ">Target</a>&amp; target) </p>

</div>
</div>
<a class="anchor" id="aa475de90506d48a1bb04ef6d1bd99bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aa475de90506d48a1bb04ef6d1bd99bfb">tvm::relay::FuncType</a> = typedef <a class="el" href="classtvm_1_1FuncType.html">tvm::FuncType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab551714015417af28d5ca2b47722997e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab551714015417af28d5ca2b47722997e">tvm::relay::FuncTypeNode</a> = typedef <a class="el" href="classtvm_1_1FuncTypeNode.html">tvm::FuncTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2235e350f9cd1eac3aa0177034976043"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2235e350f9cd1eac3aa0177034976043">tvm::relay::GlobalTypeVar</a> = typedef <a class="el" href="classtvm_1_1GlobalTypeVar.html">tvm::GlobalTypeVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9a10e2305e3a50dd00e07b043b93b5e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a9a10e2305e3a50dd00e07b043b93b5e8">tvm::relay::GlobalTypeVarNode</a> = typedef <a class="el" href="classtvm_1_1GlobalTypeVarNode.html">tvm::GlobalTypeVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81ac7c3d0824529fddce7849c9c66289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">tvm::relay::GlobalVar</a> = typedef <a class="el" href="classtvm_1_1GlobalVar.html">tvm::GlobalVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe7144195dbbc914183189444ef6a347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afe7144195dbbc914183189444ef6a347">tvm::relay::GlobalVarNode</a> = typedef <a class="el" href="classtvm_1_1GlobalVarNode.html">tvm::GlobalVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34535a1f05224c26db569bc134de7647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a34535a1f05224c26db569bc134de7647">tvm::relay::IncompleteType</a> = typedef <a class="el" href="classtvm_1_1IncompleteType.html">tvm::IncompleteType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a517ebee34b82bdb80f74ffcdcf361940"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a517ebee34b82bdb80f74ffcdcf361940">tvm::relay::IncompleteTypeNode</a> = typedef <a class="el" href="classtvm_1_1IncompleteTypeNode.html">tvm::IncompleteTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae153a27d81399fd266b8d598227764c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">tvm::relay::IndexExpr</a> = typedef ::<a class="el" href="classtvm_1_1PrimExpr.html">tvm::PrimExpr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Symbolic expression for tensor shape. </p>

</div>
</div>
<a class="anchor" id="aa44e35e7d791c8dd53bb00ddb6411b38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">tvm::relay::Kind</a> = typedef <a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">TypeKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c46d15e80f1a9916b8e9c264a185c98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6c46d15e80f1a9916b8e9c264a185c98">tvm::relay::Op</a> = typedef <a class="el" href="classtvm_1_1Op.html">tvm::Op</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac9d4f2cf78a48659817a88d890e1d142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ac9d4f2cf78a48659817a88d890e1d142">tvm::relay::OpNode</a> = typedef <a class="el" href="classtvm_1_1OpNode.html">tvm::OpNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13fd39dbc2a639262858e9b72e8fb37f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a13fd39dbc2a639262858e9b72e8fb37f">tvm::relay::RelayRefType</a> = typedef <a class="el" href="classtvm_1_1RelayRefType.html">tvm::RelayRefType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae665239bd9119c8afb037d47781bf237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ae665239bd9119c8afb037d47781bf237">tvm::relay::RelayRefTypeNode</a> = typedef <a class="el" href="classtvm_1_1RelayRefTypeNode.html">tvm::RelayRefTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d64348ae2b75977e167109fb4af4409"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a4d64348ae2b75977e167109fb4af4409">tvm::relay::Shape</a> = typedef <a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#ae153a27d81399fd266b8d598227764c4">IndexExpr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A runtime representation of shape. </p>

</div>
</div>
<a class="anchor" id="a14eacafcb803b0757e48654bb1bac655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a14eacafcb803b0757e48654bb1bac655">tvm::relay::SourceName</a> = typedef <a class="el" href="classtvm_1_1SourceName.html">tvm::SourceName</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af40ca6124bc2e88f2323eeb79d326cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af40ca6124bc2e88f2323eeb79d326cc0">tvm::relay::Span</a> = typedef <a class="el" href="classtvm_1_1Span.html">tvm::Span</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d0fa6578e97d0d64b08865f94f04827"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a7d0fa6578e97d0d64b08865f94f04827">tvm::relay::SpanNode</a> = typedef <a class="el" href="classtvm_1_1SpanNode.html">tvm::SpanNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52c13723bba53f4953dfd10c34d480f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a52c13723bba53f4953dfd10c34d480f8">tvm::relay::TensorType</a> = typedef <a class="el" href="classtvm_1_1TensorType.html">tvm::TensorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acfeff91bc774a278a2e9f6103a04387d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#acfeff91bc774a278a2e9f6103a04387d">tvm::relay::TensorTypeNode</a> = typedef <a class="el" href="classtvm_1_1TensorTypeNode.html">tvm::TensorTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4c835287dfc5ec074ea8431bcebbb17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab4c835287dfc5ec074ea8431bcebbb17">tvm::relay::TNonComputational</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator as non-computational. </p>

</div>
</div>
<a class="anchor" id="afb8a8d4dd43830d4ce7d566abcd1c450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afb8a8d4dd43830d4ce7d566abcd1c450">tvm::relay::TOpIsStateful</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether operator is stateful or contain internal state. </p>
<p>All the primitive ops we registered so far are pure. This attribute is left for potential future compatible reasons. We can always work around the stateful ops by adding an additional handle argument and return it. </p>

</div>
</div>
<a class="anchor" id="a5dab2ddae20ac7564a81ab3a0a9aba76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a5dab2ddae20ac7564a81ab3a0a9aba76">tvm::relay::TOpPattern</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the operator pattern </p>

</div>
</div>
<a class="anchor" id="a75252d8d7e8d18b796074ffe4cc9f3ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a75252d8d7e8d18b796074ffe4cc9f3ff">tvm::relay::TShapeDataDependant</a> = typedef bool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the operator whether output shape is data dependant. </p>

</div>
</div>
<a class="anchor" id="ace9102638dffea6747ae9fa9be9f00f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ace9102638dffea6747ae9fa9be9f00f2">tvm::relay::TupleType</a> = typedef <a class="el" href="classtvm_1_1TupleType.html">tvm::TupleType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a916609c894ac1000b66f9582f338d965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a916609c894ac1000b66f9582f338d965">tvm::relay::TupleTypeNode</a> = typedef <a class="el" href="classtvm_1_1TupleTypeNode.html">tvm::TupleTypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a661d95f170bca230773914caeef3fe52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">tvm::relay::Type</a> = typedef <a class="el" href="classtvm_1_1Type.html">tvm::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab406a37acee11226e3e2e119beee439e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab406a37acee11226e3e2e119beee439e">tvm::relay::TypeCall</a> = typedef <a class="el" href="classtvm_1_1TypeCall.html">tvm::TypeCall</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4dccabc877b8fd7db47cb73fb93883e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af4dccabc877b8fd7db47cb73fb93883e">tvm::relay::TypeCallNode</a> = typedef <a class="el" href="classtvm_1_1TypeCallNode.html">tvm::TypeCallNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a64e2e93fe04716efd8334ab4e39c92ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a64e2e93fe04716efd8334ab4e39c92ce">tvm::relay::TypeConstraint</a> = typedef <a class="el" href="classtvm_1_1TypeConstraint.html">tvm::TypeConstraint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a565e027589acded20ca38df22be098dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a565e027589acded20ca38df22be098dc">tvm::relay::TypeConstraintNode</a> = typedef <a class="el" href="classtvm_1_1TypeConstraintNode.html">tvm::TypeConstraintNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e725a1cb4c83346e261eac7dc7292a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a6e725a1cb4c83346e261eac7dc7292a8">tvm::relay::TypeData</a> = typedef <a class="el" href="classtvm_1_1TypeData.html">tvm::TypeData</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b8c0d5920eaca88569907e92df6066f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a2b8c0d5920eaca88569907e92df6066f">tvm::relay::TypeDataNode</a> = typedef <a class="el" href="classtvm_1_1TypeDataNode.html">tvm::TypeDataNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af6995f0c848d0d5cc4124a38f43aaf12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af6995f0c848d0d5cc4124a38f43aaf12">tvm::relay::TypeNode</a> = typedef <a class="el" href="classtvm_1_1TypeNode.html">tvm::TypeNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adab0d56fd993df71df3068dea0cd5456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#adab0d56fd993df71df3068dea0cd5456">tvm::relay::TypeRelation</a> = typedef <a class="el" href="classtvm_1_1TypeRelation.html">tvm::TypeRelation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af253112249297a6cfb2a9b94cde0f235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#af253112249297a6cfb2a9b94cde0f235">tvm::relay::TypeRelationFn</a> = typedef <a class="el" href="namespacetvm.html#a72dcba4493adfcd8908663898ece3514">tvm::TypeRelationFn</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a89d812eaf13520b04e89a9414c51748c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a89d812eaf13520b04e89a9414c51748c">tvm::relay::TypeRelationNode</a> = typedef <a class="el" href="classtvm_1_1TypeRelationNode.html">tvm::TypeRelationNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa9be9990c2006832cbfc02ebb35e527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#afa9be9990c2006832cbfc02ebb35e527">tvm::relay::TypeReporter</a> = typedef <a class="el" href="classtvm_1_1TypeReporter.html">tvm::TypeReporter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa3b5700ea20db399f539cec1abcb12b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#aaa3b5700ea20db399f539cec1abcb12b">tvm::relay::TypeReporterNode</a> = typedef <a class="el" href="classtvm_1_1TypeReporterNode.html">tvm::TypeReporterNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63321eb51080f3f57dd7563a3ca0bfa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">tvm::relay::TypeVar</a> = typedef <a class="el" href="classtvm_1_1TypeVar.html">tvm::TypeVar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2cbe31b81ebd71ea8028a8404a7c9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetvm_1_1relay.html#ab2cbe31b81ebd71ea8028a8404a7c9f3">tvm::relay::TypeVarNode</a> = typedef <a class="el" href="classtvm_1_1TypeVarNode.html">tvm::TypeVarNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="adab76fedc831b249d1c80d69c4a620a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#adab76fedc831b249d1c80d69c4a620a3">tvm::relay::AnyCodegenStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The codegeneration strategy for dynamic dimensions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="adab76fedc831b249d1c80d69c4a620a3a1a3550732b0caf3981198af2c1373542"></a>kVariableDimensions&#160;</td><td class="fielddoc">
<p>The default strategy of using completely variable dimensions. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a926750aeda977340aa82bceac863fc9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#a926750aeda977340aa82bceac863fc9e">tvm::relay::Feature</a> : int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different kinds of relay feature a program might use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea42a71e7934e2efe344713b17c426eecd"></a>fVar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eae9b152650b0ebe6dbc1b42e0f84d567f"></a>fGlobalVar&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea29eacc09610a7fd43026682238aae25f"></a>fConstant&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eaa2fe12a180d97822c440e169dc287e66"></a>fTuple&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea4d2cb67f2e197880e0971286f2ffb498"></a>fTupleGetItem&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea3b367d0501427ea782137266a2fb77fa"></a>fFunction&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eaca21bd0f67c01c6f7b82a1596cdfdf8b"></a>fOp&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea5f3d3030d2ed56e5a47329e29f12ef02"></a>fCall&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea07ce432e7b4b4c044af03e4dbd210ba4"></a>fLet&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea4e6b686fb15d50c4aef2316bef53a781"></a>fIf&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea46daa677c87c05e68258acea3579443d"></a>fRefCreate&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea7c9e5e3d738c26c3ed34099f44f66251"></a>fRefRead&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea4737da29588504f7f31cf4fb52925d63"></a>fRefWrite&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eaff71be930d862c312a5ae263e71167a2"></a>fConstructor&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9ea53a8eba57c4a3abd37b4c96fb98bf61b"></a>fMatch&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eac6392a0ecc7df38dbfa282a54d3718d1"></a>fGraph&#160;</td><td class="fielddoc">
<p>Whether any non-atom fragment of the program is shared, making the program a graph. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a926750aeda977340aa82bceac863fc9eaff508e399703958af46f99ee8eb7d1a5"></a>fLetRec&#160;</td><td class="fielddoc">
<p>Whether there is local fixpoint in the program. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetvm_1_1relay.html#ab5f4d382bf1bee69c3e484ea6c837578">tvm::relay::OpPatternKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>operator pattern used in graph fusion </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a8c63d345994ce14eb197df6ad22de3aa"></a>kElemWise&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a3c016b63ef8869468ab565c862713245"></a>kBroadcast&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a7f703d1ae163ba4e6bef88357a232e00"></a>kInjective&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578ad282ac05b650598c3bfb559dc62a0738"></a>kCommReduce&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578ab9b265465c486425c2f60cd4057e2ef4"></a>kOutEWiseFusable&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578ae5610688419b90595a0701fe007a2ebb"></a>kTuple&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab5f4d382bf1bee69c3e484ea6c837578a3cb3cec00829ebd525feba875f2d6ac1"></a>kOpaque&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae67484a25663dfe2f87cbad53075abbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ad24361b252cdb636192641e6801f2666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::AllTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all type variables in type t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b1e94cf8d97514fe4a9493a0dec1559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::AllVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all variables from expression expr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of all vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cfa0b6a4537989b886d47767526726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Map.html">tvm::Map</a>&lt; <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>, <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>binds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the free variables to a Relay expression. This is a helper function usually called by other pass functions to help optimizations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The input expression. </td></tr>
    <tr><td class="paramname">binds</td><td>The variable to expression map that will be used to help the binding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5aa65b13f8ca172009aa2ff3ba59d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from expression expr. </p>
<p>Bound variables are all type variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a419979c48a5e37cd969f6fd6d0fead4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::BoundTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound type variables from type t. </p>
<p>Bound variables are all type variables that are declared in the type. They only have meaning inside that type, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bcc32688b446d3574932554f6b8c2df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from expression expr. </p>
<p>Bound variables are all variables that are declared in the expr. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aedcb2b290b4f80292eb34afefc41f0ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::BoundVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all bound variables from pattern pat. </p>
<p>Bound variables are all variables that got bound by the pat. They only have meaning inside that expr, and can only be used in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pat</td><td>the <a class="el" href="classtvm_1_1relay_1_1Pattern.html" title="Pattern is the base type for an ADT match pattern in Relay. ">Pattern</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of bound vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e17d61a10c7781b004559a5b7430047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a>&gt; tvm::relay::CollectDeviceAnnotationOps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the device anntation operators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The annotated expression to device type mapping for annotation ops. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e35e7086b1f79ae55651500f94116b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Map.html">Map</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>, <a class="el" href="classtvm_1_1Integer.html">Integer</a>&gt; tvm::relay::CollectDeviceInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the device mapping information of each expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The device mapping. </dd></dl>

</div>
</div>
<a class="anchor" id="abdade48285a63efffe743e73e41d3b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::ConstantCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether an expression is constant. </p>
<p><a class="el" href="classtvm_1_1relay_1_1If.html">If</a> the inputs of an expression are all constant, it means the expression itself is constant also.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the expression is constant. </dd></dl>

</div>
</div>
<a class="anchor" id="ad02b5b16803fc28a9d920b105074a17d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1runtime_1_1TypedPackedFunc.html">runtime::TypedPackedFunc</a>&lt;ObjectRef(<a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>)&gt; tvm::relay::CreateInterpreter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1IRModule.html">IRModule</a>&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DLContext&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Target.html">Target</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Interpreter function that can evaluate an expression and produce a value. </p>
<p>The resulting value can be passed to Python, making it easy to use for testing and debugging.</p>
<p>The interpreter interprets the program fragments not supported by the TVM runtime, although the interpreter is naively implemented it uses TVM operators for evaluating all operators.</p>
<p>Our intent is that this will never be the most efficient implementation of Relay's semantics, but a readable and clear one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The function module. </td></tr>
    <tr><td class="paramname">context</td><td>The primary context that the interepreter runs on. </td></tr>
    <tr><td class="paramname">target</td><td>Compiler target flag to compile the functions on the context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A function that takes in an expression and returns a value. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ecbcbe35c7abd82b9eabf94f6b797d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::DeDup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduplicate the bound variables and type variables in the expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the deduplicated expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a62b651084b386991221bc32c020cbef5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1RelayExpr.html">RelayExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a81978c82e1130854e575ccabc152ad70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>The module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a191d5425083368521d49cc49cef65aba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1FeatureSet.html">FeatureSet</a> tvm::relay::DetectFeature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the feature of the program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">mod</td><td>The module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="classtvm_1_1relay_1_1FeatureSet.html" title="A finite set of Feature. ">FeatureSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac36059b06a538598a8f46257c0cb9fe0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rewrite_map_attr_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ObjectRef(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_map_attr_name</td><td>The <a class="el" href="classtvm_1_1Op.html" title="Managed reference class to OpNode. ">Op</a>'s attr name which corresponds to the rewrite rule function. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an Expr consumed by multiple callers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ae6b8ec762f81290872d611c40cc72458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::ForwardRewrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#aa04117f6f0a173924ff2f6d080c9265c">FForwardRewrite</a> &amp;&#160;</td>
          <td class="paramname"><em>rewrite_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; ObjectRef(const <a class="el" href="classtvm_1_1relay_1_1Call.html">Call</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fcontext</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a>(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fmulti_ref_trigger</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply rewrite rules to rewrite the expr in post DFS order. This function is used as a helper function to rewrtie an expression in a pass. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">rewrite_func</td><td>The rewrite func that will apply to all operators. </td></tr>
    <tr><td class="paramname">fcontext</td><td>Additional callback to provide context argument for each call node. </td></tr>
    <tr><td class="paramname">fmulti_ref_trigger</td><td>Transformation function to be called when an Expr consumed by multiple callers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rewritten expression. </dd></dl>

</div>
</div>
<a class="anchor" id="acc529cca9623ac81c8aa6e106cdb5850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from expression expr. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order visited by expr. </dd></dl>

</div>
</div>
<a class="anchor" id="a446e2b12f3e907336313004c3e0a0c86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="namespacetvm_1_1relay.html#a63321eb51080f3f57dd7563a3ca0bfa6">TypeVar</a>&gt; tvm::relay::FreeTypeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free TypeVars from type t. </p>
<p>Free type parameters are type parameters that are not bound by a function type in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>the type. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free type vars, in the PostDFS order visited by type. </dd></dl>

</div>
</div>
<a class="anchor" id="af2c5771c67f06c0af32c7b4b4269e73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a>&gt; tvm::relay::FreeVars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get free type parameters from expression expr. </p>
<p>Free variables are variables that are not bound by a let or a function parameter in the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>List of free vars, in the PostDFS order in the expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a18141658f627685d55704609111f57be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::InferType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a81ac7c3d0824529fddce7849c9c66289">GlobalVar</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Infer the type of a function as if it is mapped to var in the mod. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
    <tr><td class="paramname">mod</td><td>The module used for referencing global functions. </td></tr>
    <tr><td class="paramname">var</td><td>The global variable corresponding to the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A type checked <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a> with its checked_type field populated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function mutates mod and is not thread-safe. </dd></dl>

</div>
</div>
<a class="anchor" id="af73e45f453515df6f9c0bbbf189719d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm.html#acd267f8d7f55da6ac681239831963279">Kind</a> tvm::relay::KindCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a661d95f170bca230773914caeef3fe52">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that types are well kinded by applying "kinding rules". </p>
<p>This pass ensures we do not do things that violate the design of the type system when writing down types.</p>
<p>For example tensors are not allowed to contain functions in Relay.</p>
<p>We check this by ensuring the <code>dtype</code> field of a Tensor always contains a data type such as <code>int</code>, <code>float</code>, <code>uint</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type to check. </td></tr>
    <tr><td class="paramname">mod</td><td>The global module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The kind of the passed type. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ede3d80c546097084cf98b60e600b80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tvm::relay::PostOrderVisit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>fvisit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>recursively visit the ir in post DFS order node, apply fvisit Each node is guaranteed to be visited only once. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The ir to be visited. </td></tr>
    <tr><td class="paramname">fvisit</td><td>The visitor function to be applied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7917e50fbb560a15995e8a617d65d1ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> tvm::relay::RewriteAnnotatedOps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback_device</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the annotated program. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>The expression. </td></tr>
    <tr><td class="paramname">fallback_device</td><td>The fallback device which is the default device for operators without annotation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated program. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9548d99857f7698f4fe64d056dcd46a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::ToCPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn an expression into continuation passing style(CPS). </p>
<p>CPS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.</p>
<p>Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).</p>
<p>Similarly, all other compute will be wrapped and call the continuation as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function. </td></tr>
    <tr><td class="paramname">mod</td><td>the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1677d450d58078811f52fd70d67db515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> tvm::relay::UnCPS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the continuation argument of a CPS function. </p>
<p>Note that this only transform the type back into un-CPS form when there is no higher order input/output.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>the function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted <a class="el" href="classtvm_1_1relay_1_1Function.html" title="Managed reference to FunctionNode. ">Function</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3a8cace40f8056fd6412f39c3eaa605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt;<a class="el" href="classtvm_1_1relay_1_1Pattern.html">Pattern</a>&gt; tvm::relay::UnmatchedCases </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1relay_1_1Match.html">Match</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1IRModule.html">IRModule</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds cases that the given match expression does not catch, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>the match expression to test</td></tr>
    <tr><td class="paramname">mod</td><td>The module used for accessing global type var definitions, can be None.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a list of cases (as patterns) that are not handled by the match expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a59dde25d981d5b506115dd4dba7f67b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tvm::relay::WellFormed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetvm_1_1relay.html#a5b84e3790f89bb3fad5c7911eeb99531">Expr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that each <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> is only bound once. </p>
<p>For example, the expression <code>let x = 1 in let x = 2 in 3</code> bound x twice.</p>
<p><code>let f = (\x -&gt; x) in let g = (\x -&gt; x + 1) in f(g(2))</code> also bound x twice, although x is not shadowed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>the expression to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff all <a class="el" href="classtvm_1_1relay_1_1Var.html">Var</a> in expr is bound at most once. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac3a576d7d192ce78bafb169c9aa882d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t tvm::relay::feature_count = 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
