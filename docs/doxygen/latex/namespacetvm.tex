\hypertarget{namespacetvm}{}\section{tvm Namespace Reference}
\label{namespacetvm}\index{tvm@{tvm}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacetvm_1_1arith}{arith}
\begin{DoxyCompactList}\small\item\em namespace of arithmetic analysis. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1attr}{attr}
\begin{DoxyCompactList}\small\item\em Generic attribute names that can be attached to any function. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1codegen}{codegen}
\begin{DoxyCompactList}\small\item\em namespace for target translation and codegen. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1detail}{detail}
\item 
 \hyperlink{namespacetvm_1_1relay}{relay}
\begin{DoxyCompactList}\small\item\em Relay\+: a high level functional IR for T\+VM. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1runtime}{runtime}
\item 
 \hyperlink{namespacetvm_1_1target}{target}
\begin{DoxyCompactList}\small\item\em This namespace provides functions to construct \hyperlink{classtvm_1_1Target}{Target} instances. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1te}{te}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} expression language D\+SL. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1tir}{tir}
\item 
 \hyperlink{namespacetvm_1_1transform}{transform}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classtvm_1_1Array}{Array}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Array}{Array} container of Node\+Ref in D\+SL graph. \hyperlink{classtvm_1_1Array}{Array} implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1ArrayNode}{Array\+Node}
\begin{DoxyCompactList}\small\item\em array node content in array \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1AttrError}{Attr\+Error}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Error}{Error} thrown during attribute checking. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrFieldInfo}{Attr\+Field\+Info}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1AttrFieldInfo}{Attr\+Field\+Info}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrFieldInfoNode}{Attr\+Field\+Info\+Node}
\begin{DoxyCompactList}\small\item\em Information about attribute fields in string representations. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Attrs}{Attrs}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1BaseAttrsNode}{Base\+Attrs\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrsEqual}{Attrs\+Equal}
\begin{DoxyCompactList}\small\item\em Content-\/aware Equality comparator for attrs. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrsHash}{Attrs\+Hash}
\begin{DoxyCompactList}\small\item\em Content-\/aware hash function. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrsNode}{Attrs\+Node}
\begin{DoxyCompactList}\small\item\em The base class of the all the Use \char`\"{}curiously recurring template pattern\char`\"{}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1AttrVisitor}{Attr\+Visitor}
\begin{DoxyCompactList}\small\item\em Visitor class for to get the attributesof a A\+S\+T/\+IR node. The content is going to be called for each field. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseAttrsNode}{Base\+Attrs\+Node}
\begin{DoxyCompactList}\small\item\em Base class of all attribute class. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseExpr}{Base\+Expr}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1BaseExprNode}{Base\+Expr\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseExprNode}{Base\+Expr\+Node}
\begin{DoxyCompactList}\small\item\em Base type of all the expressions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseFunc}{Base\+Func}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1BaseFuncNode}{Base\+Func\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseFuncNode}{Base\+Func\+Node}
\begin{DoxyCompactList}\small\item\em Base node of all functions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseTensorType}{Base\+Tensor\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1BaseTensorTypeNode}{Base\+Tensor\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseTensorTypeNode}{Base\+Tensor\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Base of all Tensor types This container can hold \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} or Generic\+Tensor\+Type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseValueEqual}{Base\+Value\+Equal}
\begin{DoxyCompactList}\small\item\em Equality definition of base value class. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BaseValueHash}{Base\+Value\+Hash}
\begin{DoxyCompactList}\small\item\em Hash definition of base value classes. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BuildConfig}{Build\+Config}
\begin{DoxyCompactList}\small\item\em Build configuration for compilations. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1BuildConfigNode}{Build\+Config\+Node}
\begin{DoxyCompactList}\small\item\em Container for build configuration options. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Constructor}{Constructor}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1ConstructorNode}{Constructor\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1ConstructorNode}{Constructor\+Node}
\begin{DoxyCompactList}\small\item\em A\+DT constructor. Constructors compare by pointer equality. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1DictAttrs}{Dict\+Attrs}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1DictAttrsNode}{Dict\+Attrs\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1DictAttrsNode}{Dict\+Attrs\+Node}
\begin{DoxyCompactList}\small\item\em Specialized attribute type that is backed by a map. The \hyperlink{classtvm_1_1DictAttrsNode}{Dict\+Attrs\+Node} implements the \hyperlink{classtvm_1_1Attrs}{Attrs} behavior, its fields are directly accessible via object.\+field\+\_\+name like other normal nodes. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1EnvFunc}{Env\+Func}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1EnvFuncNode}{Env\+Func\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1EnvFuncNode}{Env\+Func\+Node}
\begin{DoxyCompactList}\small\item\em A serializable function backed by T\+VM\textquotesingle{}s global environment. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Error}{Error}
\begin{DoxyCompactList}\small\item\em Custom \hyperlink{classtvm_1_1Error}{Error} class to be thrown during compilation. \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1ErrorBuilder}{Error\+Builder}
\begin{DoxyCompactList}\small\item\em A wrapper around std\+::stringstream to build error. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1ErrorReporter}{Error\+Reporter}
\begin{DoxyCompactList}\small\item\em An abstraction around how errors are stored and reported. Designed to be opaque to users, so we can support a robust and simpler error reporting mode, as well as a more complex mode. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1FloatImm}{Float\+Imm}
\begin{DoxyCompactList}\small\item\em Managed reference class to \hyperlink{classtvm_1_1FloatImmNode}{Float\+Imm\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1FloatImmNode}{Float\+Imm\+Node}
\begin{DoxyCompactList}\small\item\em Constant floating point literals in the program. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1FuncType}{Func\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1FuncTypeNode}{Func\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1FuncTypeNode}{Func\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Function type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GenericFunc}{Generic\+Func}
\begin{DoxyCompactList}\small\item\em Generic function that can be specialized on a per-\/target basis. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GenericFuncNode}{Generic\+Func\+Node}
\begin{DoxyCompactList}\small\item\em Represents a generic function that can be specialized on a per-\/target basis. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GenericOpMap}{Generic\+Op\+Map}
\begin{DoxyCompactList}\small\item\em Generic map to store additional information of \hyperlink{classtvm_1_1Op}{Op}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GlobalTypeVar}{Global\+Type\+Var}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1GlobalTypeVarNode}{Global\+Type\+Var\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GlobalTypeVarNode}{Global\+Type\+Var\+Node}
\begin{DoxyCompactList}\small\item\em A global type variable that is used for defining new types or type aliases. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GlobalVar}{Global\+Var}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1GlobalVarNode}{Global\+Var\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1GlobalVarNode}{Global\+Var\+Node}
\begin{DoxyCompactList}\small\item\em Global variable that lives in the top-\/level module. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IncompleteType}{Incomplete\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1IncompleteTypeNode}{Incomplete\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IncompleteTypeNode}{Incomplete\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Intermediate values that is used to indicate incomplete type during type inference. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Integer}{Integer}
\begin{DoxyCompactList}\small\item\em Container of constant int that adds more constructors. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IntImm}{Int\+Imm}
\begin{DoxyCompactList}\small\item\em Managed reference class to \hyperlink{classtvm_1_1IntImmNode}{Int\+Imm\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IntImmNode}{Int\+Imm\+Node}
\begin{DoxyCompactList}\small\item\em Constant integer literals in the program. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}
\begin{DoxyCompactList}\small\item\em Managed reference class to \hyperlink{classtvm_1_1IRModuleNode}{I\+R\+Module\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IRModuleNode}{I\+R\+Module\+Node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1IRModule}{I\+R\+Module} that holds functions and type definitions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1IterAdapter}{Iter\+Adapter}
\begin{DoxyCompactList}\small\item\em iterator adapter that adapts T\+Iter to return another type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Map}{Map}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Map}{Map} container of Node\+Ref-\/$>$Node\+Ref in D\+SL graph. \hyperlink{classtvm_1_1Map}{Map} implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places. \end{DoxyCompactList}\item 
class {\bfseries Map$<$ std\+::string, V, T1, T2 $>$}
\item 
class \hyperlink{classtvm_1_1MapNode}{Map\+Node}
\begin{DoxyCompactList}\small\item\em map node content \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1MemoryInfo}{Memory\+Info}
\begin{DoxyCompactList}\small\item\em Defines memory info. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1MemoryInfoNode}{Memory\+Info\+Node}
\begin{DoxyCompactList}\small\item\em Memory information of special memory region. Use \hyperlink{classtvm_1_1MemoryInfo}{Memory\+Info} as its container type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1NodeFunctor}{Node\+Functor}
\begin{DoxyCompactList}\small\item\em A dynamically dispatched functor on the type of the first argument. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1NodeFunctor_3_01R_07const_01ObjectRef_01_6n_00_01Args_8_8_8_08_4}{Node\+Functor$<$ R(const Object\+Ref \&n, Args...)$>$}
\item 
class \hyperlink{classtvm_1_1Op}{Op}
\begin{DoxyCompactList}\small\item\em Managed reference class to \hyperlink{classtvm_1_1OpNode}{Op\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1OpMap}{Op\+Map}
\begin{DoxyCompactList}\small\item\em Map$<$\+Op,\+Value\+Type$>$ used to store meta-\/information about \hyperlink{classtvm_1_1Op}{Op}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1OpNode}{Op\+Node}
\begin{DoxyCompactList}\small\item\em Primitive Op(builtin intrinsics) \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1OpRegistry}{Op\+Registry}
\begin{DoxyCompactList}\small\item\em Helper structure to register operators. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1PointerType}{Pointer\+Type}
\item 
class \hyperlink{classtvm_1_1PointerTypeNode}{Pointer\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Low-\/level raw pointer type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr}
\begin{DoxyCompactList}\small\item\em Reference to \hyperlink{classtvm_1_1PrimExprNode}{Prim\+Expr\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1PrimExprNode}{Prim\+Expr\+Node}
\begin{DoxyCompactList}\small\item\em Base node of all primitive expressions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1PrimType}{Prim\+Type}
\item 
class \hyperlink{classtvm_1_1PrimTypeNode}{Prim\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Primitive data types used in the low-\/level IR. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Range}{Range}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Range}{Range} constainer. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1RangeNode}{Range\+Node}
\begin{DoxyCompactList}\small\item\em range over one dimension \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1ReflectionVTable}{Reflection\+V\+Table}
\begin{DoxyCompactList}\small\item\em Virtual function table to support I\+R/\+A\+ST node reflection. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1RelayExpr}{Relay\+Expr}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1RelayExprNode}{Relay\+Expr\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1RelayExprNode}{Relay\+Expr\+Node}
\begin{DoxyCompactList}\small\item\em Base node of all non-\/primitive expressions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1RelayRefType}{Relay\+Ref\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1RelayRefTypeNode}{Relay\+Ref\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1RelayRefTypeNode}{Relay\+Ref\+Type\+Node}
\begin{DoxyCompactList}\small\item\em Reference \hyperlink{classtvm_1_1Type}{Type} High-\/level Relay IR. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1ReprPrinter}{Repr\+Printer}
\begin{DoxyCompactList}\small\item\em A printer class to print the A\+S\+T/\+IR nodes. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1SEqualReducer}{S\+Equal\+Reducer}
\begin{DoxyCompactList}\small\item\em A Reducer class to reduce the structural equality result of two objects. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1SHashReducer}{S\+Hash\+Reducer}
\begin{DoxyCompactList}\small\item\em A Reducer class to reduce the structural hash value. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1SourceName}{Source\+Name}
\begin{DoxyCompactList}\small\item\em The source name of a file span. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1SourceNameNode}{Source\+Name\+Node}
\begin{DoxyCompactList}\small\item\em The name of a source fragment. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Span}{Span}
\item 
class \hyperlink{classtvm_1_1SpanNode}{Span\+Node}
\begin{DoxyCompactList}\small\item\em Stores locations in frontend source that generated a node. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1StrMapNode}{Str\+Map\+Node}
\begin{DoxyCompactList}\small\item\em specialized map node with string as key \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1StructuralEqual}{Structural\+Equal}
\begin{DoxyCompactList}\small\item\em Content-\/aware structural equality comparator for objects. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1StructuralHash}{Structural\+Hash}
\begin{DoxyCompactList}\small\item\em Content-\/aware structural hasing. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Target}{Target}
\begin{DoxyCompactList}\small\item\em Managed reference class to \hyperlink{classtvm_1_1TargetNode}{Target\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TargetNode}{Target\+Node}
\begin{DoxyCompactList}\small\item\em Compilation target. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TensorType}{Tensor\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TensorTypeNode}{Tensor\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TensorTypeNode}{Tensor\+Type\+Node}
\begin{DoxyCompactList}\small\item\em This is the most commonly used type in relay. \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} have a fixed dimension, data type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TupleType}{Tuple\+Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TupleTypeNode}{Tuple\+Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TupleTypeNode}{Tuple\+Type\+Node}
\begin{DoxyCompactList}\small\item\em The type of tuple values. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1Type}{Type}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TypeNode}{Type\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeCall}{Type\+Call}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TypeCallNode}{Type\+Call\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeCallNode}{Type\+Call\+Node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Type}{Type} function application. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeConstraint}{Type\+Constraint}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TypeConstraintNode}{Type\+Constraint\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeConstraintNode}{Type\+Constraint\+Node}
\begin{DoxyCompactList}\small\item\em Potential Constraints in a function. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeData}{Type\+Data}
\begin{DoxyCompactList}\small\item\em Stores all data for an Algebraic Data \hyperlink{classtvm_1_1Type}{Type} (A\+DT). \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeDataNode}{Type\+Data\+Node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1TypeData}{Type\+Data} container node. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypedEnvFunc}{Typed\+Env\+Func}
\begin{DoxyCompactList}\small\item\em Please refer to \hyperlink{classtvm_1_1TypedEnvFunc_3_01R_07Args_8_8_8_08_4_TypedEnvFuncAnchor}{Typed\+Env\+Func$<$R(Args..)$>$}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypedEnvFunc_3_01R_07Args_8_8_8_08_4}{Typed\+Env\+Func$<$ R(\+Args...)$>$}
\begin{DoxyCompactList}\small\item\em A typed version of \hyperlink{classtvm_1_1EnvFunc}{Env\+Func}. It is backed by a Global\+Func\+Node internally. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeFunctor}{Type\+Functor}
\item 
class \hyperlink{classtvm_1_1TypeFunctor_3_01R_07const_01Type_01_6n_00_01Args_8_8_8_08_4}{Type\+Functor$<$ R(const Type \&n, Args...)$>$}
\item 
class \hyperlink{classtvm_1_1TypeMutator}{Type\+Mutator}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1TypeMutator}{Type\+Mutator} that mutates expressions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeNode}{Type\+Node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Type}{Type} is the base type of all types. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeRelation}{Type\+Relation}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TypeRelationNode}{Type\+Relation\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeRelationNode}{Type\+Relation\+Node}
\begin{DoxyCompactList}\small\item\em User defined type relation, it is an input-\/output relation on types. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeReporter}{Type\+Reporter}
\begin{DoxyCompactList}\small\item\em Container class of \hyperlink{classtvm_1_1TypeReporter}{Type\+Reporter}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeReporterNode}{Type\+Reporter\+Node}
\begin{DoxyCompactList}\small\item\em reporter that reports back to the type resolution information. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeVar}{Type\+Var}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1TypeVarNode}{Type\+Var\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeVarNode}{Type\+Var\+Node}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Type}{Type} parameter in functions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1TypeVisitor}{Type\+Visitor}
\begin{DoxyCompactList}\small\item\em A type visitor that recursively visit types. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1With}{With}
\begin{DoxyCompactList}\small\item\em R\+A\+II wrapper function to enter and exit a context object similar to python\textquotesingle{}s with syntax. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacetvm_a72dcba4493adfcd8908663898ece3514}{Type\+Relation\+Fn} = \hyperlink{classtvm_1_1TypedEnvFunc}{Typed\+Env\+Func}$<$ bool(const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1Type}{Type} $>$ \&args, int num\+\_\+inputs, const \hyperlink{classtvm_1_1Attrs}{Attrs} \&attrs, const \hyperlink{classtvm_1_1TypeReporter}{Type\+Reporter} \&reporter)$>$
\begin{DoxyCompactList}\small\item\em User defined type constraint function. \end{DoxyCompactList}\item 
using \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} = \hyperlink{classtvm_1_1runtime_1_1DataType}{runtime\+::\+Data\+Type}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0}{Calling\+Conv} \+: int \{ \hyperlink{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0a6867faeaa475fda467e48267db2bb8a8}{Calling\+Conv\+::k\+Default} = 0, 
\hyperlink{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc}{Calling\+Conv\+::k\+Device\+Kernel\+Launch} = 2, 
\hyperlink{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0ae7694043e4825265becdb58550b4e443}{Calling\+Conv\+::k\+C\+Packed\+Func} = 3
 \}\begin{DoxyCompactList}\small\item\em Possible Calling conventions. \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279}{Type\+Kind} \+: int \{ \\*
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279a46f081c7ea2307c83d3cdfd42e1583f7}{k\+Type} = 0, 
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279ad7d44c9f700aa20bcc455c6d9ee4ff18}{k\+Shape\+Var} = 1, 
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279a86ff765603911600b938cea9a65e984b}{k\+Base\+Type} = 2, 
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279a9496d61badd19161ce92108f06903606}{k\+Constraint} = 4, 
\\*
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279ab6bf8f8bef54e7ebbc8d9f804e94421e}{k\+Adt\+Handle} = 5, 
\hyperlink{namespacetvm_acd267f8d7f55da6ac681239831963279a8b02b25ecd96ab7f18ace5aa18f832ba}{k\+Type\+Data} = 6
 \}\begin{DoxyCompactList}\small\item\em Possible kinds of Type\+Vars. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$ \hyperlink{namespacetvm_a9284f30c0e1daf1649838578fed1baa1}{lower} (\hyperlink{classtvm_1_1te_1_1Schedule}{te\+::\+Schedule} sch, const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1te_1_1Tensor}{te\+::\+Tensor} $>$ \&args, const std\+::string \&name, const std\+::unordered\+\_\+map$<$ \hyperlink{classtvm_1_1te_1_1Tensor}{te\+::\+Tensor}, \hyperlink{classtvm_1_1tir_1_1Buffer}{tir\+::\+Buffer} $>$ \&binds, const \hyperlink{classtvm_1_1BuildConfig}{Build\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Build a Lowered\+Func given a schedule, args and binds. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$ $>$ \hyperlink{namespacetvm_a66b6a4702f9c98e4e4c6c385da231903}{split\+\_\+dev\+\_\+host\+\_\+funcs} (const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$ \&funcs, const \hyperlink{classtvm_1_1Target}{Target} \&target, const \hyperlink{classtvm_1_1Target}{Target} \&target\+\_\+host, const \hyperlink{classtvm_1_1BuildConfig}{Build\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Split host/device function and running necessary pass before build. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1Module}{runtime\+::\+Module} \hyperlink{namespacetvm_a50a9a7e42c754dc31caf6d74e4423ddc}{build} (const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$ \&funcs, const \hyperlink{classtvm_1_1Target}{Target} \&target, const \hyperlink{classtvm_1_1Target}{Target} \&target\+\_\+host, const \hyperlink{classtvm_1_1BuildConfig}{Build\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Build a device and host module for a specific target from an array of lowered functions. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1Module}{runtime\+::\+Module} \hyperlink{namespacetvm_ab60e7a2ecb2573f5380a476d8c5aca6d}{build} (const \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1Target}{Target}, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$$>$ \&input, const \hyperlink{classtvm_1_1Target}{Target} \&target\+\_\+host, const \hyperlink{classtvm_1_1BuildConfig}{Build\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Build a device and host module for a specific target from a map contains target to a list of lowered functions pairs. This function is used for heterogeneous build. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1Module}{runtime\+::\+Module} \hyperlink{namespacetvm_a879a810167b7f65cbfe7975da151c06d}{build} (const \hyperlink{classtvm_1_1Map}{Map}$<$ std\+::string, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tir\+::\+Lowered\+Func} $>$$>$ \&input, const \hyperlink{classtvm_1_1Target}{Target} \&target\+\_\+host, const \hyperlink{classtvm_1_1BuildConfig}{Build\+Config} \&config)
\begin{DoxyCompactList}\small\item\em Build a device and host module for a specific target from a map contains target to a list of lowered functions pairs. This function is used for heterogeneous build. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T\+Object\+Ref $>$ }\\T\+Object\+Ref \hyperlink{namespacetvm_ab6c242e8ac09beb463fba306948b7f15}{Null\+Value} ()
\begin{DoxyCompactList}\small\item\em Create a Node\+Ref type that represents null. \end{DoxyCompactList}\item 
{\footnotesize template$<$$>$ }\\\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \hyperlink{namespacetvm_a28c693333c2b15702b1a9a57dec0fbf5}{Null\+Value$<$ Data\+Type $>$} ()
\item 
{\footnotesize template$<$typename T\+Func , typename  = typename std\+::enable\+\_\+if$<$           std\+::is\+\_\+base\+\_\+of$<$\+Base\+Func, T\+Func$>$\+::value$>$\+::type$>$ }\\T\+Func \hyperlink{namespacetvm_ae3262464aa53a0c8b1b6078dfadab049}{With\+Attr} (T\+Func func, const std\+::string \&attr\+\_\+key, Object\+Ref attr\+\_\+value)
\begin{DoxyCompactList}\small\item\em Create a new function that copies func, but overrides the attribute value key with the value. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacetvm_a52d7b2faa9f73a02d3e983b80af1f2a5}{Pretty\+Print} (const Object\+Ref \&node)
\begin{DoxyCompactList}\small\item\em Pretty print a node for debug purposes. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacetvm_a535496e3535d7128d7fe4a52a397f538}{As\+Text} (const Object\+Ref \&node, bool show\+\_\+meta\+\_\+data=true, \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc}{runtime\+::\+Typed\+Packed\+Func}$<$ std\+::string(Object\+Ref)$>$ annotate=nullptr)
\begin{DoxyCompactList}\small\item\em Render the node as a string in the text format. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_a8259e23409eda017c6bde908e050b670}{Is\+Primitive\+Op} (const \hyperlink{classtvm_1_1RelayExpr}{Relay\+Expr} \&expr)
\begin{DoxyCompactList}\small\item\em Check that an expression is a \char`\"{}primitive operator\char`\"{}. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Type}{Type} \hyperlink{namespacetvm_a27df956aaa2e5e25005e0f9dc1638a08}{Void\+Type} ()
\item 
bool \hyperlink{namespacetvm_a196edb73fc9f13d965b8de1c9287a2db}{Is\+Void\+Type} (const \hyperlink{classtvm_1_1Type}{Type} \&type)
\begin{DoxyCompactList}\small\item\em Check whether the tyep represents void. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Type}{Type} \hyperlink{namespacetvm_a7f0738778e1a4f1725bea3d6c801aab4}{Bind} (const \hyperlink{classtvm_1_1Type}{Type} \&type, const \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1TypeVar}{Type\+Var}, \hyperlink{classtvm_1_1Type}{Type} $>$ \&args\+\_\+map)
\begin{DoxyCompactList}\small\item\em Bind free type variables in the type. \end{DoxyCompactList}\item 
void \hyperlink{namespacetvm_a23b1dfa894bd954c9a1eea4ab8199764}{Dump} (const Object\+Ref \&node)
\begin{DoxyCompactList}\small\item\em Dump the node to stderr, used for debug purposes. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacetvm_aad98af358976b1598430090b7db92823}{Save\+J\+S\+ON} (const \hyperlink{classtvm_1_1runtime_1_1ObjectRef}{runtime\+::\+Object\+Ref} \&node)
\begin{DoxyCompactList}\small\item\em save the node as well as all the node it depends on as json. This can be used to serialize any T\+VM object \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1ObjectRef}{runtime\+::\+Object\+Ref} \hyperlink{namespacetvm_afa0a9bdf3997ef4fad45b19fb1a655cd}{Load\+J\+S\+ON} (std\+::string json\+\_\+str)
\begin{DoxyCompactList}\small\item\em Internal implementation of Load\+J\+S\+ON Load tvm Node object from json and return a shared\+\_\+ptr of Node. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1MemoryInfo}{Memory\+Info} \hyperlink{namespacetvm_a6e525343df6fbd739a45b291cb0dfb4f}{Get\+Memory\+Info} (const std\+::string \&scope)
\begin{DoxyCompactList}\small\item\em get memory info given scope \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Type}{Type} \hyperlink{namespacetvm_a48fb9755f38ffcfcd03592a47ffbbd14}{Get\+Type} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&expr)
\begin{DoxyCompactList}\small\item\em Get the type of the expression under the unified type system. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1DataType}{runtime\+::\+Data\+Type} \hyperlink{namespacetvm_a0447e9aa45f6cab707f6dc9f9281b3f5}{Get\+Runtime\+Data\+Type} (const \hyperlink{classtvm_1_1Type}{Type} \&type)
\begin{DoxyCompactList}\small\item\em Get the implied Data\+Type for storing values with type during runtime. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a2741c5a48b50bf369026a1bbdf02017f}{max\+\_\+value} (const \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \&dtype)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9c126a8dde0d4079713969ca574f172e}{min\+\_\+value} (const \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \&dtype)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9bf1977e7bc6f0424f4e87d77d0008ed}{infinity} (const \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \&dtype)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aa058caeda9deceda3d6ffeda347be442}{cast} (const \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \&t, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} value)
\begin{DoxyCompactList}\small\item\em cast value to type. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a2acd72f0adb3d9ae5eede7497b32c139}{reinterpret} (const \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} \&t, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} value)
\begin{DoxyCompactList}\small\item\em perform reinterpret cast value to type. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af246f441d4ac21b110185b77240b2dcc}{operator+} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em add operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abde487c0197942c4ebb1b47277b89dac}{operator-\/} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em subtraction operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abc417454badf61b154d6a8d87cd8f171}{operator-\/} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a)
\begin{DoxyCompactList}\small\item\em negation. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a5c5034de2993b9130b7bd9d593a11bb5}{operator$\ast$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em multiplication operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a18256ba1213ce5ff3cf8037a314354b7}{operator/} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em division operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af682776c3609284f1bc3ea436e21a67a}{operator$<$$<$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em left shift operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1ce1eb32fc9d76ebe5a6b8d185024d41}{operator$>$$>$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em right shift operator \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad93d00f7b080dc3f905f5c34c170a041}{operator$>$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em greater \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a5530417da455bd46f5dc55f27d69bcdf}{operator$>$=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em greater\+\_\+equal \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1f98476c3a413f6cdfc7b7e490f3221b}{operator$<$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em less \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a598f8139c469abc4066dbdd0a0a0845d}{operator$<$=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em less\+\_\+equal \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a2ea3b45c96d3980227e418f7158ce5c3}{operator==} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em equal \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a03983cf66713724c138f9697bb8e0e97}{operator!=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em not\+\_\+equal \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_afc83b50366be0862a6c8f88c9a4e62d5}{operator\&\&} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em and \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac3bf2ef3556c995846dddcd84e5db8a6}{operator$\vert$$\vert$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em or \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ab354bf1270121abea71fade83f13b0b0}{operator!} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a)
\begin{DoxyCompactList}\small\item\em not \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a40fcc9952e1ff01a76f3b75dbd368fc1}{div} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute division in C semantics. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7bcbff6b886a4fa59b65e7cf05714b49}{truncdiv} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute trunc(a / b) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ae3fd62ca6008d6f20e4845426ec47aa6}{truncmod} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute the remainder of truncdiv \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a8203d70a5ebf3532370264b000d0d276}{indexdiv} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute floor(a / b) where a and b are non-\/negative. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a857781b7243b2f90018f7fe6baf9c30e}{indexmod} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute the remainder floor(a / b) where a and b are non-\/negative. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a25cb3bf64427a16a93529d0a5c40b6de}{floordiv} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute floor(a / b) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a74b2e0fb912a82f974e2b652f7de8d34}{floormod} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em compute the remainder of floordiv \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ab49bad0808ba033343e72ba37b39af2e}{max} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em take maximum of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9da780393e228969f77aa7550520a582}{min} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em take minimum of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a92e2cae35b1e48f130b76f42c6ee3106}{operator\&} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em take bitwise and of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a236d9aae385e6697874f75e4c8a69f8d}{operator$\vert$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em take bitwise or of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abd7d1b3232218b25e2e0cf6ef699a65f}{operator$^\wedge$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\begin{DoxyCompactList}\small\item\em take bitwise xor of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a354b9954ff25dd819a51d856fdd38827}{operator$\sim$} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} a)
\begin{DoxyCompactList}\small\item\em take bitwise negation of two values \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad400409d87dc337f8b5fe13e18d363f9}{if\+\_\+then\+\_\+else} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} cond, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} true\+\_\+value, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} false\+\_\+value)
\begin{DoxyCompactList}\small\item\em Conditional expression. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad6ee4c2d41e7e226d1995112cd12e3f1}{likely} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} cond)
\begin{DoxyCompactList}\small\item\em Mark condition as likely. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a880f0cd15891153430b669f0b4eca2fe}{pow} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} y)
\begin{DoxyCompactList}\small\item\em Calculate power(x, y) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a84d274191adb24d2acb39064c1fbec52}{abs} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculate absolute value of x. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a8f98d60fdc4526b07c8858d6b0b8d1ee}{isnan} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Check if x is NaN. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6a48a2b96c995f412390db3ea3b38bd9}{isfinite} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Check if x is finite. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a30e728d87aa70f76d7f4a09316c9746d}{isinf} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Check if x is infinite. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a5cea5eb708bfbfa08e285092e5afdc33}{sum} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em sum of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a78bab31ca3c44dbd5e6801e1e223d475}{all} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em logical And of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a48629d1a87dfe0b51260defe79c82a60}{any} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em logical Or of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a80f15d31bf89ba7654442d9ca9a91a18}{max} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em max of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a2028eb350061871512cf50fed0e6fa6b}{min} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em max of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_afd8718fe1f413ab2850cdbb66adfbecc}{prod} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} source, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1IterVar}{tir\+::\+Iter\+Var} $>$ axis)
\begin{DoxyCompactList}\small\item\em product of of source expression over axis \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a45896c89bce01ea68b5a8f3ea37f3079}{floor} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculate floor(x) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a530307f2fad9f6d196c441309af777b9}{ceil} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculate ceil(x) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a660170263d6864b1caa60728619971be}{round} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculate round(x) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a8472b5c842e840063564d4280428ce23}{nearbyint} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculates std\+::nearbyint(x) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ae17d5a4cdf12b4da457d4929030592cf}{trunc} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\begin{DoxyCompactList}\small\item\em Calculate trunc(x) \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1b6f1345a0ac2506132b15ec4cbf3599}{Large\+U\+Int\+Imm} (\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} dtype, int64\+\_\+t low, int64\+\_\+t high)
\begin{DoxyCompactList}\small\item\em Construct a large uint constant by its low 32 bits and high 32bits. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aa21f5c2f67c944561ae4a260a2ed14d2}{exp} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a21e3a5d7327cf37c6a682525665a0a28}{exp2} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac760569fe43a52f3f8997461b2ef438a}{exp10} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a78ebcdb32def4b349b37423884a6417a}{erf} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad8a570f4008eb8869504544d7a1cd8ce}{tanh} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1bf7732939d615e08d0d991e2f271c42}{sigmoid} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a0a4fcbbd8d9db345d4d7e8bb0a76671a}{sqrt} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ae77bc5dc1c2f4bcafcac8ad698b089a5}{rsqrt} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aed9236feb2ab21523cb2dcb0257fe8da}{log} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aae5edd83ffa099868f2d58a9def0b2b4}{log2} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a04657a6242778fd95b77df057385e398}{log10} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a04551919927933a4265c87809d889577}{popcount} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aaabcd438dbdc57aa6866fde3edaf2d83}{tan} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a66fb538aa75f90efb6f5c948920f8f95}{cos} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a581c9279a40694ab7a5defa179bcad67}{cosh} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aeb9b0d266628cfa6c4d254c4e719249a}{sin} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a8c17ac9dc5cd2be44dd2c3ef23e0e4c9}{sinh} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a0a4e38b4b6d9f7396f2eafa680f98bd8}{atan} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} x)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a96061840d12f84eeecc8fae11e245242}{operator+=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a164d454c519fecaa5611c86b65469acc}{operator-\/=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9233d7b436ae52ac070442ba19caed18}{operator$\ast$=} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a2725c044e8067299c3dccbd453ce614f}{operator+} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac86d7f61b9f0899a08685145f6bb5051}{operator+} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad728a6c2c3d21242a4df808aadb722eb}{operator+} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a50bfde26f015ed64e1c0341dd65d3fad}{operator+} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac225d9ad74343d0e97a5e943e7f6a7d1}{operator+} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a679ff94dec26779d8769231abb229647}{operator-\/} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aef861fe5325bc0b415a905a24c42f10a}{operator-\/} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a4f40ad3340a853d58664bc864dc10d47}{operator-\/} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af7c46ff33a2727f48b10d7d563f4a746}{operator-\/} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a028ba217f99b6cb1592a6a56b2bc9ee5}{operator-\/} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af70bb4a982810d795dbd17ce73c6b124}{operator$\ast$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ace5dbde3bde1ba48d14a3f9064a45aee}{operator$\ast$} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aca621e1d2df8562819bc021c1410b741}{operator$\ast$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6823188ec16be854223bbffe349c975d}{operator$\ast$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1815d8b152819885a5733554f374a9ca}{operator$\ast$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7134c7ce44fbedab5990f19428ceb5c4}{max} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abc6aa5a903c9a71faece2f5dfbc8218c}{max} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7bd1dc5f6d10420562d216bb3660270d}{max} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac0dc60ecafe41384d28baf92f6943680}{max} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aa26bf5f7b12b17f87400c63c63663c60}{max} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1a8d2a9b2868033477024d551f779d61}{min} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6ebe9e5428f481f683f89f59440dde2a}{min} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a3b4b479c377151a9d64dc67d1105421e}{min} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7fe0dbe362aac3d4f9c204eeba803d8e}{min} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a468d959980234ccc84c319810d787219}{min} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ae2d70142d842bb07be508adb2d4f7447}{div} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a85c28d529a26976f3d5f67511f2aef8b}{div} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a8a958cb2612b58e6464f5421bb8ab74b}{div} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac9f587b864957447e3d0c64ac9159633}{div} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1180d1f0ef1d427bad98a89c66d84c0f}{div} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9cea8f3789d8f3dc78acae43e9a6aad6}{operator$>$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6d0ad14c882c11311836138a2c164cf3}{operator$>$} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6aeb6ed068c5de8ab908ff234337aeeb}{operator$>$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_acc92dcd3d81981e983ddf05347bc9371}{operator$>$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7e2181bca182f90533ec35537714d09d}{operator$>$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a35961a6074b72fae0dfc48ee395e0673}{operator$>$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7a94a354cd62137652e09fa887a96100}{operator$>$=} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af7dee311b945dfc5a821a119c1db9ad1}{operator$>$=} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac194836fc11a8ba34e44738da17fd116}{operator$>$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aae1dcfef78728c5490d3c107b4abac5a}{operator$>$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a4c5092e248ab7daa5de5c22717670d8e}{operator$<$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abc5d3aba4f3f15098d5ac2fb0c3dfd39}{operator$<$} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a46877235265ab97544ec2e561f521b0f}{operator$<$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aa672271dbd566a0e7b9e4c87664bccb4}{operator$<$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a0854363590c38f5479b1da5e70c4f002}{operator$<$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a06d97bd5ee2c12e8547be0cc42f6b300}{operator$<$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, float b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a872f50bd7175eccf440865311aa75232}{operator$<$=} (float a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad5dbec0c48b8644c5c6e9d773ddc106b}{operator$<$=} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af94a56db543e741a23bbf2f51c49091a}{operator$<$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6eea8276bcc178425bc14f3d878970ff}{operator$<$=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, double b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_af9a4e8a59397e5778c38356129c06110}{indexdiv} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9d88aa90642838c6bc41c4cbead148fd}{indexdiv} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ac4d2991113bb8e0b634e4c83183eb5c1}{indexmod} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abd2345bc3cd37ab4f762c0f971042daa}{indexmod} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ae50afd0565c00f594ee188bab7323372}{truncdiv} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a5b5bb91649c681b0ea799689be9647bf}{truncdiv} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a4c2633a4e92785dd73834bfff282699c}{truncmod} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad6c6dbf136b1086695780fd695df350b}{truncmod} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a83e68dc71a05711a9c94123af2a3fdbf}{floordiv} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad3b659d13dd33e7a027b9d082315a776}{floordiv} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6993f628929a88cf563461c9dcafb2ae}{floormod} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a08a5224a973dc893665ab543c116854d}{floormod} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_abccc3d3e96ee608022b148ffa05034eb}{operator$>$$>$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a550c2a251b2a6fd2a72172fe3db75d40}{operator$>$$>$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a9d8412e5f401f59f5ca85ed556d70810}{operator$<$$<$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad0449d28f23318cc5163159a58c80ba3}{operator$<$$<$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a4ff6afc90cabb820cf2f2fda6daefd92}{operator\&} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_acb2697d9f746f0377975893eb080288e}{operator\&} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a7c7fc3c45e6f6b52b2a1064deabd0797}{operator$\vert$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ad5ba71021b167b0a6ca2138b2c8bbace}{operator$\vert$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a82dc2fe21e7a64be5a1b11c2a8775d31}{operator$^\wedge$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, int b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a6f638564e5e4d1023096523800f2579e}{operator$^\wedge$} (int a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_aca62d5095a23e0e24db1d6611d118eab}{operator\&\&} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, bool b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a3fc66f0c6cd2135365cd24917d931abe}{operator\&\&} (bool a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a873bb60c71f37cbb743e21797a53ba06}{operator$\vert$$\vert$} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, bool b)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a1a3f9ad4d0e25eee9c0b3a9c83114bc0}{operator$\vert$$\vert$} (bool a, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&b)
\item 
{\footnotesize template$<$typename TA $>$ }\\void \hyperlink{namespacetvm_a31e7a3e4a160a1d048e3ba741966f1a8}{Div\+Ambiguity\+Error} (const TA \&a)
\begin{DoxyCompactList}\small\item\em Helper function to raise a compiler error about division ambiguity. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TB $>$ }\\\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a136427374941fbf8e50f53b1cab39e38}{operator/} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, const TB \&b)
\item 
{\footnotesize template$<$typename TB $>$ }\\\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_a51dc569142bf8ce8ea55f73029d3807d}{operator/=} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, const TB \&b)
\item 
{\footnotesize template$<$typename TB $>$ }\\\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_ab25738e50b37cd07b2d171ca74ba9321}{operator\%} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a, const TB \&b)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{tvm@{tvm}!Data\+Type@{Data\+Type}}
\index{Data\+Type@{Data\+Type}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Data\+Type}{DataType}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::\+Data\+Type} = typedef {\bf runtime\+::\+Data\+Type}}\hypertarget{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{}\label{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}
\index{tvm@{tvm}!Type\+Relation\+Fn@{Type\+Relation\+Fn}}
\index{Type\+Relation\+Fn@{Type\+Relation\+Fn}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Type\+Relation\+Fn}{TypeRelationFn}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::\+Type\+Relation\+Fn} = typedef {\bf Typed\+Env\+Func}$<$bool(const {\bf Array}$<${\bf Type}$>$\& args, int num\+\_\+inputs, const {\bf Attrs}\& attrs, const {\bf Type\+Reporter}\& reporter)$>$}\hypertarget{namespacetvm_a72dcba4493adfcd8908663898ece3514}{}\label{namespacetvm_a72dcba4493adfcd8908663898ece3514}


User defined type constraint function. 

If the input type information can be used to fully decide the Incomplete\+Types, then the function should call reporter.\+Assign to report the new types, and return true. Otherwise, the function should return false.


\begin{DoxyParams}{Parameters}
{\em args} & The arguments to the relation. The types are stored in the form of \mbox{[}input\+\_\+type\+\_\+0, input\+\_\+type\+\_\+1, ... input\+\_\+type\+\_\+n, output\+\_\+type\+\_\+0, output\+\_\+type\+\_\+1, ... output\+\_\+type\+\_\+m\mbox{]}\\
\hline
{\em num\+\_\+inputs} & Number of input types in the args. \\
\hline
{\em attrs} & The additional attributes of the operator. \\
\hline
{\em reporter} & The reporter to report solution to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if This relation cannot be resolved. true if this relation has been resolved. 
\end{DoxyReturn}


\subsection{Enumeration Type Documentation}
\index{tvm@{tvm}!Calling\+Conv@{Calling\+Conv}}
\index{Calling\+Conv@{Calling\+Conv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Calling\+Conv}{CallingConv}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::\+Calling\+Conv} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\hypertarget{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0}{}\label{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0}


Possible Calling conventions. 

N\+O\+TE\+: The calling convention also implies the way we implement the function during lowering. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Default@{k\+Default}!tvm@{tvm}}\index{tvm@{tvm}!k\+Default@{k\+Default}}\item[{\em 
k\+Default\hypertarget{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0a6867faeaa475fda467e48267db2bb8a8}{}\label{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0a6867faeaa475fda467e48267db2bb8a8}
}]Default calling convetion. 
\begin{DoxyItemize}
\item Uses the native calling convention of the target.
\item Implementation\+: specified by the native target. 
\end{DoxyItemize}\index{k\+Device\+Kernel\+Launch@{k\+Device\+Kernel\+Launch}!tvm@{tvm}}\index{tvm@{tvm}!k\+Device\+Kernel\+Launch@{k\+Device\+Kernel\+Launch}}\item[{\em 
k\+Device\+Kernel\+Launch\hypertarget{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc}{}\label{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc}
}]Device kernel launch. 
\begin{DoxyItemize}
\item Call by Packed\+Func calling convention.
\item Implementation\+: defined by device runtime(e.\+g. runtime/cuda) 
\end{DoxyItemize}\index{k\+C\+Packed\+Func@{k\+C\+Packed\+Func}!tvm@{tvm}}\index{tvm@{tvm}!k\+C\+Packed\+Func@{k\+C\+Packed\+Func}}\item[{\em 
k\+C\+Packed\+Func\hypertarget{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0ae7694043e4825265becdb58550b4e443}{}\label{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0ae7694043e4825265becdb58550b4e443}
}]Packed\+Func that exposes a C\+Packed\+Func signature. 
\begin{DoxyItemize}
\item Calling by Packed\+Func calling convention.
\item Implementation\+: Expose a function with the C\+Packed\+Func signature. 
\end{DoxyItemize}\end{description}
\end{Desc}
\index{tvm@{tvm}!Type\+Kind@{Type\+Kind}}
\index{Type\+Kind@{Type\+Kind}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Type\+Kind}{TypeKind}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::\+Type\+Kind} \+: int}\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279}


Possible kinds of Type\+Vars. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Type@{k\+Type}!tvm@{tvm}}\index{tvm@{tvm}!k\+Type@{k\+Type}}\item[{\em 
k\+Type\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279a46f081c7ea2307c83d3cdfd42e1583f7}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279a46f081c7ea2307c83d3cdfd42e1583f7}
}]\index{k\+Shape\+Var@{k\+Shape\+Var}!tvm@{tvm}}\index{tvm@{tvm}!k\+Shape\+Var@{k\+Shape\+Var}}\item[{\em 
k\+Shape\+Var\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279ad7d44c9f700aa20bcc455c6d9ee4ff18}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279ad7d44c9f700aa20bcc455c6d9ee4ff18}
}]Template variable in shape expression. \index{k\+Base\+Type@{k\+Base\+Type}!tvm@{tvm}}\index{tvm@{tvm}!k\+Base\+Type@{k\+Base\+Type}}\item[{\em 
k\+Base\+Type\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279a86ff765603911600b938cea9a65e984b}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279a86ff765603911600b938cea9a65e984b}
}]\index{k\+Constraint@{k\+Constraint}!tvm@{tvm}}\index{tvm@{tvm}!k\+Constraint@{k\+Constraint}}\item[{\em 
k\+Constraint\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279a9496d61badd19161ce92108f06903606}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279a9496d61badd19161ce92108f06903606}
}]\index{k\+Adt\+Handle@{k\+Adt\+Handle}!tvm@{tvm}}\index{tvm@{tvm}!k\+Adt\+Handle@{k\+Adt\+Handle}}\item[{\em 
k\+Adt\+Handle\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279ab6bf8f8bef54e7ebbc8d9f804e94421e}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279ab6bf8f8bef54e7ebbc8d9f804e94421e}
}]\index{k\+Type\+Data@{k\+Type\+Data}!tvm@{tvm}}\index{tvm@{tvm}!k\+Type\+Data@{k\+Type\+Data}}\item[{\em 
k\+Type\+Data\hypertarget{namespacetvm_acd267f8d7f55da6ac681239831963279a8b02b25ecd96ab7f18ace5aa18f832ba}{}\label{namespacetvm_acd267f8d7f55da6ac681239831963279a8b02b25ecd96ab7f18ace5aa18f832ba}
}]\end{description}
\end{Desc}


\subsection{Function Documentation}
\index{tvm@{tvm}!abs@{abs}}
\index{abs@{abs}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{abs(\+Prim\+Expr x)}{abs(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::abs (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a84d274191adb24d2acb39064c1fbec52}{}\label{namespacetvm_a84d274191adb24d2acb39064c1fbec52}


Calculate absolute value of x. 


\begin{DoxyParams}{Parameters}
{\em x} & The input data\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The aboslute value of input data x 
\end{DoxyReturn}
\index{tvm@{tvm}!all@{all}}
\index{all@{all}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{all(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{all(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::all (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a78bab31ca3c44dbd5e6801e1e223d475}{}\label{namespacetvm_a78bab31ca3c44dbd5e6801e1e223d475}


logical And of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!any@{any}}
\index{any@{any}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{any(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{any(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::any (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a48629d1a87dfe0b51260defe79c82a60}{}\label{namespacetvm_a48629d1a87dfe0b51260defe79c82a60}


logical Or of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!As\+Text@{As\+Text}}
\index{As\+Text@{As\+Text}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{As\+Text(const Object\+Ref \&node, bool show\+\_\+meta\+\_\+data=true, runtime\+::\+Typed\+Packed\+Func$<$ std\+::string(\+Object\+Ref)$>$ annotate=nullptr)}{AsText(const ObjectRef &node, bool show_meta_data=true, runtime::TypedPackedFunc< std::string(ObjectRef)> annotate=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string tvm\+::\+As\+Text (
\begin{DoxyParamCaption}
\item[{const Object\+Ref \&}]{node, }
\item[{bool}]{show\+\_\+meta\+\_\+data = {\ttfamily true}, }
\item[{{\bf runtime\+::\+Typed\+Packed\+Func}$<$ std\+::string(Object\+Ref)$>$}]{annotate = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a535496e3535d7128d7fe4a52a397f538}{}\label{namespacetvm_a535496e3535d7128d7fe4a52a397f538}


Render the node as a string in the text format. 


\begin{DoxyParams}{Parameters}
{\em node} & The node to be rendered. \\
\hline
{\em show\+\_\+meta\+\_\+data} & Whether to print meta data section. \\
\hline
{\em annotate} & An optional callback function for attaching additional comment block to an expr.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
We support a limited set of IR nodes that are part of relay IR and
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{namespacetvm_a52d7b2faa9f73a02d3e983b80af1f2a5}{Pretty\+Print}. 
\end{DoxySeeAlso}
\begin{DoxyReturn}{Returns}
The text representation. 
\end{DoxyReturn}
\index{tvm@{tvm}!atan@{atan}}
\index{atan@{atan}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{atan(\+Prim\+Expr x)}{atan(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::atan (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a0a4e38b4b6d9f7396f2eafa680f98bd8}{}\label{namespacetvm_a0a4e38b4b6d9f7396f2eafa680f98bd8}
\index{tvm@{tvm}!Bind@{Bind}}
\index{Bind@{Bind}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Bind(const Type \&type, const Map$<$ Type\+Var, Type $>$ \&args\+\_\+map)}{Bind(const Type &type, const Map< TypeVar, Type > &args_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type} tvm\+::\+Bind (
\begin{DoxyParamCaption}
\item[{const {\bf Type} \&}]{type, }
\item[{const {\bf Map}$<$ {\bf Type\+Var}, {\bf Type} $>$ \&}]{args\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a7f0738778e1a4f1725bea3d6c801aab4}{}\label{namespacetvm_a7f0738778e1a4f1725bea3d6c801aab4}


Bind free type variables in the type. 


\begin{DoxyParams}{Parameters}
{\em type} & The type to be updated. \\
\hline
{\em args\+\_\+map} & The binding map. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!build@{build}}
\index{build@{build}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{build(const Array$<$ tir\+::\+Lowered\+Func $>$ \&funcs, const Target \&target, const Target \&target\+\_\+host, const Build\+Config \&config)}{build(const Array< tir::LoweredFunc > &funcs, const Target &target, const Target &target_host, const BuildConfig &config)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf runtime\+::\+Module} tvm\+::build (
\begin{DoxyParamCaption}
\item[{const {\bf Array}$<$ {\bf tir\+::\+Lowered\+Func} $>$ \&}]{funcs, }
\item[{const {\bf Target} \&}]{target, }
\item[{const {\bf Target} \&}]{target\+\_\+host, }
\item[{const {\bf Build\+Config} \&}]{config}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a50a9a7e42c754dc31caf6d74e4423ddc}{}\label{namespacetvm_a50a9a7e42c754dc31caf6d74e4423ddc}


Build a device and host module for a specific target from an array of lowered functions. 


\begin{DoxyParams}{Parameters}
{\em funcs} & The functions to be built. \\
\hline
{\em target} & The target device to build for. \\
\hline
{\em target\+\_\+host} & The target for building host code. To use the default, pass Target() \\
\hline
{\em config} & The build configuration. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The built module. 
\end{DoxyReturn}
\index{tvm@{tvm}!build@{build}}
\index{build@{build}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{build(const Map$<$ Target, Array$<$ tir\+::\+Lowered\+Func $>$$>$ \&input, const Target \&target\+\_\+host, const Build\+Config \&config)}{build(const Map< Target, Array< tir::LoweredFunc >> &input, const Target &target_host, const BuildConfig &config)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf runtime\+::\+Module} tvm\+::build (
\begin{DoxyParamCaption}
\item[{const {\bf Map}$<$ {\bf Target}, {\bf Array}$<$ {\bf tir\+::\+Lowered\+Func} $>$$>$ \&}]{input, }
\item[{const {\bf Target} \&}]{target\+\_\+host, }
\item[{const {\bf Build\+Config} \&}]{config}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ab60e7a2ecb2573f5380a476d8c5aca6d}{}\label{namespacetvm_ab60e7a2ecb2573f5380a476d8c5aca6d}


Build a device and host module for a specific target from a map contains target to a list of lowered functions pairs. This function is used for heterogeneous build. 


\begin{DoxyParams}{Parameters}
{\em input} & The map contains target to a list of lowered functions pairs. \\
\hline
{\em target\+\_\+host} & The target for building host code. To use the default, pass Target(). \\
\hline
{\em config} & The build configuration. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The built module that contains code for different processors. 
\end{DoxyReturn}
\index{tvm@{tvm}!build@{build}}
\index{build@{build}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{build(const Map$<$ std\+::string, Array$<$ tir\+::\+Lowered\+Func $>$$>$ \&input, const Target \&target\+\_\+host, const Build\+Config \&config)}{build(const Map< std::string, Array< tir::LoweredFunc >> &input, const Target &target_host, const BuildConfig &config)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf runtime\+::\+Module} tvm\+::build (
\begin{DoxyParamCaption}
\item[{const {\bf Map}$<$ std\+::string, {\bf Array}$<$ {\bf tir\+::\+Lowered\+Func} $>$$>$ \&}]{input, }
\item[{const {\bf Target} \&}]{target\+\_\+host, }
\item[{const {\bf Build\+Config} \&}]{config}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a879a810167b7f65cbfe7975da151c06d}{}\label{namespacetvm_a879a810167b7f65cbfe7975da151c06d}


Build a device and host module for a specific target from a map contains target to a list of lowered functions pairs. This function is used for heterogeneous build. 


\begin{DoxyParams}{Parameters}
{\em input} & The map contains target string to a list of lowered functions pairs. \\
\hline
{\em target\+\_\+host} & The target for building host code. To use the default, pass Target(). \\
\hline
{\em config} & The build configuration. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The built module that contains code for different processors. 
\end{DoxyReturn}
\index{tvm@{tvm}!cast@{cast}}
\index{cast@{cast}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{cast(const Data\+Type \&t, Prim\+Expr value)}{cast(const DataType &t, PrimExpr value)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::cast (
\begin{DoxyParamCaption}
\item[{const {\bf Data\+Type} \&}]{t, }
\item[{{\bf Prim\+Expr}}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_aa058caeda9deceda3d6ffeda347be442}{}\label{namespacetvm_aa058caeda9deceda3d6ffeda347be442}


cast value to type. 


\begin{DoxyParams}{Parameters}
{\em t} & the target type. \\
\hline
{\em value} & The value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function may return value if the type is the same. 
\end{DoxyNote}
\index{tvm@{tvm}!ceil@{ceil}}
\index{ceil@{ceil}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{ceil(\+Prim\+Expr x)}{ceil(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::ceil (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a530307f2fad9f6d196c441309af777b9}{}\label{namespacetvm_a530307f2fad9f6d196c441309af777b9}


Calculate ceil(x) 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!cos@{cos}}
\index{cos@{cos}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{cos(\+Prim\+Expr x)}{cos(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::cos (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a66fb538aa75f90efb6f5c948920f8f95}{}\label{namespacetvm_a66fb538aa75f90efb6f5c948920f8f95}
\index{tvm@{tvm}!cosh@{cosh}}
\index{cosh@{cosh}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{cosh(\+Prim\+Expr x)}{cosh(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::cosh (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a581c9279a40694ab7a5defa179bcad67}{}\label{namespacetvm_a581c9279a40694ab7a5defa179bcad67}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(\+Prim\+Expr a, Prim\+Expr b)}{div(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a40fcc9952e1ff01a76f3b75dbd368fc1}{}\label{namespacetvm_a40fcc9952e1ff01a76f3b75dbd368fc1}


compute division in C semantics. 

a / b as in C/\+C++.

When operands are integers, it directly corresponds to truncdiv.


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(const Prim\+Expr \&a, float b)}{div(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ae2d70142d842bb07be508adb2d4f7447}{}\label{namespacetvm_ae2d70142d842bb07be508adb2d4f7447}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(float a, const Prim\+Expr \&b)}{div(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a85c28d529a26976f3d5f67511f2aef8b}{}\label{namespacetvm_a85c28d529a26976f3d5f67511f2aef8b}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(int a, const Prim\+Expr \&b)}{div(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a8a958cb2612b58e6464f5421bb8ab74b}{}\label{namespacetvm_a8a958cb2612b58e6464f5421bb8ab74b}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(const Prim\+Expr \&a, int b)}{div(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac9f587b864957447e3d0c64ac9159633}{}\label{namespacetvm_ac9f587b864957447e3d0c64ac9159633}
\index{tvm@{tvm}!div@{div}}
\index{div@{div}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{div(const Prim\+Expr \&a, double b)}{div(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::div (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a1180d1f0ef1d427bad98a89c66d84c0f}{}\label{namespacetvm_a1180d1f0ef1d427bad98a89c66d84c0f}
\index{tvm@{tvm}!Div\+Ambiguity\+Error@{Div\+Ambiguity\+Error}}
\index{Div\+Ambiguity\+Error@{Div\+Ambiguity\+Error}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Div\+Ambiguity\+Error(const T\+A \&a)}{DivAmbiguityError(const TA &a)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename TA $>$ void tvm\+::\+Div\+Ambiguity\+Error (
\begin{DoxyParamCaption}
\item[{const TA \&}]{a}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a31e7a3e4a160a1d048e3ba741966f1a8}{}\label{namespacetvm_a31e7a3e4a160a1d048e3ba741966f1a8}


Helper function to raise a compiler error about division ambiguity. 

\begin{DoxyNote}{Note}
The call to this function will always results in a compiler error. 
\end{DoxyNote}

\begin{DoxyTemplParams}{Template Parameters}
{\em TA} & Any class type. \\
\hline
\end{DoxyTemplParams}
\index{tvm@{tvm}!Dump@{Dump}}
\index{Dump@{Dump}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Dump(const Object\+Ref \&node)}{Dump(const ObjectRef &node)}}]{\setlength{\rightskip}{0pt plus 5cm}void tvm\+::\+Dump (
\begin{DoxyParamCaption}
\item[{const Object\+Ref \&}]{node}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a23b1dfa894bd954c9a1eea4ab8199764}{}\label{namespacetvm_a23b1dfa894bd954c9a1eea4ab8199764}


Dump the node to stderr, used for debug purposes. 


\begin{DoxyParams}{Parameters}
{\em node} & The input node \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!erf@{erf}}
\index{erf@{erf}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{erf(\+Prim\+Expr x)}{erf(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::erf (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a78ebcdb32def4b349b37423884a6417a}{}\label{namespacetvm_a78ebcdb32def4b349b37423884a6417a}
\index{tvm@{tvm}!exp@{exp}}
\index{exp@{exp}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{exp(\+Prim\+Expr x)}{exp(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::exp (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aa21f5c2f67c944561ae4a260a2ed14d2}{}\label{namespacetvm_aa21f5c2f67c944561ae4a260a2ed14d2}
\index{tvm@{tvm}!exp10@{exp10}}
\index{exp10@{exp10}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{exp10(\+Prim\+Expr x)}{exp10(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::exp10 (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac760569fe43a52f3f8997461b2ef438a}{}\label{namespacetvm_ac760569fe43a52f3f8997461b2ef438a}
\index{tvm@{tvm}!exp2@{exp2}}
\index{exp2@{exp2}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{exp2(\+Prim\+Expr x)}{exp2(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::exp2 (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a21e3a5d7327cf37c6a682525665a0a28}{}\label{namespacetvm_a21e3a5d7327cf37c6a682525665a0a28}
\index{tvm@{tvm}!floor@{floor}}
\index{floor@{floor}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floor(\+Prim\+Expr x)}{floor(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floor (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a45896c89bce01ea68b5a8f3ea37f3079}{}\label{namespacetvm_a45896c89bce01ea68b5a8f3ea37f3079}


Calculate floor(x) 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!floordiv@{floordiv}}
\index{floordiv@{floordiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floordiv(\+Prim\+Expr a, Prim\+Expr b)}{floordiv(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floordiv (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a25cb3bf64427a16a93529d0a5c40b6de}{}\label{namespacetvm_a25cb3bf64427a16a93529d0a5c40b6de}


compute floor(a / b) 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!floordiv@{floordiv}}
\index{floordiv@{floordiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floordiv(const Prim\+Expr \&a, int b)}{floordiv(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floordiv (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a83e68dc71a05711a9c94123af2a3fdbf}{}\label{namespacetvm_a83e68dc71a05711a9c94123af2a3fdbf}
\index{tvm@{tvm}!floordiv@{floordiv}}
\index{floordiv@{floordiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floordiv(int a, const Prim\+Expr \&b)}{floordiv(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floordiv (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad3b659d13dd33e7a027b9d082315a776}{}\label{namespacetvm_ad3b659d13dd33e7a027b9d082315a776}
\index{tvm@{tvm}!floormod@{floormod}}
\index{floormod@{floormod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floormod(\+Prim\+Expr a, Prim\+Expr b)}{floormod(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floormod (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a74b2e0fb912a82f974e2b652f7de8d34}{}\label{namespacetvm_a74b2e0fb912a82f974e2b652f7de8d34}


compute the remainder of floordiv 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!floormod@{floormod}}
\index{floormod@{floormod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floormod(const Prim\+Expr \&a, int b)}{floormod(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floormod (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6993f628929a88cf563461c9dcafb2ae}{}\label{namespacetvm_a6993f628929a88cf563461c9dcafb2ae}
\index{tvm@{tvm}!floormod@{floormod}}
\index{floormod@{floormod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{floormod(int a, const Prim\+Expr \&b)}{floormod(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::floormod (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a08a5224a973dc893665ab543c116854d}{}\label{namespacetvm_a08a5224a973dc893665ab543c116854d}
\index{tvm@{tvm}!Get\+Memory\+Info@{Get\+Memory\+Info}}
\index{Get\+Memory\+Info@{Get\+Memory\+Info}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Get\+Memory\+Info(const std\+::string \&scope)}{GetMemoryInfo(const std::string &scope)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Memory\+Info} tvm\+::\+Get\+Memory\+Info (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{scope}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a6e525343df6fbd739a45b291cb0dfb4f}{}\label{namespacetvm_a6e525343df6fbd739a45b291cb0dfb4f}


get memory info given scope 


\begin{DoxyParams}{Parameters}
{\em scope} & The scope name. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
info The memory info. 
\end{DoxyReturn}
\index{tvm@{tvm}!Get\+Runtime\+Data\+Type@{Get\+Runtime\+Data\+Type}}
\index{Get\+Runtime\+Data\+Type@{Get\+Runtime\+Data\+Type}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Get\+Runtime\+Data\+Type(const Type \&type)}{GetRuntimeDataType(const Type &type)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf runtime\+::\+Data\+Type} tvm\+::\+Get\+Runtime\+Data\+Type (
\begin{DoxyParamCaption}
\item[{const {\bf Type} \&}]{type}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a0447e9aa45f6cab707f6dc9f9281b3f5}{}\label{namespacetvm_a0447e9aa45f6cab707f6dc9f9281b3f5}


Get the implied Data\+Type for storing values with type during runtime. 


\begin{DoxyParams}{Parameters}
{\em type} & The input type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result \hyperlink{classtvm_1_1runtime_1_1DataType}{runtime\+::\+Data\+Type}.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{ir_2type_8h}{tvm/ir/type.\+h} for discussion about the relation between \hyperlink{classtvm_1_1Type}{Type} and \hyperlink{classtvm_1_1runtime_1_1DataType}{runtime\+::\+Data\+Type}. 
\end{DoxySeeAlso}
\index{tvm@{tvm}!Get\+Type@{Get\+Type}}
\index{Get\+Type@{Get\+Type}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Get\+Type(const Prim\+Expr \&expr)}{GetType(const PrimExpr &expr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type} tvm\+::\+Get\+Type (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{expr}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a48fb9755f38ffcfcd03592a47ffbbd14}{}\label{namespacetvm_a48fb9755f38ffcfcd03592a47ffbbd14}


Get the type of the expression under the unified type system. 

This function could return a more refined type than the runtime type provided by expr-\/$>$dtype


\begin{DoxyParams}{Parameters}
{\em expr} & The input parameter. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result type.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{ir_2type_8h}{tvm/ir/type.\+h} for discussion about the relation between \hyperlink{classtvm_1_1Type}{Type} and \hyperlink{classtvm_1_1runtime_1_1DataType}{runtime\+::\+Data\+Type}. 
\end{DoxySeeAlso}
\index{tvm@{tvm}!if\+\_\+then\+\_\+else@{if\+\_\+then\+\_\+else}}
\index{if\+\_\+then\+\_\+else@{if\+\_\+then\+\_\+else}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{if\+\_\+then\+\_\+else(\+Prim\+Expr cond, Prim\+Expr true\+\_\+value, Prim\+Expr false\+\_\+value)}{if_then_else(PrimExpr cond, PrimExpr true_value, PrimExpr false_value)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::if\+\_\+then\+\_\+else (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{cond, }
\item[{{\bf Prim\+Expr}}]{true\+\_\+value, }
\item[{{\bf Prim\+Expr}}]{false\+\_\+value}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ad400409d87dc337f8b5fe13e18d363f9}{}\label{namespacetvm_ad400409d87dc337f8b5fe13e18d363f9}


Conditional expression. 


\begin{DoxyParams}{Parameters}
{\em cond} & The condition \\
\hline
{\em true\+\_\+value} & The value when results are true. \\
\hline
{\em false\+\_\+value} & The value when results are false. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!indexdiv@{indexdiv}}
\index{indexdiv@{indexdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexdiv(\+Prim\+Expr a, Prim\+Expr b)}{indexdiv(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexdiv (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a8203d70a5ebf3532370264b000d0d276}{}\label{namespacetvm_a8203d70a5ebf3532370264b000d0d276}


compute floor(a / b) where a and b are non-\/negative. 

Use this function for index split calculation.

This function might take advantage of the fact that a and b are non-\/negative.


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!indexdiv@{indexdiv}}
\index{indexdiv@{indexdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexdiv(const Prim\+Expr \&a, int b)}{indexdiv(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexdiv (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_af9a4e8a59397e5778c38356129c06110}{}\label{namespacetvm_af9a4e8a59397e5778c38356129c06110}
\index{tvm@{tvm}!indexdiv@{indexdiv}}
\index{indexdiv@{indexdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexdiv(int a, const Prim\+Expr \&b)}{indexdiv(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexdiv (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a9d88aa90642838c6bc41c4cbead148fd}{}\label{namespacetvm_a9d88aa90642838c6bc41c4cbead148fd}
\index{tvm@{tvm}!indexmod@{indexmod}}
\index{indexmod@{indexmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexmod(\+Prim\+Expr a, Prim\+Expr b)}{indexmod(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexmod (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a857781b7243b2f90018f7fe6baf9c30e}{}\label{namespacetvm_a857781b7243b2f90018f7fe6baf9c30e}


compute the remainder floor(a / b) where a and b are non-\/negative. 

Use this function for index split calculation. This function might take advantage of the fact that a and b are non-\/negative.


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!indexmod@{indexmod}}
\index{indexmod@{indexmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexmod(const Prim\+Expr \&a, int b)}{indexmod(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexmod (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac4d2991113bb8e0b634e4c83183eb5c1}{}\label{namespacetvm_ac4d2991113bb8e0b634e4c83183eb5c1}
\index{tvm@{tvm}!indexmod@{indexmod}}
\index{indexmod@{indexmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{indexmod(int a, const Prim\+Expr \&b)}{indexmod(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::indexmod (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_abd2345bc3cd37ab4f762c0f971042daa}{}\label{namespacetvm_abd2345bc3cd37ab4f762c0f971042daa}
\index{tvm@{tvm}!infinity@{infinity}}
\index{infinity@{infinity}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{infinity(const Data\+Type \&dtype)}{infinity(const DataType &dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::infinity (
\begin{DoxyParamCaption}
\item[{const {\bf Data\+Type} \&}]{dtype}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a9bf1977e7bc6f0424f4e87d77d0008ed}{}\label{namespacetvm_a9bf1977e7bc6f0424f4e87d77d0008ed}
Get the value of infinity. 
\begin{DoxyParams}{Parameters}
{\em dtype} & The data type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the infinity value in this format. 
\end{DoxyReturn}
\index{tvm@{tvm}!isfinite@{isfinite}}
\index{isfinite@{isfinite}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{isfinite(\+Prim\+Expr x)}{isfinite(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::isfinite (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a6a48a2b96c995f412390db3ea3b38bd9}{}\label{namespacetvm_a6a48a2b96c995f412390db3ea3b38bd9}


Check if x is finite. 


\begin{DoxyParams}{Parameters}
{\em x} & The input data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!isinf@{isinf}}
\index{isinf@{isinf}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{isinf(\+Prim\+Expr x)}{isinf(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::isinf (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a30e728d87aa70f76d7f4a09316c9746d}{}\label{namespacetvm_a30e728d87aa70f76d7f4a09316c9746d}


Check if x is infinite. 


\begin{DoxyParams}{Parameters}
{\em x} & The input data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!isnan@{isnan}}
\index{isnan@{isnan}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{isnan(\+Prim\+Expr x)}{isnan(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::isnan (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a8f98d60fdc4526b07c8858d6b0b8d1ee}{}\label{namespacetvm_a8f98d60fdc4526b07c8858d6b0b8d1ee}


Check if x is NaN. 


\begin{DoxyParams}{Parameters}
{\em x} & The input data \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!Is\+Primitive\+Op@{Is\+Primitive\+Op}}
\index{Is\+Primitive\+Op@{Is\+Primitive\+Op}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Is\+Primitive\+Op(const Relay\+Expr \&expr)}{IsPrimitiveOp(const RelayExpr &expr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::\+Is\+Primitive\+Op (
\begin{DoxyParamCaption}
\item[{const {\bf Relay\+Expr} \&}]{expr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a8259e23409eda017c6bde908e050b670}{}\label{namespacetvm_a8259e23409eda017c6bde908e050b670}


Check that an expression is a \char`\"{}primitive operator\char`\"{}. 

Will return true if the expression is an operator which matches the form of primitive operators registered directly by the Relay codebase.

That is the arguments are all type variables, and there is a single type relation applied to the input and output types.


\begin{DoxyParams}{Parameters}
{\em expr} & An expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the expression is primitive op. 
\end{DoxyReturn}
\index{tvm@{tvm}!Is\+Void\+Type@{Is\+Void\+Type}}
\index{Is\+Void\+Type@{Is\+Void\+Type}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Is\+Void\+Type(const Type \&type)}{IsVoidType(const Type &type)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::\+Is\+Void\+Type (
\begin{DoxyParamCaption}
\item[{const {\bf Type} \&}]{type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a196edb73fc9f13d965b8de1c9287a2db}{}\label{namespacetvm_a196edb73fc9f13d965b8de1c9287a2db}


Check whether the tyep represents void. 

\begin{DoxyReturn}{Returns}
The check result. 
\end{DoxyReturn}
\index{tvm@{tvm}!Large\+U\+Int\+Imm@{Large\+U\+Int\+Imm}}
\index{Large\+U\+Int\+Imm@{Large\+U\+Int\+Imm}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Large\+U\+Int\+Imm(\+Data\+Type dtype, int64\+\_\+t low, int64\+\_\+t high)}{LargeUIntImm(DataType dtype, int64_t low, int64_t high)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::\+Large\+U\+Int\+Imm (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{dtype, }
\item[{int64\+\_\+t}]{low, }
\item[{int64\+\_\+t}]{high}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a1b6f1345a0ac2506132b15ec4cbf3599}{}\label{namespacetvm_a1b6f1345a0ac2506132b15ec4cbf3599}


Construct a large uint constant by its low 32 bits and high 32bits. 


\begin{DoxyParams}{Parameters}
{\em dtype} & The final data type. \\
\hline
{\em low} & The lower 32 bits. \\
\hline
{\em high} & The higher 32 bits. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The constructed expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!likely@{likely}}
\index{likely@{likely}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{likely(\+Prim\+Expr cond)}{likely(PrimExpr cond)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::likely (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{cond}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ad6ee4c2d41e7e226d1995112cd12e3f1}{}\label{namespacetvm_ad6ee4c2d41e7e226d1995112cd12e3f1}


Mark condition as likely. 


\begin{DoxyParams}{Parameters}
{\em cond} & The condition \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The marked expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!Load\+J\+S\+ON@{Load\+J\+S\+ON}}
\index{Load\+J\+S\+ON@{Load\+J\+S\+ON}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Load\+J\+S\+O\+N(std\+::string json\+\_\+str)}{LoadJSON(std::string json_str)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf runtime\+::\+Object\+Ref} tvm\+::\+Load\+J\+S\+ON (
\begin{DoxyParamCaption}
\item[{std\+::string}]{json\+\_\+str}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_afa0a9bdf3997ef4fad45b19fb1a655cd}{}\label{namespacetvm_afa0a9bdf3997ef4fad45b19fb1a655cd}


Internal implementation of Load\+J\+S\+ON Load tvm Node object from json and return a shared\+\_\+ptr of Node. 


\begin{DoxyParams}{Parameters}
{\em json\+\_\+str} & The json string to load from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The shared\+\_\+ptr of the Node. 
\end{DoxyReturn}
\index{tvm@{tvm}!log@{log}}
\index{log@{log}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{log(\+Prim\+Expr x)}{log(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::log (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aed9236feb2ab21523cb2dcb0257fe8da}{}\label{namespacetvm_aed9236feb2ab21523cb2dcb0257fe8da}
\index{tvm@{tvm}!log10@{log10}}
\index{log10@{log10}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{log10(\+Prim\+Expr x)}{log10(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::log10 (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a04657a6242778fd95b77df057385e398}{}\label{namespacetvm_a04657a6242778fd95b77df057385e398}
\index{tvm@{tvm}!log2@{log2}}
\index{log2@{log2}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{log2(\+Prim\+Expr x)}{log2(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::log2 (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aae5edd83ffa099868f2d58a9def0b2b4}{}\label{namespacetvm_aae5edd83ffa099868f2d58a9def0b2b4}
\index{tvm@{tvm}!lower@{lower}}
\index{lower@{lower}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{lower(te\+::\+Schedule sch, const Array$<$ te\+::\+Tensor $>$ \&args, const std\+::string \&name, const std\+::unordered\+\_\+map$<$ te\+::\+Tensor, tir\+::\+Buffer $>$ \&binds, const Build\+Config \&config)}{lower(te::Schedule sch, const Array< te::Tensor > &args, const std::string &name, const std::unordered_map< te::Tensor, tir::Buffer > &binds, const BuildConfig &config)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Array}$<${\bf tir\+::\+Lowered\+Func}$>$ tvm\+::lower (
\begin{DoxyParamCaption}
\item[{{\bf te\+::\+Schedule}}]{sch, }
\item[{const {\bf Array}$<$ {\bf te\+::\+Tensor} $>$ \&}]{args, }
\item[{const std\+::string \&}]{name, }
\item[{const std\+::unordered\+\_\+map$<$ {\bf te\+::\+Tensor}, {\bf tir\+::\+Buffer} $>$ \&}]{binds, }
\item[{const {\bf Build\+Config} \&}]{config}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a9284f30c0e1daf1649838578fed1baa1}{}\label{namespacetvm_a9284f30c0e1daf1649838578fed1baa1}


Build a Lowered\+Func given a schedule, args and binds. 


\begin{DoxyParams}{Parameters}
{\em sch} & The schedule to lower. \\
\hline
{\em args} & The arguments to the function. \\
\hline
{\em name} & The name of the lowered function. \\
\hline
{\em binds} & Buffer assignments. \\
\hline
{\em config} & The build configuration. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The lowered function. 
\end{DoxyReturn}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(\+Prim\+Expr a, Prim\+Expr b)}{max(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ab49bad0808ba033343e72ba37b39af2e}{}\label{namespacetvm_ab49bad0808ba033343e72ba37b39af2e}


take maximum of two values 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{max(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a80f15d31bf89ba7654442d9ca9a91a18}{}\label{namespacetvm_a80f15d31bf89ba7654442d9ca9a91a18}


max of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(const Prim\+Expr \&a, float b)}{max(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7134c7ce44fbedab5990f19428ceb5c4}{}\label{namespacetvm_a7134c7ce44fbedab5990f19428ceb5c4}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(float a, const Prim\+Expr \&b)}{max(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_abc6aa5a903c9a71faece2f5dfbc8218c}{}\label{namespacetvm_abc6aa5a903c9a71faece2f5dfbc8218c}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(int a, const Prim\+Expr \&b)}{max(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7bd1dc5f6d10420562d216bb3660270d}{}\label{namespacetvm_a7bd1dc5f6d10420562d216bb3660270d}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(const Prim\+Expr \&a, int b)}{max(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac0dc60ecafe41384d28baf92f6943680}{}\label{namespacetvm_ac0dc60ecafe41384d28baf92f6943680}
\index{tvm@{tvm}!max@{max}}
\index{max@{max}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max(const Prim\+Expr \&a, double b)}{max(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aa26bf5f7b12b17f87400c63c63663c60}{}\label{namespacetvm_aa26bf5f7b12b17f87400c63c63663c60}
\index{tvm@{tvm}!max\+\_\+value@{max\+\_\+value}}
\index{max\+\_\+value@{max\+\_\+value}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{max\+\_\+value(const Data\+Type \&dtype)}{max_value(const DataType &dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::max\+\_\+value (
\begin{DoxyParamCaption}
\item[{const {\bf Data\+Type} \&}]{dtype}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a2741c5a48b50bf369026a1bbdf02017f}{}\label{namespacetvm_a2741c5a48b50bf369026a1bbdf02017f}
Query the maximum possible value of dtype. 
\begin{DoxyParams}{Parameters}
{\em dtype} & The data type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the maximum possible value in this format. 
\end{DoxyReturn}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(\+Prim\+Expr a, Prim\+Expr b)}{min(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a9da780393e228969f77aa7550520a582}{}\label{namespacetvm_a9da780393e228969f77aa7550520a582}


take minimum of two values 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{min(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a2028eb350061871512cf50fed0e6fa6b}{}\label{namespacetvm_a2028eb350061871512cf50fed0e6fa6b}


max of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(const Prim\+Expr \&a, double b)}{min(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a468d959980234ccc84c319810d787219}{}\label{namespacetvm_a468d959980234ccc84c319810d787219}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(const Prim\+Expr \&a, float b)}{min(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a1a8d2a9b2868033477024d551f779d61}{}\label{namespacetvm_a1a8d2a9b2868033477024d551f779d61}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(float a, const Prim\+Expr \&b)}{min(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6ebe9e5428f481f683f89f59440dde2a}{}\label{namespacetvm_a6ebe9e5428f481f683f89f59440dde2a}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(int a, const Prim\+Expr \&b)}{min(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a3b4b479c377151a9d64dc67d1105421e}{}\label{namespacetvm_a3b4b479c377151a9d64dc67d1105421e}
\index{tvm@{tvm}!min@{min}}
\index{min@{min}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min(const Prim\+Expr \&a, int b)}{min(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7fe0dbe362aac3d4f9c204eeba803d8e}{}\label{namespacetvm_a7fe0dbe362aac3d4f9c204eeba803d8e}
\index{tvm@{tvm}!min\+\_\+value@{min\+\_\+value}}
\index{min\+\_\+value@{min\+\_\+value}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{min\+\_\+value(const Data\+Type \&dtype)}{min_value(const DataType &dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::min\+\_\+value (
\begin{DoxyParamCaption}
\item[{const {\bf Data\+Type} \&}]{dtype}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a9c126a8dde0d4079713969ca574f172e}{}\label{namespacetvm_a9c126a8dde0d4079713969ca574f172e}
Query the minimum possible value of dtype. 
\begin{DoxyParams}{Parameters}
{\em dtype} & The data type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the minimum possible value in this format. 
\end{DoxyReturn}
\index{tvm@{tvm}!nearbyint@{nearbyint}}
\index{nearbyint@{nearbyint}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{nearbyint(\+Prim\+Expr x)}{nearbyint(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::nearbyint (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a8472b5c842e840063564d4280428ce23}{}\label{namespacetvm_a8472b5c842e840063564d4280428ce23}


Calculates std\+::nearbyint(x) 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. This is a faster alternate to round. 
\end{DoxyReturn}
\index{tvm@{tvm}!Null\+Value@{Null\+Value}}
\index{Null\+Value@{Null\+Value}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Null\+Value()}{NullValue()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Object\+Ref $>$ T\+Object\+Ref tvm\+::\+Null\+Value (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ab6c242e8ac09beb463fba306948b7f15}{}\label{namespacetvm_ab6c242e8ac09beb463fba306948b7f15}


Create a Node\+Ref type that represents null. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T\+Node\+Ref} & the type to be created. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
A instance that will represent None. 
\end{DoxyReturn}
\index{tvm@{tvm}!Null\+Value$<$ Data\+Type $>$@{Null\+Value$<$ Data\+Type $>$}}
\index{Null\+Value$<$ Data\+Type $>$@{Null\+Value$<$ Data\+Type $>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Null\+Value$<$ Data\+Type $>$()}{NullValue< DataType >()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$$>$ {\bf Data\+Type} {\bf tvm\+::\+Null\+Value}$<$ {\bf Data\+Type} $>$ (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a28c693333c2b15702b1a9a57dec0fbf5}{}\label{namespacetvm_a28c693333c2b15702b1a9a57dec0fbf5}
\index{tvm@{tvm}!operator"!@{operator"!}}
\index{operator"!@{operator"!}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator"!(\+Prim\+Expr a)}{operator!(PrimExpr a)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator! (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ab354bf1270121abea71fade83f13b0b0}{}\label{namespacetvm_ab354bf1270121abea71fade83f13b0b0}


not 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This operator does eager constant folding. 
\end{DoxyNote}
\index{tvm@{tvm}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator"!=(\+Prim\+Expr a, Prim\+Expr b)}{operator!=(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} {\bf tvm\+::operator!}= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a03983cf66713724c138f9697bb8e0e97}{}\label{namespacetvm_a03983cf66713724c138f9697bb8e0e97}


not\+\_\+equal 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator\%@{operator\%}}
\index{operator\%@{operator\%}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\%(const Prim\+Expr \&a, const T\+B \&b)}{operator%(const PrimExpr &a, const TB &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename TB $>$ {\bf Prim\+Expr} tvm\+::operator\% (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{const TB \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ab25738e50b37cd07b2d171ca74ba9321}{}\label{namespacetvm_ab25738e50b37cd07b2d171ca74ba9321}
\index{tvm@{tvm}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&(\+Prim\+Expr a, Prim\+Expr b)}{operator&(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\& (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a92e2cae35b1e48f130b76f42c6ee3106}{}\label{namespacetvm_a92e2cae35b1e48f130b76f42c6ee3106}


take bitwise and of two values 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&(const Prim\+Expr \&a, int b)}{operator&(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\& (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a4ff6afc90cabb820cf2f2fda6daefd92}{}\label{namespacetvm_a4ff6afc90cabb820cf2f2fda6daefd92}
\index{tvm@{tvm}!operator\&@{operator\&}}
\index{operator\&@{operator\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&(int a, const Prim\+Expr \&b)}{operator&(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\& (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_acb2697d9f746f0377975893eb080288e}{}\label{namespacetvm_acb2697d9f746f0377975893eb080288e}
\index{tvm@{tvm}!operator\&\&@{operator\&\&}}
\index{operator\&\&@{operator\&\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&\&(\+Prim\+Expr a, Prim\+Expr b)}{operator&&(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\&\& (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_afc83b50366be0862a6c8f88c9a4e62d5}{}\label{namespacetvm_afc83b50366be0862a6c8f88c9a4e62d5}


and 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This operator does eager constant folding. 
\end{DoxyNote}
\index{tvm@{tvm}!operator\&\&@{operator\&\&}}
\index{operator\&\&@{operator\&\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&\&(const Prim\+Expr \&a, bool b)}{operator&&(const PrimExpr &a, bool b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\&\& (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{bool}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aca62d5095a23e0e24db1d6611d118eab}{}\label{namespacetvm_aca62d5095a23e0e24db1d6611d118eab}
\index{tvm@{tvm}!operator\&\&@{operator\&\&}}
\index{operator\&\&@{operator\&\&}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\&\&(bool a, const Prim\+Expr \&b)}{operator&&(bool a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator\&\& (
\begin{DoxyParamCaption}
\item[{bool}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a3fc66f0c6cd2135365cd24917d931abe}{}\label{namespacetvm_a3fc66f0c6cd2135365cd24917d931abe}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(\+Prim\+Expr a, Prim\+Expr b)}{operator*(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a5c5034de2993b9130b7bd9d593a11bb5}{}\label{namespacetvm_a5c5034de2993b9130b7bd9d593a11bb5}


multiplication operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Prim\+Expr \&a, float b)}{operator*(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_af70bb4a982810d795dbd17ce73c6b124}{}\label{namespacetvm_af70bb4a982810d795dbd17ce73c6b124}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(float a, const Prim\+Expr \&b)}{operator*(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ace5dbde3bde1ba48d14a3f9064a45aee}{}\label{namespacetvm_ace5dbde3bde1ba48d14a3f9064a45aee}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(int a, const Prim\+Expr \&b)}{operator*(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aca621e1d2df8562819bc021c1410b741}{}\label{namespacetvm_aca621e1d2df8562819bc021c1410b741}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Prim\+Expr \&a, int b)}{operator*(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6823188ec16be854223bbffe349c975d}{}\label{namespacetvm_a6823188ec16be854223bbffe349c975d}
\index{tvm@{tvm}!operator$\ast$@{operator$\ast$}}
\index{operator$\ast$@{operator$\ast$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$(const Prim\+Expr \&a, double b)}{operator*(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a1815d8b152819885a5733554f374a9ca}{}\label{namespacetvm_a1815d8b152819885a5733554f374a9ca}
\index{tvm@{tvm}!operator$\ast$=@{operator$\ast$=}}
\index{operator$\ast$=@{operator$\ast$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\ast$=(\+Prim\+Expr \&a, Prim\+Expr b)}{operator*=(PrimExpr &a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\ast$= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr} \&}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a9233d7b436ae52ac070442ba19caed18}{}\label{namespacetvm_a9233d7b436ae52ac070442ba19caed18}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(\+Prim\+Expr a, Prim\+Expr b)}{operator+(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_af246f441d4ac21b110185b77240b2dcc}{}\label{namespacetvm_af246f441d4ac21b110185b77240b2dcc}


add operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(const Prim\+Expr \&a, double b)}{operator+(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac225d9ad74343d0e97a5e943e7f6a7d1}{}\label{namespacetvm_ac225d9ad74343d0e97a5e943e7f6a7d1}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(const Prim\+Expr \&a, float b)}{operator+(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a2725c044e8067299c3dccbd453ce614f}{}\label{namespacetvm_a2725c044e8067299c3dccbd453ce614f}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(float a, const Prim\+Expr \&b)}{operator+(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac86d7f61b9f0899a08685145f6bb5051}{}\label{namespacetvm_ac86d7f61b9f0899a08685145f6bb5051}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(int a, const Prim\+Expr \&b)}{operator+(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad728a6c2c3d21242a4df808aadb722eb}{}\label{namespacetvm_ad728a6c2c3d21242a4df808aadb722eb}
\index{tvm@{tvm}!operator+@{operator+}}
\index{operator+@{operator+}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+(const Prim\+Expr \&a, int b)}{operator+(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a50bfde26f015ed64e1c0341dd65d3fad}{}\label{namespacetvm_a50bfde26f015ed64e1c0341dd65d3fad}
\index{tvm@{tvm}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator+=(\+Prim\+Expr \&a, Prim\+Expr b)}{operator+=(PrimExpr &a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator+= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr} \&}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a96061840d12f84eeecc8fae11e245242}{}\label{namespacetvm_a96061840d12f84eeecc8fae11e245242}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(\+Prim\+Expr a, Prim\+Expr b)}{operator-(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_abde487c0197942c4ebb1b47277b89dac}{}\label{namespacetvm_abde487c0197942c4ebb1b47277b89dac}


subtraction operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(\+Prim\+Expr a)}{operator-(PrimExpr a)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_abc417454badf61b154d6a8d87cd8f171}{}\label{namespacetvm_abc417454badf61b154d6a8d87cd8f171}


negation. 


\begin{DoxyParams}{Parameters}
{\em a} & input. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(const Prim\+Expr \&a, double b)}{operator-(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a028ba217f99b6cb1592a6a56b2bc9ee5}{}\label{namespacetvm_a028ba217f99b6cb1592a6a56b2bc9ee5}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(const Prim\+Expr \&a, float b)}{operator-(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a679ff94dec26779d8769231abb229647}{}\label{namespacetvm_a679ff94dec26779d8769231abb229647}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(float a, const Prim\+Expr \&b)}{operator-(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aef861fe5325bc0b415a905a24c42f10a}{}\label{namespacetvm_aef861fe5325bc0b415a905a24c42f10a}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(int a, const Prim\+Expr \&b)}{operator-(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a4f40ad3340a853d58664bc864dc10d47}{}\label{namespacetvm_a4f40ad3340a853d58664bc864dc10d47}
\index{tvm@{tvm}!operator-\/@{operator-\/}}
\index{operator-\/@{operator-\/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/(const Prim\+Expr \&a, int b)}{operator-(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_af7c46ff33a2727f48b10d7d563f4a746}{}\label{namespacetvm_af7c46ff33a2727f48b10d7d563f4a746}
\index{tvm@{tvm}!operator-\/=@{operator-\/=}}
\index{operator-\/=@{operator-\/=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator-\/=(\+Prim\+Expr \&a, Prim\+Expr b)}{operator-=(PrimExpr &a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator-\/= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr} \&}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a164d454c519fecaa5611c86b65469acc}{}\label{namespacetvm_a164d454c519fecaa5611c86b65469acc}
\index{tvm@{tvm}!operator/@{operator/}}
\index{operator/@{operator/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator/(\+Prim\+Expr a, Prim\+Expr b)}{operator/(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator/ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a18256ba1213ce5ff3cf8037a314354b7}{}\label{namespacetvm_a18256ba1213ce5ff3cf8037a314354b7}


division operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator/@{operator/}}
\index{operator/@{operator/}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator/(const Prim\+Expr \&a, const T\+B \&b)}{operator/(const PrimExpr &a, const TB &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename TB $>$ {\bf Prim\+Expr} tvm\+::operator/ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{const TB \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a136427374941fbf8e50f53b1cab39e38}{}\label{namespacetvm_a136427374941fbf8e50f53b1cab39e38}
\index{tvm@{tvm}!operator/=@{operator/=}}
\index{operator/=@{operator/=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator/=(const Prim\+Expr \&a, const T\+B \&b)}{operator/=(const PrimExpr &a, const TB &b)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename TB $>$ {\bf Prim\+Expr} tvm\+::operator/= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{const TB \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a51dc569142bf8ce8ea55f73029d3807d}{}\label{namespacetvm_a51dc569142bf8ce8ea55f73029d3807d}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(\+Prim\+Expr a, Prim\+Expr b)}{operator<(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a1f98476c3a413f6cdfc7b7e490f3221b}{}\label{namespacetvm_a1f98476c3a413f6cdfc7b7e490f3221b}


less 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(const Prim\+Expr \&a, float b)}{operator<(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a4c5092e248ab7daa5de5c22717670d8e}{}\label{namespacetvm_a4c5092e248ab7daa5de5c22717670d8e}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(float a, const Prim\+Expr \&b)}{operator<(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_abc5d3aba4f3f15098d5ac2fb0c3dfd39}{}\label{namespacetvm_abc5d3aba4f3f15098d5ac2fb0c3dfd39}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(int a, const Prim\+Expr \&b)}{operator<(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a46877235265ab97544ec2e561f521b0f}{}\label{namespacetvm_a46877235265ab97544ec2e561f521b0f}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(const Prim\+Expr \&a, double b)}{operator<(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a0854363590c38f5479b1da5e70c4f002}{}\label{namespacetvm_a0854363590c38f5479b1da5e70c4f002}
\index{tvm@{tvm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$(const Prim\+Expr \&a, int b)}{operator<(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aa672271dbd566a0e7b9e4c87664bccb4}{}\label{namespacetvm_aa672271dbd566a0e7b9e4c87664bccb4}
\index{tvm@{tvm}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$$<$(\+Prim\+Expr a, Prim\+Expr b)}{operator<<(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_af682776c3609284f1bc3ea436e21a67a}{}\label{namespacetvm_af682776c3609284f1bc3ea436e21a67a}


left shift operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$$<$(const Prim\+Expr \&a, int b)}{operator<<(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a9d8412e5f401f59f5ca85ed556d70810}{}\label{namespacetvm_a9d8412e5f401f59f5ca85ed556d70810}
\index{tvm@{tvm}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$$<$(int a, const Prim\+Expr \&b)}{operator<<(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad0449d28f23318cc5163159a58c80ba3}{}\label{namespacetvm_ad0449d28f23318cc5163159a58c80ba3}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(\+Prim\+Expr a, Prim\+Expr b)}{operator<=(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a598f8139c469abc4066dbdd0a0a0845d}{}\label{namespacetvm_a598f8139c469abc4066dbdd0a0a0845d}


less\+\_\+equal 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(const Prim\+Expr \&a, double b)}{operator<=(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6eea8276bcc178425bc14f3d878970ff}{}\label{namespacetvm_a6eea8276bcc178425bc14f3d878970ff}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(const Prim\+Expr \&a, float b)}{operator<=(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a06d97bd5ee2c12e8547be0cc42f6b300}{}\label{namespacetvm_a06d97bd5ee2c12e8547be0cc42f6b300}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(int a, const Prim\+Expr \&b)}{operator<=(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad5dbec0c48b8644c5c6e9d773ddc106b}{}\label{namespacetvm_ad5dbec0c48b8644c5c6e9d773ddc106b}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(const Prim\+Expr \&a, int b)}{operator<=(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_af94a56db543e741a23bbf2f51c49091a}{}\label{namespacetvm_af94a56db543e741a23bbf2f51c49091a}
\index{tvm@{tvm}!operator$<$=@{operator$<$=}}
\index{operator$<$=@{operator$<$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$<$=(float a, const Prim\+Expr \&b)}{operator<=(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$<$= (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a872f50bd7175eccf440865311aa75232}{}\label{namespacetvm_a872f50bd7175eccf440865311aa75232}
\index{tvm@{tvm}!operator==@{operator==}}
\index{operator==@{operator==}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator==(\+Prim\+Expr a, Prim\+Expr b)}{operator==(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator== (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a2ea3b45c96d3980227e418f7158ce5c3}{}\label{namespacetvm_a2ea3b45c96d3980227e418f7158ce5c3}


equal 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(\+Prim\+Expr a, Prim\+Expr b)}{operator>(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ad93d00f7b080dc3f905f5c34c170a041}{}\label{namespacetvm_ad93d00f7b080dc3f905f5c34c170a041}


greater 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(int a, const Prim\+Expr \&b)}{operator>(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6aeb6ed068c5de8ab908ff234337aeeb}{}\label{namespacetvm_a6aeb6ed068c5de8ab908ff234337aeeb}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(const Prim\+Expr \&a, int b)}{operator>(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_acc92dcd3d81981e983ddf05347bc9371}{}\label{namespacetvm_acc92dcd3d81981e983ddf05347bc9371}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(const Prim\+Expr \&a, double b)}{operator>(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7e2181bca182f90533ec35537714d09d}{}\label{namespacetvm_a7e2181bca182f90533ec35537714d09d}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(const Prim\+Expr \&a, float b)}{operator>(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a9cea8f3789d8f3dc78acae43e9a6aad6}{}\label{namespacetvm_a9cea8f3789d8f3dc78acae43e9a6aad6}
\index{tvm@{tvm}!operator$>$@{operator$>$}}
\index{operator$>$@{operator$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$(float a, const Prim\+Expr \&b)}{operator>(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$ (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6d0ad14c882c11311836138a2c164cf3}{}\label{namespacetvm_a6d0ad14c882c11311836138a2c164cf3}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(\+Prim\+Expr a, Prim\+Expr b)}{operator>=(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a5530417da455bd46f5dc55f27d69bcdf}{}\label{namespacetvm_a5530417da455bd46f5dc55f27d69bcdf}


greater\+\_\+equal 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(int a, const Prim\+Expr \&b)}{operator>=(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_af7dee311b945dfc5a821a119c1db9ad1}{}\label{namespacetvm_af7dee311b945dfc5a821a119c1db9ad1}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(const Prim\+Expr \&a, float b)}{operator>=(const PrimExpr &a, float b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{float}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a35961a6074b72fae0dfc48ee395e0673}{}\label{namespacetvm_a35961a6074b72fae0dfc48ee395e0673}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(const Prim\+Expr \&a, int b)}{operator>=(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ac194836fc11a8ba34e44738da17fd116}{}\label{namespacetvm_ac194836fc11a8ba34e44738da17fd116}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(const Prim\+Expr \&a, double b)}{operator>=(const PrimExpr &a, double b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{double}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aae1dcfef78728c5490d3c107b4abac5a}{}\label{namespacetvm_aae1dcfef78728c5490d3c107b4abac5a}
\index{tvm@{tvm}!operator$>$=@{operator$>$=}}
\index{operator$>$=@{operator$>$=}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$=(float a, const Prim\+Expr \&b)}{operator>=(float a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$= (
\begin{DoxyParamCaption}
\item[{float}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7a94a354cd62137652e09fa887a96100}{}\label{namespacetvm_a7a94a354cd62137652e09fa887a96100}
\index{tvm@{tvm}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$$>$(\+Prim\+Expr a, Prim\+Expr b)}{operator>>(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$$>$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a1ce1eb32fc9d76ebe5a6b8d185024d41}{}\label{namespacetvm_a1ce1eb32fc9d76ebe5a6b8d185024d41}


right shift operator 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$$>$(const Prim\+Expr \&a, int b)}{operator>>(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$$>$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_abccc3d3e96ee608022b148ffa05034eb}{}\label{namespacetvm_abccc3d3e96ee608022b148ffa05034eb}
\index{tvm@{tvm}!operator$>$$>$@{operator$>$$>$}}
\index{operator$>$$>$@{operator$>$$>$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$>$$>$(int a, const Prim\+Expr \&b)}{operator>>(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$>$$>$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a550c2a251b2a6fd2a72172fe3db75d40}{}\label{namespacetvm_a550c2a251b2a6fd2a72172fe3db75d40}
\index{tvm@{tvm}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(\+Prim\+Expr a, Prim\+Expr b)}{operator^(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_abd7d1b3232218b25e2e0cf6ef699a65f}{}\label{namespacetvm_abd7d1b3232218b25e2e0cf6ef699a65f}


take bitwise xor of two values 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(int a, const Prim\+Expr \&b)}{operator^(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a6f638564e5e4d1023096523800f2579e}{}\label{namespacetvm_a6f638564e5e4d1023096523800f2579e}
\index{tvm@{tvm}!operator$^\wedge$@{operator$^\wedge$}}
\index{operator$^\wedge$@{operator$^\wedge$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$^\wedge$(const Prim\+Expr \&a, int b)}{operator^(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$^\wedge$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a82dc2fe21e7a64be5a1b11c2a8775d31}{}\label{namespacetvm_a82dc2fe21e7a64be5a1b11c2a8775d31}
\index{tvm@{tvm}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(\+Prim\+Expr a, Prim\+Expr b)}{operator|(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a236d9aae385e6697874f75e4c8a69f8d}{}\label{namespacetvm_a236d9aae385e6697874f75e4c8a69f8d}


take bitwise or of two values 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(const Prim\+Expr \&a, int b)}{operator|(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a7c7fc3c45e6f6b52b2a1064deabd0797}{}\label{namespacetvm_a7c7fc3c45e6f6b52b2a1064deabd0797}
\index{tvm@{tvm}!operator\texttt{"|}@{operator\texttt{"|}}}
\index{operator\texttt{"|}@{operator\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}(int a, const Prim\+Expr \&b)}{operator|(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$ (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad5ba71021b167b0a6ca2138b2c8bbace}{}\label{namespacetvm_ad5ba71021b167b0a6ca2138b2c8bbace}
\index{tvm@{tvm}!operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}}
\index{operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}\texttt{"|}(\+Prim\+Expr a, Prim\+Expr b)}{operator||(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$$\vert$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ac3bf2ef3556c995846dddcd84e5db8a6}{}\label{namespacetvm_ac3bf2ef3556c995846dddcd84e5db8a6}


or 


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This operator does eager constant folding. 
\end{DoxyNote}
\index{tvm@{tvm}!operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}}
\index{operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}\texttt{"|}(const Prim\+Expr \&a, bool b)}{operator||(const PrimExpr &a, bool b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$$\vert$ (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{bool}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a873bb60c71f37cbb743e21797a53ba06}{}\label{namespacetvm_a873bb60c71f37cbb743e21797a53ba06}
\index{tvm@{tvm}!operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}}
\index{operator\texttt{"|}\texttt{"|}@{operator\texttt{"|}\texttt{"|}}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator\texttt{"|}\texttt{"|}(bool a, const Prim\+Expr \&b)}{operator||(bool a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\vert$$\vert$ (
\begin{DoxyParamCaption}
\item[{bool}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a1a3f9ad4d0e25eee9c0b3a9c83114bc0}{}\label{namespacetvm_a1a3f9ad4d0e25eee9c0b3a9c83114bc0}
\index{tvm@{tvm}!operator````~@{operator$\sim$}}
\index{operator````~@{operator$\sim$}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{operator$\sim$(\+Prim\+Expr a)}{operator~(PrimExpr a)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::operator$\sim$ (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a354b9954ff25dd819a51d856fdd38827}{}\label{namespacetvm_a354b9954ff25dd819a51d856fdd38827}


take bitwise negation of two values 


\begin{DoxyParams}{Parameters}
{\em a} & the input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!popcount@{popcount}}
\index{popcount@{popcount}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{popcount(\+Prim\+Expr x)}{popcount(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::popcount (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a04551919927933a4265c87809d889577}{}\label{namespacetvm_a04551919927933a4265c87809d889577}
\index{tvm@{tvm}!pow@{pow}}
\index{pow@{pow}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{pow(\+Prim\+Expr x, Prim\+Expr y)}{pow(PrimExpr x, PrimExpr y)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::pow (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x, }
\item[{{\bf Prim\+Expr}}]{y}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a880f0cd15891153430b669f0b4eca2fe}{}\label{namespacetvm_a880f0cd15891153430b669f0b4eca2fe}


Calculate power(x, y) 


\begin{DoxyParams}{Parameters}
{\em x} & The left operand. \\
\hline
{\em y} & The right operand. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!Pretty\+Print@{Pretty\+Print}}
\index{Pretty\+Print@{Pretty\+Print}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Pretty\+Print(const Object\+Ref \&node)}{PrettyPrint(const ObjectRef &node)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string tvm\+::\+Pretty\+Print (
\begin{DoxyParamCaption}
\item[{const Object\+Ref \&}]{node}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a52d7b2faa9f73a02d3e983b80af1f2a5}{}\label{namespacetvm_a52d7b2faa9f73a02d3e983b80af1f2a5}


Pretty print a node for debug purposes. 


\begin{DoxyParams}{Parameters}
{\em node} & The node to be printed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The text reperesentation. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function does not show version or meta-\/data. Use As\+Text if you want to store the text. 
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\hyperlink{namespacetvm_a535496e3535d7128d7fe4a52a397f538}{As\+Text}. 
\end{DoxySeeAlso}
\index{tvm@{tvm}!prod@{prod}}
\index{prod@{prod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{prod(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{prod(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::prod (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_afd8718fe1f413ab2850cdbb66adfbecc}{}\label{namespacetvm_afd8718fe1f413ab2850cdbb66adfbecc}


product of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!reinterpret@{reinterpret}}
\index{reinterpret@{reinterpret}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{reinterpret(const Data\+Type \&t, Prim\+Expr value)}{reinterpret(const DataType &t, PrimExpr value)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::reinterpret (
\begin{DoxyParamCaption}
\item[{const {\bf Data\+Type} \&}]{t, }
\item[{{\bf Prim\+Expr}}]{value}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a2acd72f0adb3d9ae5eede7497b32c139}{}\label{namespacetvm_a2acd72f0adb3d9ae5eede7497b32c139}


perform reinterpret cast value to type. 


\begin{DoxyParams}{Parameters}
{\em t} & the target type. \\
\hline
{\em value} & The value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function may return value if the type is the same. 
\end{DoxyNote}
\index{tvm@{tvm}!round@{round}}
\index{round@{round}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{round(\+Prim\+Expr x)}{round(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::round (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a660170263d6864b1caa60728619971be}{}\label{namespacetvm_a660170263d6864b1caa60728619971be}


Calculate round(x) 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!rsqrt@{rsqrt}}
\index{rsqrt@{rsqrt}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{rsqrt(\+Prim\+Expr x)}{rsqrt(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::rsqrt (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ae77bc5dc1c2f4bcafcac8ad698b089a5}{}\label{namespacetvm_ae77bc5dc1c2f4bcafcac8ad698b089a5}
\index{tvm@{tvm}!Save\+J\+S\+ON@{Save\+J\+S\+ON}}
\index{Save\+J\+S\+ON@{Save\+J\+S\+ON}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Save\+J\+S\+O\+N(const runtime\+::\+Object\+Ref \&node)}{SaveJSON(const runtime::ObjectRef &node)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string tvm\+::\+Save\+J\+S\+ON (
\begin{DoxyParamCaption}
\item[{const {\bf runtime\+::\+Object\+Ref} \&}]{node}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_aad98af358976b1598430090b7db92823}{}\label{namespacetvm_aad98af358976b1598430090b7db92823}


save the node as well as all the node it depends on as json. This can be used to serialize any T\+VM object 

\begin{DoxyReturn}{Returns}
the string representation of the node. 
\end{DoxyReturn}
\index{tvm@{tvm}!sigmoid@{sigmoid}}
\index{sigmoid@{sigmoid}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{sigmoid(\+Prim\+Expr x)}{sigmoid(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::sigmoid (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a1bf7732939d615e08d0d991e2f271c42}{}\label{namespacetvm_a1bf7732939d615e08d0d991e2f271c42}
\index{tvm@{tvm}!sin@{sin}}
\index{sin@{sin}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{sin(\+Prim\+Expr x)}{sin(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::sin (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aeb9b0d266628cfa6c4d254c4e719249a}{}\label{namespacetvm_aeb9b0d266628cfa6c4d254c4e719249a}
\index{tvm@{tvm}!sinh@{sinh}}
\index{sinh@{sinh}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{sinh(\+Prim\+Expr x)}{sinh(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::sinh (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a8c17ac9dc5cd2be44dd2c3ef23e0e4c9}{}\label{namespacetvm_a8c17ac9dc5cd2be44dd2c3ef23e0e4c9}
\index{tvm@{tvm}!split\+\_\+dev\+\_\+host\+\_\+funcs@{split\+\_\+dev\+\_\+host\+\_\+funcs}}
\index{split\+\_\+dev\+\_\+host\+\_\+funcs@{split\+\_\+dev\+\_\+host\+\_\+funcs}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{split\+\_\+dev\+\_\+host\+\_\+funcs(const Array$<$ tir\+::\+Lowered\+Func $>$ \&funcs, const Target \&target, const Target \&target\+\_\+host, const Build\+Config \&config)}{split_dev_host_funcs(const Array< tir::LoweredFunc > &funcs, const Target &target, const Target &target_host, const BuildConfig &config)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Array}$<${\bf Array}$<${\bf tir\+::\+Lowered\+Func}$>$ $>$ tvm\+::split\+\_\+dev\+\_\+host\+\_\+funcs (
\begin{DoxyParamCaption}
\item[{const {\bf Array}$<$ {\bf tir\+::\+Lowered\+Func} $>$ \&}]{funcs, }
\item[{const {\bf Target} \&}]{target, }
\item[{const {\bf Target} \&}]{target\+\_\+host, }
\item[{const {\bf Build\+Config} \&}]{config}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a66b6a4702f9c98e4e4c6c385da231903}{}\label{namespacetvm_a66b6a4702f9c98e4e4c6c385da231903}


Split host/device function and running necessary pass before build. 


\begin{DoxyParams}{Parameters}
{\em funcs} & The functions to be built. \\
\hline
{\em target} & The target device to build for. \\
\hline
{\em target\+\_\+host} & The target for building host code. To use the default, pass Target() \\
\hline
{\em config} & The build configuration. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{classtvm_1_1Array}{Array}$<$Array$<$\+Lowered\+Func$>$$>$ with 2 elements. First is host function \hyperlink{classtvm_1_1Array}{Array}, second is device function array 
\end{DoxyReturn}
\index{tvm@{tvm}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{sqrt(\+Prim\+Expr x)}{sqrt(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::sqrt (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a0a4fcbbd8d9db345d4d7e8bb0a76671a}{}\label{namespacetvm_a0a4fcbbd8d9db345d4d7e8bb0a76671a}
\index{tvm@{tvm}!sum@{sum}}
\index{sum@{sum}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{sum(\+Prim\+Expr source, Array$<$ tir\+::\+Iter\+Var $>$ axis)}{sum(PrimExpr source, Array< tir::IterVar > axis)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::sum (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{source, }
\item[{{\bf Array}$<$ {\bf tir\+::\+Iter\+Var} $>$}]{axis}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a5cea5eb708bfbfa08e285092e5afdc33}{}\label{namespacetvm_a5cea5eb708bfbfa08e285092e5afdc33}


sum of of source expression over axis 


\begin{DoxyParams}{Parameters}
{\em source} & The source expression. \\
\hline
{\em axis} & List of iteration variables that will be used for reduction. \\
\hline
\end{DoxyParams}
\index{tvm@{tvm}!tan@{tan}}
\index{tan@{tan}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{tan(\+Prim\+Expr x)}{tan(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tan (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_aaabcd438dbdc57aa6866fde3edaf2d83}{}\label{namespacetvm_aaabcd438dbdc57aa6866fde3edaf2d83}
\index{tvm@{tvm}!tanh@{tanh}}
\index{tanh@{tanh}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{tanh(\+Prim\+Expr x)}{tanh(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tanh (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad8a570f4008eb8869504544d7a1cd8ce}{}\label{namespacetvm_ad8a570f4008eb8869504544d7a1cd8ce}
\index{tvm@{tvm}!trunc@{trunc}}
\index{trunc@{trunc}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{trunc(\+Prim\+Expr x)}{trunc(PrimExpr x)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::trunc (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{x}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ae17d5a4cdf12b4da457d4929030592cf}{}\label{namespacetvm_ae17d5a4cdf12b4da457d4929030592cf}


Calculate trunc(x) 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm@{tvm}!truncdiv@{truncdiv}}
\index{truncdiv@{truncdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncdiv(\+Prim\+Expr a, Prim\+Expr b)}{truncdiv(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncdiv (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_a7bcbff6b886a4fa59b65e7cf05714b49}{}\label{namespacetvm_a7bcbff6b886a4fa59b65e7cf05714b49}


compute trunc(a / b) 

This is the default integer division behavior in C.


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!truncdiv@{truncdiv}}
\index{truncdiv@{truncdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncdiv(int a, const Prim\+Expr \&b)}{truncdiv(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncdiv (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a5b5bb91649c681b0ea799689be9647bf}{}\label{namespacetvm_a5b5bb91649c681b0ea799689be9647bf}
\index{tvm@{tvm}!truncdiv@{truncdiv}}
\index{truncdiv@{truncdiv}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncdiv(const Prim\+Expr \&a, int b)}{truncdiv(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncdiv (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ae50afd0565c00f594ee188bab7323372}{}\label{namespacetvm_ae50afd0565c00f594ee188bab7323372}
\index{tvm@{tvm}!truncmod@{truncmod}}
\index{truncmod@{truncmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncmod(\+Prim\+Expr a, Prim\+Expr b)}{truncmod(PrimExpr a, PrimExpr b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncmod (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{a, }
\item[{{\bf Prim\+Expr}}]{b}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_ae3fd62ca6008d6f20e4845426ec47aa6}{}\label{namespacetvm_ae3fd62ca6008d6f20e4845426ec47aa6}


compute the remainder of truncdiv 

This is the default integer division behavior in C.


\begin{DoxyParams}{Parameters}
{\em a} & left operand \\
\hline
{\em b} & right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
this function does eager constant folding for index types(int32, int64) when possible. 
\end{DoxyNote}
\index{tvm@{tvm}!truncmod@{truncmod}}
\index{truncmod@{truncmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncmod(int a, const Prim\+Expr \&b)}{truncmod(int a, const PrimExpr &b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncmod (
\begin{DoxyParamCaption}
\item[{int}]{a, }
\item[{const {\bf Prim\+Expr} \&}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ad6c6dbf136b1086695780fd695df350b}{}\label{namespacetvm_ad6c6dbf136b1086695780fd695df350b}
\index{tvm@{tvm}!truncmod@{truncmod}}
\index{truncmod@{truncmod}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{truncmod(const Prim\+Expr \&a, int b)}{truncmod(const PrimExpr &a, int b)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::truncmod (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a, }
\item[{int}]{b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a4c2633a4e92785dd73834bfff282699c}{}\label{namespacetvm_a4c2633a4e92785dd73834bfff282699c}
\index{tvm@{tvm}!Void\+Type@{Void\+Type}}
\index{Void\+Type@{Void\+Type}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{Void\+Type()}{VoidType()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type} tvm\+::\+Void\+Type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_a27df956aaa2e5e25005e0f9dc1638a08}{}\label{namespacetvm_a27df956aaa2e5e25005e0f9dc1638a08}
\begin{DoxyReturn}{Returns}
a type that represents void. 
\end{DoxyReturn}
\index{tvm@{tvm}!With\+Attr@{With\+Attr}}
\index{With\+Attr@{With\+Attr}!tvm@{tvm}}
\subsubsection[{\texorpdfstring{With\+Attr(\+T\+Func func, const std\+::string \&attr\+\_\+key, Object\+Ref attr\+\_\+value)}{WithAttr(TFunc func, const std::string &attr_key, ObjectRef attr_value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T\+Func , typename  = typename std\+::enable\+\_\+if$<$           std\+::is\+\_\+base\+\_\+of$<$\+Base\+Func, T\+Func$>$\+::value$>$\+::type$>$ T\+Func tvm\+::\+With\+Attr (
\begin{DoxyParamCaption}
\item[{T\+Func}]{func, }
\item[{const std\+::string \&}]{attr\+\_\+key, }
\item[{Object\+Ref}]{attr\+\_\+value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_ae3262464aa53a0c8b1b6078dfadab049}{}\label{namespacetvm_ae3262464aa53a0c8b1b6078dfadab049}


Create a new function that copies func, but overrides the attribute value key with the value. 


\begin{DoxyParams}{Parameters}
{\em func} & The input function. \\
\hline
{\em attr\+\_\+key} & The attribute key. \\
\hline
{\em attr\+\_\+value} & The value attribute value.\\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T\+Func} & The corresponding function type.\\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
The new function with updated attributes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This function performs copy on write optimization for func. If we move a uniquely referenced func into With\+Attr, then no additional copy will be performed.
\end{DoxyNote}
This is also why we make it as a function instead of a member function and why we pass by value in the first argument.


\begin{DoxyCode}
\textcolor{comment}{// Recommended way to trigger copy on write}
func = \hyperlink{namespacetvm_ae3262464aa53a0c8b1b6078dfadab049}{WithAttr}(std::move(func), \textcolor{stringliteral}{"key1"}, value1);
func = \hyperlink{namespacetvm_ae3262464aa53a0c8b1b6078dfadab049}{WithAttr}(std::move(func), \textcolor{stringliteral}{"key2"}, value2);
\end{DoxyCode}
 