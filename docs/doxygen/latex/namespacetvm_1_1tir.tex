\hypertarget{namespacetvm_1_1tir}{}\section{tvm\+:\+:tir Namespace Reference}
\label{namespacetvm_1_1tir}\index{tvm\+::tir@{tvm\+::tir}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacetvm_1_1tir_1_1attr}{attr}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func} specific attribute names. \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1tir_1_1intrinsic}{intrinsic}
\begin{DoxyCompactList}\small\item\em namespace of T\+VM Intrinsic functions \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1tir_1_1transform}{transform}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classtvm_1_1tir_1_1AddNode}{Add\+Node}
\begin{DoxyCompactList}\small\item\em a + b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1AllocateNode}{Allocate\+Node}
\begin{DoxyCompactList}\small\item\em Allocate a buffer that can be used in body. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1AndNode}{And\+Node}
\begin{DoxyCompactList}\small\item\em a \&\& b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1AnyNode}{Any\+Node}
\begin{DoxyCompactList}\small\item\em Any shape. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1AssertStmtNode}{Assert\+Stmt\+Node}
\begin{DoxyCompactList}\small\item\em Assert condition, if an error occurs, return the error message. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1AttrStmtNode}{Attr\+Stmt\+Node}
\begin{DoxyCompactList}\small\item\em Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1BijectiveLayout}{Bijective\+Layout}
\begin{DoxyCompactList}\small\item\em Bijective function mapping for data layout transformation. Given two \hyperlink{classtvm_1_1tir_1_1Layout}{Layout}, \hyperlink{classtvm_1_1tir_1_1BijectiveLayout}{Bijective\+Layout} build and store the mapping rules, provides A\+PI to transform N-\/dimention tensor from the source indices (i0, i1, …, im) to the destination indices (j0, j1, … jm). \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1BijectiveLayoutNode}{Bijective\+Layout\+Node}
\item 
class \hyperlink{classtvm_1_1tir_1_1BinaryOpNode}{Binary\+Op\+Node}
\begin{DoxyCompactList}\small\item\em Base template to implement binary ops. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1BroadcastNode}{Broadcast\+Node}
\begin{DoxyCompactList}\small\item\em Create a vector where all the elements are value. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} is a symbolic n-\/darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1BufferNode}{Buffer\+Node}
\begin{DoxyCompactList}\small\item\em Node to represent a buffer. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1CallNode}{Call\+Node}
\begin{DoxyCompactList}\small\item\em Call node. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1CastNode}{Cast\+Node}
\begin{DoxyCompactList}\small\item\em Cast value from one data type to another. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1CmpOpNode}{Cmp\+Op\+Node}
\begin{DoxyCompactList}\small\item\em Base template to implement comparison ops. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1CommReducer}{Comm\+Reducer}
\item 
class \hyperlink{classtvm_1_1tir_1_1CommReducerNode}{Comm\+Reducer\+Node}
\begin{DoxyCompactList}\small\item\em A commutative reducer node to represent a commutative binary operator with identity element. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1DivNode}{Div\+Node}
\begin{DoxyCompactList}\small\item\em a / b in the C semnatics. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1EQNode}{E\+Q\+Node}
\begin{DoxyCompactList}\small\item\em a == b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1EvaluateNode}{Evaluate\+Node}
\begin{DoxyCompactList}\small\item\em Evaluates an expression. This is mostly used for putting a Call node into \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ExprFunctor}{Expr\+Functor}
\begin{DoxyCompactList}\small\item\em A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4}{Expr\+Functor$<$ R(const Prim\+Expr \&n, Args...)$>$}
\item 
class \hyperlink{classtvm_1_1tir_1_1ExprMutator}{Expr\+Mutator}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1ExprMutator}{Expr\+Mutator} that mutates expressions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ExprVisitor}{Expr\+Visitor}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1ExprVisitor}{Expr\+Visitor}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1FloorDivNode}{Floor\+Div\+Node}
\begin{DoxyCompactList}\small\item\em Floor division, floor(a/b) \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1FloorModNode}{Floor\+Mod\+Node}
\begin{DoxyCompactList}\small\item\em The remainder of the floordiv. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ForNode}{For\+Node}
\begin{DoxyCompactList}\small\item\em A for loop, with poissible type annotations. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1FreeNode}{Free\+Node}
\begin{DoxyCompactList}\small\item\em Free the resources in the buffer before the scope ends. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1FunctionBaseNode}{Function\+Base\+Node}
\begin{DoxyCompactList}\small\item\em Base node of internal functions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1FunctionRef}{Function\+Ref}
\begin{DoxyCompactList}\small\item\em reference to a function \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1GENode}{G\+E\+Node}
\begin{DoxyCompactList}\small\item\em a $>$= b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1GTNode}{G\+T\+Node}
\begin{DoxyCompactList}\small\item\em a $>$ b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1IfThenElseNode}{If\+Then\+Else\+Node}
\begin{DoxyCompactList}\small\item\em If\+Then\+Else statment. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var}
\begin{DoxyCompactList}\small\item\em Iteration Variable, represents an iteration over an integer interval. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1IterVarNode}{Iter\+Var\+Node}
\begin{DoxyCompactList}\small\item\em An iteration variable representing an iteration over a one dimensional interval. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1Layout}{Layout}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1Layout}{Layout} is to describe how data is organized within an N-\/dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. For example, N\+C\+H\+W16c can describe a 5-\/D tensor of \mbox{[}batch\+\_\+size, channel, height, width, channel\+\_\+block\mbox{]}. Here subordinate axis channel\+\_\+block=16 is the factor size of the primal axis C (channel). \hyperlink{classtvm_1_1tir_1_1Layout}{Layout} for scalar is defined, while both its name and axes have size 0. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LayoutAxis}{Layout\+Axis}
\item 
class \hyperlink{classtvm_1_1tir_1_1LayoutNode}{Layout\+Node}
\item 
struct \hyperlink{structtvm_1_1tir_1_1LENode}{L\+E\+Node}
\begin{DoxyCompactList}\small\item\em a $<$= b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LetNode}{Let\+Node}
\begin{DoxyCompactList}\small\item\em Let binding. Bind var to value then evaluate body. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LetStmtNode}{Let\+Stmt\+Node}
\begin{DoxyCompactList}\small\item\em Let binding, bind var to value, then run body. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LoadNode}{Load\+Node}
\begin{DoxyCompactList}\small\item\em Load the value from buffer\+\_\+var. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} represents function after lowering. This is the final IR representation before codegen. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LoweredFuncNode}{Lowered\+Func\+Node}
\begin{DoxyCompactList}\small\item\em Node container of \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1LTNode}{L\+T\+Node}
\begin{DoxyCompactList}\small\item\em a $<$ b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1MaxNode}{Max\+Node}
\begin{DoxyCompactList}\small\item\em max(a, b) \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1MinNode}{Min\+Node}
\begin{DoxyCompactList}\small\item\em min(a, b) \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ModNode}{Mod\+Node}
\begin{DoxyCompactList}\small\item\em a \% b in the C semnatics. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1MulNode}{Mul\+Node}
\begin{DoxyCompactList}\small\item\em a $\ast$ b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1NENode}{N\+E\+Node}
\begin{DoxyCompactList}\small\item\em a != b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1NotNode}{Not\+Node}
\begin{DoxyCompactList}\small\item\em !a \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1OrNode}{Or\+Node}
\begin{DoxyCompactList}\small\item\em a $\vert$$\vert$ b \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1PrefetchNode}{Prefetch\+Node}
\begin{DoxyCompactList}\small\item\em A prefetch hint of func. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func}
\begin{DoxyCompactList}\small\item\em Managed reference to \hyperlink{classtvm_1_1tir_1_1PrimFuncNode}{Prim\+Func\+Node}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1PrimFuncNode}{Prim\+Func\+Node}
\begin{DoxyCompactList}\small\item\em Primitive functions that contains T\+IR statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ProducerConsumerNode}{Producer\+Consumer\+Node}
\begin{DoxyCompactList}\small\item\em annotation node of producer/consumer relation. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ProvideNode}{Provide\+Node}
\begin{DoxyCompactList}\small\item\em Store value into mult-\/dimensional array defined by func. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1RampNode}{Ramp\+Node}
\begin{DoxyCompactList}\small\item\em Construct a vector with lanes elements where its i-\/th element equals base + i $\ast$ stride. This is useful to construct a index for a continuous vector load. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1RealizeNode}{Realize\+Node}
\begin{DoxyCompactList}\small\item\em Annotate the bounds where func need to be written and read in body. We will need to allocate space for the corresponding regions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ReduceNode}{Reduce\+Node}
\begin{DoxyCompactList}\small\item\em Reduction operator operator. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SelectNode}{Select\+Node}
\begin{DoxyCompactList}\small\item\em return true\+\_\+value if condition is true, otherwise return false\+\_\+value. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SeqStmt}{Seq\+Stmt}
\begin{DoxyCompactList}\small\item\em Sequence statement. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SeqStmtNode}{Seq\+Stmt\+Node}
\begin{DoxyCompactList}\small\item\em The container of seq statement. Represent a sequence of statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1ShuffleNode}{Shuffle\+Node}
\begin{DoxyCompactList}\small\item\em Shuffle instruction. vec = concat(vectors) result = (vec\mbox{[}indices\mbox{[}0\mbox{]}\mbox{]}, vec\mbox{[}indices\mbox{[}1\mbox{]}\mbox{]} ...) \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SizeVar}{Size\+Var}
\begin{DoxyCompactList}\small\item\em a named variable represents a tensor index size \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SizeVarNode}{Size\+Var\+Node}
\begin{DoxyCompactList}\small\item\em A variable node represent a tensor index size, whose value must be non-\/negative. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt}
\begin{DoxyCompactList}\small\item\em Container of all statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtExprMutator}{Stmt\+Expr\+Mutator}
\begin{DoxyCompactList}\small\item\em Mutator that recursively mutates stmts and exprs on them. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtExprVisitor}{Stmt\+Expr\+Visitor}
\begin{DoxyCompactList}\small\item\em Visitor that recursively visit stmts and exprs on them. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtFunctor}{Stmt\+Functor}
\begin{DoxyCompactList}\small\item\em Same as \hyperlink{classtvm_1_1tir_1_1ExprFunctor}{Expr\+Functor} except it is applied on statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4}{Stmt\+Functor$<$ R(const Stmt \&n, Args...\+args)$>$}
\item 
class \hyperlink{classtvm_1_1tir_1_1StmtMutator}{Stmt\+Mutator}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1StmtMutator}{Stmt\+Mutator} that mutates the statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtNode}{Stmt\+Node}
\begin{DoxyCompactList}\small\item\em Base node of all statements. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StmtVisitor}{Stmt\+Visitor}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1tir_1_1StmtVisitor}{Stmt\+Visitor}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StoreNode}{Store\+Node}
\begin{DoxyCompactList}\small\item\em Store value to the buffer. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1StringImm}{String\+Imm}
\item 
class \hyperlink{classtvm_1_1tir_1_1StringImmNode}{String\+Imm\+Node}
\begin{DoxyCompactList}\small\item\em String constants, only used in asserts. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1SubNode}{Sub\+Node}
\begin{DoxyCompactList}\small\item\em a -\/ b \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1tir_1_1TensorKey}{Tensor\+Key}
\begin{DoxyCompactList}\small\item\em Auxiliary data structure used in IR Pass to indicate a tensor. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1Var}{Var}
\begin{DoxyCompactList}\small\item\em a named variable in T\+VM \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1tir_1_1VarNode}{Var\+Node}
\begin{DoxyCompactList}\small\item\em A variable node in the IR. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacetvm_1_1tir_a8277e2a3d81a80a4776705673df51e0a}{Region} = \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1Range}{Range} $>$
\item 
using \hyperlink{namespacetvm_1_1tir_aa177c432dd27540d34b22c05559324ab}{Domain} = \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1Range}{Range} $>$
\item 
using \hyperlink{namespacetvm_1_1tir_ae8c7db788e840dc1c2ed1f365d5ea829}{Int\+Imm\+Node} = \hyperlink{classtvm_1_1IntImmNode}{tvm\+::\+Int\+Imm\+Node}
\item 
using \hyperlink{namespacetvm_1_1tir_adb123be81447d2871f4c716ce2d1dc00}{Float\+Imm\+Node} = \hyperlink{classtvm_1_1FloatImmNode}{tvm\+::\+Float\+Imm\+Node}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1}{Buffer\+Type} \+: int \{ \hyperlink{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39}{k\+Default} = 1, 
\hyperlink{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663}{k\+Auto\+Broadcast} = 2
 \}\begin{DoxyCompactList}\small\item\em buffer type \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358e}{Iter\+Var\+Type} \+: int \{ \\*
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422}{k\+Data\+Par} = 0, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0}{k\+Thread\+Index} = 1, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4}{k\+Comm\+Reduce} = 2, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b}{k\+Ordered} = 3, 
\\*
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c}{k\+Opaque} = 4, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403}{k\+Unrolled} = 5, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd}{k\+Vectorized} = 6, 
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652}{k\+Parallelized} = 7, 
\\*
\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47}{k\+Tensorized} = 8
 \}\begin{DoxyCompactList}\small\item\em Type of iteration variable. Each Iter\+Var have a specific type. \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66}{Lowered\+Func\+Type} \+: int \{ \hyperlink{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9}{k\+Mixed\+Func} = 0, 
\hyperlink{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858}{k\+Host\+Func} = 1, 
\hyperlink{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628}{k\+Device\+Func} = 2
 \}\begin{DoxyCompactList}\small\item\em specific type of lowered function \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736}{For\+Type} \+: int \{ \hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493}{For\+Type\+::\+Serial} = 0, 
\hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131}{For\+Type\+::\+Parallel} = 1, 
\hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725}{For\+Type\+::\+Vectorized} = 2, 
\hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac}{For\+Type\+::\+Unrolled} = 3
 \}\begin{DoxyCompactList}\small\item\em Additional annotation of for loop. \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019}{Device\+A\+PI} \+: int \{ \hyperlink{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754}{Device\+A\+P\+I\+::\+None} = 0
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} \hyperlink{namespacetvm_1_1tir_a9b3692f3f081d3b5b84a24cf8082141e}{decl\+\_\+buffer} (\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ shape, \hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} dtype=\hyperlink{classtvm_1_1runtime_1_1DataType_a237a714a6a16e14aa01fa4ac52426551}{Data\+Type\+::\+Float}(32), std\+::string name=\char`\"{}buffer\char`\"{})
\begin{DoxyCompactList}\small\item\em Construct a new buffer given shape, and dtype. \end{DoxyCompactList}\item 
const char $\ast$ \hyperlink{namespacetvm_1_1tir_afc0fdee9fc81462318d59dbe64c8df26}{Iter\+Var\+Type2\+String} (\hyperlink{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358e}{Iter\+Var\+Type} t)
\item 
{\footnotesize template$<$typename K , typename V $>$ }\\std\+::unordered\+\_\+map$<$ K, V $>$ \hyperlink{namespacetvm_1_1tir_abb777c4f4d61883c0cbdf9116458b70d}{as\+\_\+unordered\+\_\+map} (const \hyperlink{classtvm_1_1Map}{Map}$<$ K, V $>$ \&dmap)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_a923d1bb833c984008772782e90cda37a}{Simplify} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} expr, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$ vrange=\hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$())
\begin{DoxyCompactList}\small\item\em Simplify the expression. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a49287db98b766f8900dbbfcc466cb596}{Simplify} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$ vrange=\hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$())
\begin{DoxyCompactList}\small\item\em Simplify the statement. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_ae3f7ea11fa82b0cb4a990f51beaa5203}{Canonical\+Simplify} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$ vrange=\hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$())
\begin{DoxyCompactList}\small\item\em Simplify by applying canonical form. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_a6a22160396635ce8b681f3aaed32df5b}{Canonical\+Simplify} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} expr, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$ vrange=\hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1Range}{Range} $>$())
\begin{DoxyCompactList}\small\item\em Simplify by applying canonical form. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_ae9b75fe00e0f29e2cc8e2b3ffe541ff4}{Equal} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&lhs, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&rhs)
\begin{DoxyCompactList}\small\item\em Deep compare lhs and rhs. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_af7135e786c567aacc96fa95bac4dae4b}{Equal} (const \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \&lhs, const \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \&rhs)
\begin{DoxyCompactList}\small\item\em Deep compare lhs and rhs. \end{DoxyCompactList}\item 
int \hyperlink{namespacetvm_1_1tir_a388b768f462e6699d061b5ea3ca87616}{Compare} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&lhs, const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&rhs)
\begin{DoxyCompactList}\small\item\em Deep compare lhs and rhs. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_ae4506ebe76b8f44653dafdf0aef263f1}{Verify\+S\+SA} (const \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \&ir)
\begin{DoxyCompactList}\small\item\em verifies whether the IR stmt or Expr is in S\+SA form. That is\+: each Var\+Expr is defined and assigned once(in Let/\+For) \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a93a2b6c1ea585d4cfd12539e65f48fdb}{Has\+Side\+Effect} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&e)
\begin{DoxyCompactList}\small\item\em Whether the expression have side effect. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a2a95f59679b6acbb47ab488a1e2c6b09}{Expr\+Use\+Var} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&e, const \hyperlink{classtvm_1_1tir_1_1Var}{Var} \&v)
\begin{DoxyCompactList}\small\item\em Whether e expression used var. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_ae82ce8b3c5f0cd3a8213b90153637177}{Expr\+Use\+Var} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&e, const std\+::unordered\+\_\+set$<$ const \hyperlink{classtvm_1_1tir_1_1VarNode}{Var\+Node} $\ast$ $>$ \&vset)
\begin{DoxyCompactList}\small\item\em Whether e expression used any var in variable set.. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_afdbcd71b66872684f3dc873b9380520f}{Convert\+S\+SA} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Convert a IR node to be S\+SA form. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a4b122873fd63b721684ffb4cd9913bb4}{Substitute} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, const std\+::unordered\+\_\+map$<$ const \hyperlink{classtvm_1_1tir_1_1VarNode}{Var\+Node} $\ast$, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ \&value\+\_\+map)
\begin{DoxyCompactList}\small\item\em Substitute the var specified in key-\/$>$var to be value. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_a1753495736a7c0ab703ed01c673ec5d0}{Substitute} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} expr, const std\+::unordered\+\_\+map$<$ const \hyperlink{classtvm_1_1tir_1_1VarNode}{Var\+Node} $\ast$, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ \&value\+\_\+map)
\begin{DoxyCompactList}\small\item\em Substitute the var specified in key-\/$>$var to be value. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_abc79c4131e8b95c4ae4be56d4ab3c494}{Substitute} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, const \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ \&value\+\_\+map)
\begin{DoxyCompactList}\small\item\em Substitute the var specified in key-\/$>$var to be value. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_a34e6a1e27339fcc255f664dd14e7c6cc}{Substitute} (\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} expr, const \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var}, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ \&value\+\_\+map)
\begin{DoxyCompactList}\small\item\em Substitute the var specified in key-\/$>$var to be value. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a96379de32bcde10449bdb01b9b816e99}{Inline} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1tir_1_1FunctionRef}{Function\+Ref} f, \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var} $>$ args, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} body)
\begin{DoxyCompactList}\small\item\em inline all calls of f in stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a2c63e0decac1e98ee375d32dee15526e}{Storage\+Flatten} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1te_1_1Tensor}{te\+::\+Tensor}, \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} $>$ extern\+\_\+buffer, int cache\+\_\+line\+\_\+size, bool create\+\_\+bound\+\_\+attribute=false)
\begin{DoxyCompactList}\small\item\em Flatten the multi-\/dimensional read/write to single dimensional Load/\+Store. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a00e711fe4801fd2d11f85cb64bc64d56}{Rewrite\+For\+Tensor\+Core} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1te_1_1Schedule}{te\+::\+Schedule} schedule, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1te_1_1Tensor}{te\+::\+Tensor}, \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} $>$ extern\+\_\+buffer)
\begin{DoxyCompactList}\small\item\em Try to modify the A\+ST to support Tensor\+Core. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_ae892521d99d9475a59e2d01df9413b49}{Verify\+Compact\+Buffer} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Verify if there is any argument bound to compact buffer. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a64dd52c904c2944a4771b81a2cf8f08a}{Remove\+No\+Op} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Remove No \hyperlink{classtvm_1_1Op}{Op} from the \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt}. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a319c8f6b65c8c053c87b429d6d791343}{Unroll\+Loop} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, int auto\+\_\+max\+\_\+step, int auto\+\_\+max\+\_\+depth, int auto\+\_\+max\+\_\+extent, bool explicit\+\_\+unroll)
\begin{DoxyCompactList}\small\item\em unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_abdd6d56877b9dd03803f433352b09060}{Vectorize\+Loop} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em vectorize the constant loops \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a2f8fc7370ebc9a6b0de19ae9e597576f}{Skip\+Vectorize} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em convert vectorized loops into serialized loops \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a604c5a3e5e7fad62a912b1d3bb41c3fa}{Instrument\+Bound\+Checkers} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em instruments bound checkers. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a8c9c2135e4a2a674c7ffe1f414d9b362}{Inject\+Virtual\+Thread} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Inject virtual thread loops into stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a1d45de8cf5b6053ab16dde307a00238d}{Inject\+Prefetch} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Inject prefetch instructions into stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_abde051e07d9c7ba41d5676ce64208766}{Inject\+Double\+Buffer} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, int split\+\_\+loop)
\begin{DoxyCompactList}\small\item\em Inject double buffer into stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a3550907081d6332c5a4b0849e1948c79}{Inject\+Copy\+Intrin} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, const std\+::string \&pragma\+\_\+key, const \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{runtime\+::\+Packed\+Func} \&fintrin)
\begin{DoxyCompactList}\small\item\em Inject copy intrinsics with optional pad. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a5b70ca88f988211332570160c82e3026}{Storage\+Rewrite} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_ae0606ab38faf2f31d42759f217fdec93}{Loop\+Partition} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, bool split\+\_\+const\+\_\+loop)
\begin{DoxyCompactList}\small\item\em partition loops in the stmt \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a9a890acc3681867fe74ad2207d17278f}{Co\+Proc\+Sync} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Detect and insert sync points to co-\/processor. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a799dff4f3a280576d6838694c151e657}{Lift\+Attr\+Scope} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, std\+::string attr\+\_\+key)
\begin{DoxyCompactList}\small\item\em Lift common attrs with attr\+\_\+key to outer scope. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a2c3a142f48991df5a96ee1791685ca64}{Rewrite\+Unsafe\+Select} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Detect and rewrite unsafe select that contains memory access. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a3b6c7e53cce5184e897b0bd24adb06b6}{Lower\+Storage\+Access\+Info} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Lower attached storage access information. Do this pass after all storage access analysis finish. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a1f89ddc934004f9e58b2e6ac3a260e3d}{Decorate\+Device\+Scope} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a803eaac5980c445a9ff8e38fb2c595fa}{Hoist\+If\+Then\+Else} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt)
\begin{DoxyCompactList}\small\item\em Loop invariant code motion which locates and hoists if statements. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_ab2d44994c14f11c500586a007c782c84}{Make\+A\+PI} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} body, std\+::string name, \hyperlink{classtvm_1_1Array}{Array}$<$ Object\+Ref $>$ api\+\_\+args, int num\+\_\+unpacked\+\_\+args, bool is\+\_\+restricted)
\begin{DoxyCompactList}\small\item\em Make an user callable A\+PI \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func}. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_a1ac3af6813bf02262470992a3980a25a}{Bind\+Device\+Type} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} func, int device\+\_\+type)
\begin{DoxyCompactList}\small\item\em Bind the device type of host function to be device\+\_\+type. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var} $>$ \hyperlink{namespacetvm_1_1tir_ae110e02855d8bc12eb8b6f92ed391844}{Undefined\+Vars} (const \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \&stmt, const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1Var}{Var} $>$ \&defs)
\begin{DoxyCompactList}\small\item\em Find undefined vars in the statment. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} $>$ \hyperlink{namespacetvm_1_1tir_ac7f5e04aea66d87ad42baf957768c451}{Split\+Host\+Device} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} func)
\begin{DoxyCompactList}\small\item\em Split the function into a host function and device functions. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_ab0df6d882d69f4ec8e1b146a0d8728f9}{Thread\+Sync} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} stmt, std\+::string storage\+\_\+scope)
\begin{DoxyCompactList}\small\item\em Insert sync between parallel read/write of shared buffers. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_a438729b72b0e38a28289d763b48995b1}{Lower\+Thread\+Allreduce} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f, int warp\+\_\+size)
\begin{DoxyCompactList}\small\item\em Lower cross thread alleduce in the stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_af5111eb3e9b9d2f52998c5db4b4e3ae9}{Lower\+Warp\+Memory} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f, int warp\+\_\+size)
\begin{DoxyCompactList}\small\item\em Lower warp memory in stmt. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_ad55f17f026155f1424b3d0fdd3f86435}{Remap\+Thread\+Axis} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f, \hyperlink{classtvm_1_1Map}{Map}$<$ \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr}, \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} $>$ axis\+\_\+map)
\begin{DoxyCompactList}\small\item\em Remap the thread axis. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_a9d59ba0cb48da1661593b7eeb2e96821}{Lower\+T\+V\+M\+Builtin} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f)
\begin{DoxyCompactList}\small\item\em Lower packed function call. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_a5c2b224ff5bb292b1b7e677d50576b38}{Combine\+Context\+Call} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f)
\begin{DoxyCompactList}\small\item\em Combine context function calls. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_ad2814a5568d2e1329a5c5aab2e35091e}{Pointer\+Value\+Type\+Rewrite} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f)
\begin{DoxyCompactList}\small\item\em Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func} \hyperlink{namespacetvm_1_1tir_abbf2681c6850628b3c9b213298f056b3}{Pointer\+Value\+Type\+Rewrite} (\hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func} f)
\begin{DoxyCompactList}\small\item\em Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_afcbd367b40fe2cd31d101c88a63a0b25}{Lower\+Device\+Storage\+Access\+Info} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} func)
\begin{DoxyCompactList}\small\item\em Lower attached storage access information on device. Do this pass after all storage access analysis finish. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_adb8b5d13c11411299808c564adda2713}{Lower\+Intrin} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f, const std\+::string \&target)
\begin{DoxyCompactList}\small\item\em Lower intrinsic function calls. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_ac8725d2ad12962353ec11b6285cc6b3d}{Lower\+Custom\+Datatypes} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f, const std\+::string \&target)
\begin{DoxyCompactList}\small\item\em Lower custom datatypes. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_acd928ded601486ae3a3b787df3f09688}{Infer\+Fragment} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f)
\begin{DoxyCompactList}\small\item\em Infer the Tensor\+Core fragment infomation using tensor intrinsics. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} \hyperlink{namespacetvm_1_1tir_a9968b6563c42117a9a1cd4576054400f}{Skip\+Assert} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} f)
\begin{DoxyCompactList}\small\item\em skip assert stmt generation \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_aa649448c69d8324ba1fd7ec5e3e54731}{Verify\+Memory} (\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} func, int device\+\_\+type)
\begin{DoxyCompactList}\small\item\em Verify if memory accesses are legal for a specific target device type. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a705b3e58180a12eba5297cb2442fd1a2}{Verify\+G\+P\+U\+Code} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} stmt, \hyperlink{classtvm_1_1Map}{Map}$<$ std\+::string, \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ constraints)
\begin{DoxyCompactList}\small\item\em Verify the correctness of a G\+PU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Value\+Type , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+pod$<$\+Value\+Type$>$\+::value$>$\+::type$>$ }\\\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_a4ea566597880d04bd62fbec687e338b5}{make\+\_\+const} (\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} t, Value\+Type value)
\begin{DoxyCompactList}\small\item\em Make a const value with certain data type. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_adc4408508a413fb7f3b2567f8d847dbb}{make\+\_\+zero} (\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} t)
\begin{DoxyCompactList}\small\item\em Make a const zero expr. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_ac40c127b53bca09d4c39f806a98dfdf8}{const\+\_\+true} (int lanes=1)
\begin{DoxyCompactList}\small\item\em Make a constant true expression. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_ae11cb5c6f810546e5aa4e08a0684071a}{const\+\_\+false} (int lanes=1)
\begin{DoxyCompactList}\small\item\em Make a constant false expression. \end{DoxyCompactList}\item 
const int64\+\_\+t $\ast$ \hyperlink{namespacetvm_1_1tir_acbe8f225faaf34c540194921a7ee6a66}{as\+\_\+const\+\_\+int} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x)
\begin{DoxyCompactList}\small\item\em Get x as constant int expression. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a5c414d5e54c099ad7287be302aac8f02}{is\+\_\+const\+\_\+int} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x, int64\+\_\+t value)
\begin{DoxyCompactList}\small\item\em Check whether x is a constant integer expression. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a8de8f843c6eb433b6ddfbf34e24099ef}{is\+\_\+no\+\_\+op} (const \hyperlink{classtvm_1_1tir_1_1Stmt}{tir\+::\+Stmt} \&stmt)
\begin{DoxyCompactList}\small\item\em Check whether stmt is nop. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a9b5104dcf0933da31329bb0b2580a947}{is\+\_\+one} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x)
\begin{DoxyCompactList}\small\item\em Check whether x is a constant integer 1. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a48bad3db162b334837716bf8e7ba9285}{is\+\_\+zero} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x)
\begin{DoxyCompactList}\small\item\em Check whether x is a constant integer 0. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_ab706ef9860459b25068f3440d88a7193}{is\+\_\+const} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x)
\begin{DoxyCompactList}\small\item\em Check whether x is a constant. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a246623a4a0c9cd8f8a209ec952a8d1c3}{is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&x, int $\ast$shift)
\begin{DoxyCompactList}\small\item\em Check whether x is a constant power of two If x is power of two, write the power to the shift. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1tir_a782dc226f8b2b537efdc56b1f76351d1}{is\+\_\+positive\+\_\+const} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a)
\item 
bool \hyperlink{namespacetvm_1_1tir_a51d552441331effb387b7c8fb241c454}{is\+\_\+negative\+\_\+const} (const \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \&a)
\item 
{\footnotesize template$<$typename Value\+Type $>$ }\\\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_af2ca71170aca9d397c2125eb4f55c197}{Make\+Const\+Scalar} (\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} t, Value\+Type value)
\item 
\hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} \hyperlink{namespacetvm_1_1tir_afb1743e78389c4beaf0b788c631d424e}{Type\+Annotation} (\hyperlink{namespacetvm_a41918af1a1dc386388639a9d3ad06c5d}{Data\+Type} dtype)
\begin{DoxyCompactList}\small\item\em Create a type annotation expression. \end{DoxyCompactList}\item 
std\+::ostream \& \hyperlink{namespacetvm_1_1tir_a12a98cd1a8440b18d6bac0ad3eaa42ed}{operator$<$$<$} (std\+::ostream \&os, \hyperlink{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736}{For\+Type} for\+\_\+type)
\item 
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} \hyperlink{namespacetvm_1_1tir_a1217dd1b57e84b5901cf755251b9e164}{I\+R\+Transform} (\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} node, const \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{runtime\+::\+Packed\+Func} \&preorder, const \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{runtime\+::\+Packed\+Func} \&postorder, const \hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1PrimExpr}{Prim\+Expr} $>$ \&only\+\_\+enable=\{\})
\begin{DoxyCompactList}\small\item\em recursively visit the ir in post D\+FS order node, and transform it \end{DoxyCompactList}\item 
void \hyperlink{namespacetvm_1_1tir_a4b5067fa233d111c9db9cc402ed599c3}{Post\+Order\+Visit} (const Object\+Ref \&node, std\+::function$<$ void(const Object\+Ref \&)$>$ fvisit)
\begin{DoxyCompactList}\small\item\em recursively visit the ir in post D\+FS order node, apply fvisit Each node is guaranteed to be visited only once. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{tvm\+::tir@{tvm\+::tir}!Domain@{Domain}}
\index{Domain@{Domain}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Domain}{Domain}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::tir\+::\+Domain} = typedef {\bf Array}$<${\bf Range}$>$}\hypertarget{namespacetvm_1_1tir_aa177c432dd27540d34b22c05559324ab}{}\label{namespacetvm_1_1tir_aa177c432dd27540d34b22c05559324ab}
\index{tvm\+::tir@{tvm\+::tir}!Float\+Imm\+Node@{Float\+Imm\+Node}}
\index{Float\+Imm\+Node@{Float\+Imm\+Node}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Float\+Imm\+Node}{FloatImmNode}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::tir\+::\+Float\+Imm\+Node} = typedef {\bf tvm\+::\+Float\+Imm\+Node}}\hypertarget{namespacetvm_1_1tir_adb123be81447d2871f4c716ce2d1dc00}{}\label{namespacetvm_1_1tir_adb123be81447d2871f4c716ce2d1dc00}
\index{tvm\+::tir@{tvm\+::tir}!Int\+Imm\+Node@{Int\+Imm\+Node}}
\index{Int\+Imm\+Node@{Int\+Imm\+Node}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Int\+Imm\+Node}{IntImmNode}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::tir\+::\+Int\+Imm\+Node} = typedef {\bf tvm\+::\+Int\+Imm\+Node}}\hypertarget{namespacetvm_1_1tir_ae8c7db788e840dc1c2ed1f365d5ea829}{}\label{namespacetvm_1_1tir_ae8c7db788e840dc1c2ed1f365d5ea829}
\index{tvm\+::tir@{tvm\+::tir}!Region@{Region}}
\index{Region@{Region}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Region}{Region}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::tir\+::\+Region} = typedef {\bf Array}$<${\bf Range}$>$}\hypertarget{namespacetvm_1_1tir_a8277e2a3d81a80a4776705673df51e0a}{}\label{namespacetvm_1_1tir_a8277e2a3d81a80a4776705673df51e0a}


\subsection{Enumeration Type Documentation}
\index{tvm\+::tir@{tvm\+::tir}!Buffer\+Type@{Buffer\+Type}}
\index{Buffer\+Type@{Buffer\+Type}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Buffer\+Type}{BufferType}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::tir\+::\+Buffer\+Type} \+: int}\hypertarget{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1}{}\label{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1}


buffer type 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Default@{k\+Default}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Default@{k\+Default}}\item[{\em 
k\+Default\hypertarget{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39}{}\label{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a4500370408bf0077c86a795cbe9dbf39}
}]\index{k\+Auto\+Broadcast@{k\+Auto\+Broadcast}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Auto\+Broadcast@{k\+Auto\+Broadcast}}\item[{\em 
k\+Auto\+Broadcast\hypertarget{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663}{}\label{namespacetvm_1_1tir_a9ac05a14db42ca73da1d3945e7ce2fd1a08cd53d61aa635081a2f7a0597025663}
}]\end{description}
\end{Desc}
\index{tvm\+::tir@{tvm\+::tir}!Device\+A\+PI@{Device\+A\+PI}}
\index{Device\+A\+PI@{Device\+A\+PI}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Device\+A\+PI}{DeviceAPI}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::tir\+::\+Device\+A\+PI} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\hypertarget{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019}{}\label{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{None@{None}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!None@{None}}\item[{\em 
None\hypertarget{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754}{}\label{namespacetvm_1_1tir_aed067b57db2923a07913239b2165e019a6adf97f83acf6453d4a6a4b1070f3754}
}]\end{description}
\end{Desc}
\index{tvm\+::tir@{tvm\+::tir}!For\+Type@{For\+Type}}
\index{For\+Type@{For\+Type}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{For\+Type}{ForType}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::tir\+::\+For\+Type} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\hypertarget{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736}{}\label{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736}


Additional annotation of for loop. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Serial@{Serial}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!Serial@{Serial}}\item[{\em 
Serial\hypertarget{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493}{}\label{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a5255d3daaa0a6276b844d61401e6f493}
}]serial execution. \index{Parallel@{Parallel}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!Parallel@{Parallel}}\item[{\em 
Parallel\hypertarget{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131}{}\label{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a98402eecfbcefc336954458a01752131}
}]parallel execution on C\+PU. \index{Vectorized@{Vectorized}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!Vectorized@{Vectorized}}\item[{\em 
Vectorized\hypertarget{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725}{}\label{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736a138bc087eaaaf426b54f9a466f0cc725}
}]Vector S\+I\+MD loop annotaion. \index{Unrolled@{Unrolled}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!Unrolled@{Unrolled}}\item[{\em 
Unrolled\hypertarget{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac}{}\label{namespacetvm_1_1tir_ae35cce8e3f1e8d7366dc0d9b15536736ae53597647de81f4cc9e098fc119ba0ac}
}]Unroll annotation. \end{description}
\end{Desc}
\index{tvm\+::tir@{tvm\+::tir}!Iter\+Var\+Type@{Iter\+Var\+Type}}
\index{Iter\+Var\+Type@{Iter\+Var\+Type}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Iter\+Var\+Type}{IterVarType}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::tir\+::\+Iter\+Var\+Type} \+: int}\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358e}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358e}


\hyperlink{classtvm_1_1Type}{Type} of iteration variable. Each \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} have a specific type. 

The type of iter var can be overriden via stage.\+iter\+\_\+var\+\_\+attrs given they are compatible. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Data\+Par@{k\+Data\+Par}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Data\+Par@{k\+Data\+Par}}\item[{\em 
k\+Data\+Par\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea943fcb20375772edb59ea948f6cc9422}
}]Data parallel iteration. This normally corresponds to axis of Tensor. Allow all \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} manipulations. \begin{DoxyNote}{Note}
This does not mean the loop have to be executed in parallel fashion. 
\end{DoxyNote}
\index{k\+Thread\+Index@{k\+Thread\+Index}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Thread\+Index@{k\+Thread\+Index}}\item[{\em 
k\+Thread\+Index\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea2758d2f7912af847eff77105023a25d0}
}]The \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} itself is a thread-\/index of a fixed thread launching group. Note that this is already assumed to be paralellized. Disallow\+: split/fuse/vectorize/parallel \index{k\+Comm\+Reduce@{k\+Comm\+Reduce}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Comm\+Reduce@{k\+Comm\+Reduce}}\item[{\em 
k\+Comm\+Reduce\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eac78682fe1cb0a6de8511f2fc5144c0b4}
}]Communicative reduction. Cannot be directly parallelized. Disallow\+: parallel/vectorize \index{k\+Ordered@{k\+Ordered}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Ordered@{k\+Ordered}}\item[{\em 
k\+Ordered\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaba48cf32065b1bf9086138313912f64b}
}]Serial loops with loop carry dependency, the iteration must execute in order. Cannot be re-\/ordered. Disallow\+: reorder/parallel/vectorize \index{k\+Opaque@{k\+Opaque}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Opaque@{k\+Opaque}}\item[{\em 
k\+Opaque\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eaf324873e6195114a186db7f910559b2c}
}]\hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} is opaque,. May not corresponds to any generated loop Disallow all \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} manipulations and compute\+\_\+at

\begin{DoxyNote}{Note}
This is usually used to implement composite op or external op, where the 
\end{DoxyNote}
\index{k\+Unrolled@{k\+Unrolled}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Unrolled@{k\+Unrolled}}\item[{\em 
k\+Unrolled\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea37ab325f4c3ab1d2a905cbfe546bc403}
}]The execution is unrolled. \index{k\+Vectorized@{k\+Vectorized}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Vectorized@{k\+Vectorized}}\item[{\em 
k\+Vectorized\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea1d03c8fa5be7edb0032b8155736239bd}
}]The loop is vectorized. \index{k\+Parallelized@{k\+Parallelized}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Parallelized@{k\+Parallelized}}\item[{\em 
k\+Parallelized\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358eae12eb286fbc36da6dd2e4775a1306652}
}]The loop is parallelized. \index{k\+Tensorized@{k\+Tensorized}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Tensorized@{k\+Tensorized}}\item[{\em 
k\+Tensorized\hypertarget{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47}{}\label{namespacetvm_1_1tir_add7d0a6b1dd91f0c3c5dd2f4cf64358ea772fdb24758cfac34cb164be343abb47}
}]Marks boundary of tensorization intrinsic. \end{description}
\end{Desc}
\index{tvm\+::tir@{tvm\+::tir}!Lowered\+Func\+Type@{Lowered\+Func\+Type}}
\index{Lowered\+Func\+Type@{Lowered\+Func\+Type}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lowered\+Func\+Type}{LoweredFuncType}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::tir\+::\+Lowered\+Func\+Type} \+: int}\hypertarget{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66}{}\label{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66}


specific type of lowered function 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Mixed\+Func@{k\+Mixed\+Func}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Mixed\+Func@{k\+Mixed\+Func}}\item[{\em 
k\+Mixed\+Func\hypertarget{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9}{}\label{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66accd368fda1b61f733343349a79cf2ca9}
}]Function that can mix device and host calls. \index{k\+Host\+Func@{k\+Host\+Func}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Host\+Func@{k\+Host\+Func}}\item[{\em 
k\+Host\+Func\hypertarget{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858}{}\label{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66acf71d9235254aaaf4856732d6f743858}
}]Only contains host code. \index{k\+Device\+Func@{k\+Device\+Func}!tvm\+::tir@{tvm\+::tir}}\index{tvm\+::tir@{tvm\+::tir}!k\+Device\+Func@{k\+Device\+Func}}\item[{\em 
k\+Device\+Func\hypertarget{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628}{}\label{namespacetvm_1_1tir_a69f0089a367b98e377b652186fa7dc66a6280765ba977e1b1b059d48dd508a628}
}]Only contains device code. \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{tvm\+::tir@{tvm\+::tir}!as\+\_\+const\+\_\+int@{as\+\_\+const\+\_\+int}}
\index{as\+\_\+const\+\_\+int@{as\+\_\+const\+\_\+int}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{as\+\_\+const\+\_\+int(const Prim\+Expr \&x)}{as_const_int(const PrimExpr &x)}}]{\setlength{\rightskip}{0pt plus 5cm}const int64\+\_\+t$\ast$ tvm\+::tir\+::as\+\_\+const\+\_\+int (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_acbe8f225faaf34c540194921a7ee6a66}{}\label{namespacetvm_1_1tir_acbe8f225faaf34c540194921a7ee6a66}


Get x as constant int expression. 


\begin{DoxyParams}{Parameters}
{\em x} & The expression \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the address to the int expression, return nullptr, if x is not \hyperlink{classtvm_1_1IntImm}{Int\+Imm}. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!as\+\_\+unordered\+\_\+map@{as\+\_\+unordered\+\_\+map}}
\index{as\+\_\+unordered\+\_\+map@{as\+\_\+unordered\+\_\+map}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{as\+\_\+unordered\+\_\+map(const Map$<$ K, V $>$ \&dmap)}{as_unordered_map(const Map< K, V > &dmap)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename K , typename V $>$ std\+::unordered\+\_\+map$<$K, V$>$ tvm\+::tir\+::as\+\_\+unordered\+\_\+map (
\begin{DoxyParamCaption}
\item[{const {\bf Map}$<$ K, V $>$ \&}]{dmap}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_abb777c4f4d61883c0cbdf9116458b70d}{}\label{namespacetvm_1_1tir_abb777c4f4d61883c0cbdf9116458b70d}
\index{tvm\+::tir@{tvm\+::tir}!Bind\+Device\+Type@{Bind\+Device\+Type}}
\index{Bind\+Device\+Type@{Bind\+Device\+Type}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Bind\+Device\+Type(\+Lowered\+Func func, int device\+\_\+type)}{BindDeviceType(LoweredFunc func, int device_type)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Bind\+Device\+Type (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{func, }
\item[{int}]{device\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a1ac3af6813bf02262470992a3980a25a}{}\label{namespacetvm_1_1tir_a1ac3af6813bf02262470992a3980a25a}


Bind the device type of host function to be device\+\_\+type. 


\begin{DoxyParams}{Parameters}
{\em func} & The function to be binded. \\
\hline
{\em device\+\_\+type} & The device type to be binded. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The binded function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Canonical\+Simplify@{Canonical\+Simplify}}
\index{Canonical\+Simplify@{Canonical\+Simplify}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Canonical\+Simplify(\+Stmt stmt, Map$<$ Var, Range $>$ vrange=\+Map$<$ Var, Range $>$())}{CanonicalSimplify(Stmt stmt, Map< Var, Range > vrange=Map< Var, Range >())}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Canonical\+Simplify (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf Map}$<$ {\bf Var}, {\bf Range} $>$}]{vrange = {\ttfamily {\bf Map}$<$~{\bf Var},~{\bf Range}~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae3f7ea11fa82b0cb4a990f51beaa5203}{}\label{namespacetvm_1_1tir_ae3f7ea11fa82b0cb4a990f51beaa5203}


Simplify by applying canonical form. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be canonically simplifed. \\
\hline
{\em vrange} & The range information about the variable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Canonicalized statement. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Canonical\+Simplify@{Canonical\+Simplify}}
\index{Canonical\+Simplify@{Canonical\+Simplify}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Canonical\+Simplify(\+Prim\+Expr expr, Map$<$ Var, Range $>$ vrange=\+Map$<$ Var, Range $>$())}{CanonicalSimplify(PrimExpr expr, Map< Var, Range > vrange=Map< Var, Range >())}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::\+Canonical\+Simplify (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{expr, }
\item[{{\bf Map}$<$ {\bf Var}, {\bf Range} $>$}]{vrange = {\ttfamily {\bf Map}$<$~{\bf Var},~{\bf Range}~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a6a22160396635ce8b681f3aaed32df5b}{}\label{namespacetvm_1_1tir_a6a22160396635ce8b681f3aaed32df5b}


Simplify by applying canonical form. 


\begin{DoxyParams}{Parameters}
{\em expr} & The statement to be canonically simplifed. \\
\hline
{\em vrange} & The range information about the variable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Canonicalized expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Combine\+Context\+Call@{Combine\+Context\+Call}}
\index{Combine\+Context\+Call@{Combine\+Context\+Call}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Combine\+Context\+Call(\+Lowered\+Func f)}{CombineContextCall(LoweredFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Combine\+Context\+Call (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a5c2b224ff5bb292b1b7e677d50576b38}{}\label{namespacetvm_1_1tir_a5c2b224ff5bb292b1b7e677d50576b38}


Combine context function calls. 


\begin{DoxyParams}{Parameters}
{\em f} & The host function to be lowered. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Compare@{Compare}}
\index{Compare@{Compare}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Compare(const Prim\+Expr \&lhs, const Prim\+Expr \&rhs)}{Compare(const PrimExpr &lhs, const PrimExpr &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}int tvm\+::tir\+::\+Compare (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{lhs, }
\item[{const {\bf Prim\+Expr} \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a388b768f462e6699d061b5ea3ca87616}{}\label{namespacetvm_1_1tir_a388b768f462e6699d061b5ea3ca87616}


Deep compare lhs and rhs. 

If you only want equality comparison, use Equal which will also tie definitions. The compare mode will give order of expression in total order.


\begin{DoxyParams}{Parameters}
{\em lhs} & The left operand \\
\hline
{\em rhs} & The right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The comparison result. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!const\+\_\+false@{const\+\_\+false}}
\index{const\+\_\+false@{const\+\_\+false}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{const\+\_\+false(int lanes=1)}{const_false(int lanes=1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::const\+\_\+false (
\begin{DoxyParamCaption}
\item[{int}]{lanes = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_ae11cb5c6f810546e5aa4e08a0684071a}{}\label{namespacetvm_1_1tir_ae11cb5c6f810546e5aa4e08a0684071a}


Make a constant false expression. 


\begin{DoxyParams}{Parameters}
{\em lanes} & The number of lanes in the bool \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!const\+\_\+true@{const\+\_\+true}}
\index{const\+\_\+true@{const\+\_\+true}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{const\+\_\+true(int lanes=1)}{const_true(int lanes=1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::const\+\_\+true (
\begin{DoxyParamCaption}
\item[{int}]{lanes = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_ac40c127b53bca09d4c39f806a98dfdf8}{}\label{namespacetvm_1_1tir_ac40c127b53bca09d4c39f806a98dfdf8}


Make a constant true expression. 


\begin{DoxyParams}{Parameters}
{\em lanes} & The number of lanes in the bool \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Convert\+S\+SA@{Convert\+S\+SA}}
\index{Convert\+S\+SA@{Convert\+S\+SA}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Convert\+S\+S\+A(\+Stmt stmt)}{ConvertSSA(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Convert\+S\+SA (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_afdbcd71b66872684f3dc873b9380520f}{}\label{namespacetvm_1_1tir_afdbcd71b66872684f3dc873b9380520f}


Convert a IR node to be S\+SA form. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The source statement to be converted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted form. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Co\+Proc\+Sync@{Co\+Proc\+Sync}}
\index{Co\+Proc\+Sync@{Co\+Proc\+Sync}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Co\+Proc\+Sync(\+Stmt stmt)}{CoProcSync(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Co\+Proc\+Sync (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a9a890acc3681867fe74ad2207d17278f}{}\label{namespacetvm_1_1tir_a9a890acc3681867fe74ad2207d17278f}


Detect and insert sync points to co-\/processor. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be transformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!decl\+\_\+buffer@{decl\+\_\+buffer}}
\index{decl\+\_\+buffer@{decl\+\_\+buffer}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{decl\+\_\+buffer(\+Array$<$ Prim\+Expr $>$ shape, Data\+Type dtype=\+Data\+Type\+::\+Float(32), std\+::string name=""buffer"")}{decl_buffer(Array< PrimExpr > shape, DataType dtype=DataType::Float(32), std::string name="buffer")}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Buffer} tvm\+::tir\+::decl\+\_\+buffer (
\begin{DoxyParamCaption}
\item[{{\bf Array}$<$ {\bf Prim\+Expr} $>$}]{shape, }
\item[{{\bf Data\+Type}}]{dtype = {\ttfamily {\bf Data\+Type\+::\+Float}(32)}, }
\item[{std\+::string}]{name = {\ttfamily \char`\"{}buffer\char`\"{}}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a9b3692f3f081d3b5b84a24cf8082141e}{}\label{namespacetvm_1_1tir_a9b3692f3f081d3b5b84a24cf8082141e}


Construct a new buffer given shape, and dtype. 


\begin{DoxyParams}{Parameters}
{\em shape} & The shape of the buffer, \\
\hline
{\em dtype} & The content data type. \\
\hline
{\em name} & The name of the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The created buffer. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{classtvm_1_1tir_1_1BufferNode_abdf17916660dd43932e3f72958ca297d}{Buffer\+Node\+::make} for complete constructor. 
\end{DoxySeeAlso}
\index{tvm\+::tir@{tvm\+::tir}!Decorate\+Device\+Scope@{Decorate\+Device\+Scope}}
\index{Decorate\+Device\+Scope@{Decorate\+Device\+Scope}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Decorate\+Device\+Scope(\+Stmt stmt)}{DecorateDeviceScope(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Decorate\+Device\+Scope (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a1f89ddc934004f9e58b2e6ac3a260e3d}{}\label{namespacetvm_1_1tir_a1f89ddc934004f9e58b2e6ac3a260e3d}


Decorate the stmt with a device scope, this is helpful for hardware accelerator without thread blocks. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be transformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Equal@{Equal}}
\index{Equal@{Equal}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Equal(const Prim\+Expr \&lhs, const Prim\+Expr \&rhs)}{Equal(const PrimExpr &lhs, const PrimExpr &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Equal (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{lhs, }
\item[{const {\bf Prim\+Expr} \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae9b75fe00e0f29e2cc8e2b3ffe541ff4}{}\label{namespacetvm_1_1tir_ae9b75fe00e0f29e2cc8e2b3ffe541ff4}


Deep compare lhs and rhs. 


\begin{DoxyParams}{Parameters}
{\em lhs} & The left operand \\
\hline
{\em rhs} & The right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The comparison result. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Equal@{Equal}}
\index{Equal@{Equal}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Equal(const Stmt \&lhs, const Stmt \&rhs)}{Equal(const Stmt &lhs, const Stmt &rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Equal (
\begin{DoxyParamCaption}
\item[{const {\bf Stmt} \&}]{lhs, }
\item[{const {\bf Stmt} \&}]{rhs}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_af7135e786c567aacc96fa95bac4dae4b}{}\label{namespacetvm_1_1tir_af7135e786c567aacc96fa95bac4dae4b}


Deep compare lhs and rhs. 


\begin{DoxyParams}{Parameters}
{\em lhs} & The left operand \\
\hline
{\em rhs} & The right operand \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The comparison result. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Expr\+Use\+Var@{Expr\+Use\+Var}}
\index{Expr\+Use\+Var@{Expr\+Use\+Var}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Expr\+Use\+Var(const Prim\+Expr \&e, const Var \&v)}{ExprUseVar(const PrimExpr &e, const Var &v)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Expr\+Use\+Var (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{e, }
\item[{const {\bf Var} \&}]{v}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a2a95f59679b6acbb47ab488a1e2c6b09}{}\label{namespacetvm_1_1tir_a2a95f59679b6acbb47ab488a1e2c6b09}


Whether e expression used var. 


\begin{DoxyParams}{Parameters}
{\em e} & The expression to be checked. \\
\hline
{\em v} & The variable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether e uses v. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Expr\+Use\+Var@{Expr\+Use\+Var}}
\index{Expr\+Use\+Var@{Expr\+Use\+Var}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Expr\+Use\+Var(const Prim\+Expr \&e, const std\+::unordered\+\_\+set$<$ const Var\+Node $\ast$ $>$ \&vset)}{ExprUseVar(const PrimExpr &e, const std::unordered_set< const VarNode * > &vset)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Expr\+Use\+Var (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{e, }
\item[{const std\+::unordered\+\_\+set$<$ const {\bf Var\+Node} $\ast$ $>$ \&}]{vset}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae82ce8b3c5f0cd3a8213b90153637177}{}\label{namespacetvm_1_1tir_ae82ce8b3c5f0cd3a8213b90153637177}


Whether e expression used any var in variable set.. 


\begin{DoxyParams}{Parameters}
{\em e} & The expression to be checked. \\
\hline
{\em vset} & The variable set. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether e uses vset. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Has\+Side\+Effect@{Has\+Side\+Effect}}
\index{Has\+Side\+Effect@{Has\+Side\+Effect}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Has\+Side\+Effect(const Prim\+Expr \&e)}{HasSideEffect(const PrimExpr &e)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Has\+Side\+Effect (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{e}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a93a2b6c1ea585d4cfd12539e65f48fdb}{}\label{namespacetvm_1_1tir_a93a2b6c1ea585d4cfd12539e65f48fdb}


Whether the expression have side effect. 

\begin{DoxyReturn}{Returns}
whether expression have side effect 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Hoist\+If\+Then\+Else@{Hoist\+If\+Then\+Else}}
\index{Hoist\+If\+Then\+Else@{Hoist\+If\+Then\+Else}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Hoist\+If\+Then\+Else(\+Stmt stmt)}{HoistIfThenElse(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Hoist\+If\+Then\+Else (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a803eaac5980c445a9ff8e38fb2c595fa}{}\label{namespacetvm_1_1tir_a803eaac5980c445a9ff8e38fb2c595fa}


Loop invariant code motion which locates and hoists if statements. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to do if statement hoisting. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Infer\+Fragment@{Infer\+Fragment}}
\index{Infer\+Fragment@{Infer\+Fragment}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Infer\+Fragment(\+Lowered\+Func f)}{InferFragment(LoweredFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Infer\+Fragment (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_acd928ded601486ae3a3b787df3f09688}{}\label{namespacetvm_1_1tir_acd928ded601486ae3a3b787df3f09688}


Infer the Tensor\+Core fragment infomation using tensor intrinsics. 


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Inject\+Copy\+Intrin@{Inject\+Copy\+Intrin}}
\index{Inject\+Copy\+Intrin@{Inject\+Copy\+Intrin}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Inject\+Copy\+Intrin(\+Stmt stmt, const std\+::string \&pragma\+\_\+key, const runtime\+::\+Packed\+Func \&fintrin)}{InjectCopyIntrin(Stmt stmt, const std::string &pragma_key, const runtime::PackedFunc &fintrin)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Inject\+Copy\+Intrin (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{const std\+::string \&}]{pragma\+\_\+key, }
\item[{const {\bf runtime\+::\+Packed\+Func} \&}]{fintrin}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a3550907081d6332c5a4b0849e1948c79}{}\label{namespacetvm_1_1tir_a3550907081d6332c5a4b0849e1948c79}


Inject copy intrinsics with optional pad. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be transformed. \\
\hline
{\em pragma\+\_\+key} & The pragma key for hint of copy. \\
\hline
{\em fintrin} & The function with signature\\
\hline
\end{DoxyParams}
\hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} fintrin(\hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} src, \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} dst, Array$<$\+Expr$>$ pad\+\_\+before, Array$<$\+Expr$>$ pad\+\_\+after, Expr pad\+\_\+value) \begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Inject\+Double\+Buffer@{Inject\+Double\+Buffer}}
\index{Inject\+Double\+Buffer@{Inject\+Double\+Buffer}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Inject\+Double\+Buffer(\+Stmt stmt, int split\+\_\+loop)}{InjectDoubleBuffer(Stmt stmt, int split_loop)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Inject\+Double\+Buffer (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{int}]{split\+\_\+loop}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_abde051e07d9c7ba41d5676ce64208766}{}\label{namespacetvm_1_1tir_abde051e07d9c7ba41d5676ce64208766}


Inject double buffer into stmt. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be transformed. \\
\hline
{\em split\+\_\+loop} & Loop splitting factor. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Inject\+Prefetch@{Inject\+Prefetch}}
\index{Inject\+Prefetch@{Inject\+Prefetch}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Inject\+Prefetch(\+Stmt stmt)}{InjectPrefetch(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Inject\+Prefetch (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a1d45de8cf5b6053ab16dde307a00238d}{}\label{namespacetvm_1_1tir_a1d45de8cf5b6053ab16dde307a00238d}


Inject prefetch instructions into stmt. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be transformed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Inject\+Virtual\+Thread@{Inject\+Virtual\+Thread}}
\index{Inject\+Virtual\+Thread@{Inject\+Virtual\+Thread}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Inject\+Virtual\+Thread(\+Stmt stmt)}{InjectVirtualThread(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Inject\+Virtual\+Thread (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a8c9c2135e4a2a674c7ffe1f414d9b362}{}\label{namespacetvm_1_1tir_a8c9c2135e4a2a674c7ffe1f414d9b362}


Inject virtual thread loops into stmt. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be transformed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Inline@{Inline}}
\index{Inline@{Inline}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Inline(\+Stmt stmt, Function\+Ref f, Array$<$ Var $>$ args, Prim\+Expr body)}{Inline(Stmt stmt, FunctionRef f, Array< Var > args, PrimExpr body)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Inline (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf Function\+Ref}}]{f, }
\item[{{\bf Array}$<$ {\bf Var} $>$}]{args, }
\item[{{\bf Prim\+Expr}}]{body}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a96379de32bcde10449bdb01b9b816e99}{}\label{namespacetvm_1_1tir_a96379de32bcde10449bdb01b9b816e99}


inline all calls of f in stmt. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to apply inline optimization. \\
\hline
{\em f} & The function reference to be inlined \\
\hline
{\em args} & The arguments variable of the function. \\
\hline
{\em body} & The definition body of the function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result stmt
\end{DoxyReturn}
\begin{DoxyNote}{Note}
All the passes in this file uses S\+SA form and outputs S\+SA form. 
\end{DoxyNote}
\index{tvm\+::tir@{tvm\+::tir}!Instrument\+Bound\+Checkers@{Instrument\+Bound\+Checkers}}
\index{Instrument\+Bound\+Checkers@{Instrument\+Bound\+Checkers}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Instrument\+Bound\+Checkers(\+Stmt stmt)}{InstrumentBoundCheckers(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Instrument\+Bound\+Checkers (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a604c5a3e5e7fad62a912b1d3bb41c3fa}{}\label{namespacetvm_1_1tir_a604c5a3e5e7fad62a912b1d3bb41c3fa}


instruments bound checkers. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be instrumented. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Instrumented stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!I\+R\+Transform@{I\+R\+Transform}}
\index{I\+R\+Transform@{I\+R\+Transform}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{I\+R\+Transform(\+Stmt node, const runtime\+::\+Packed\+Func \&preorder, const runtime\+::\+Packed\+Func \&postorder, const Array$<$ Prim\+Expr $>$ \&only\+\_\+enable=\lcurly{}\rcurly{})}{IRTransform(Stmt node, const runtime::PackedFunc &preorder, const runtime::PackedFunc &postorder, const Array< PrimExpr > &only_enable=\{\})}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+I\+R\+Transform (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{node, }
\item[{const {\bf runtime\+::\+Packed\+Func} \&}]{preorder, }
\item[{const {\bf runtime\+::\+Packed\+Func} \&}]{postorder, }
\item[{const {\bf Array}$<$ {\bf Prim\+Expr} $>$ \&}]{only\+\_\+enable = {\ttfamily \{\}}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a1217dd1b57e84b5901cf755251b9e164}{}\label{namespacetvm_1_1tir_a1217dd1b57e84b5901cf755251b9e164}


recursively visit the ir in post D\+FS order node, and transform it 


\begin{DoxyParams}{Parameters}
{\em node} & The ir to be transformed. \\
\hline
{\em preorder} & The function called in before recursive mutation If preorder returns None, then the transform will proceed to recursive call. If preorder returns a not None Stmt/\+Expr, the transformer will simply return it and won\textquotesingle{}t do further recursion. \\
\hline
{\em postorder} & The function called after recursive mutation. The recursive mutation result is passed to postorder for further mutation. \\
\hline
{\em only\+\_\+enable} & List of \hyperlink{classtvm_1_1tir_1_1StringImm}{String\+Imm}. If it is empty, all I\+R\+Node will call preorder/postorder If it is not empty, preorder/postorder will only be called when the I\+R\+Node\textquotesingle{}s type key is in the list. \\
\hline
\end{DoxyParams}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+const@{is\+\_\+const}}
\index{is\+\_\+const@{is\+\_\+const}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+const(const Prim\+Expr \&x)}{is_const(const PrimExpr &x)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+const (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_ab706ef9860459b25068f3440d88a7193}{}\label{namespacetvm_1_1tir_ab706ef9860459b25068f3440d88a7193}


Check whether x is a constant. 

\begin{DoxyNote}{Note}
This only return true for integer types. 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
whether x is constant 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+const\+\_\+int@{is\+\_\+const\+\_\+int}}
\index{is\+\_\+const\+\_\+int@{is\+\_\+const\+\_\+int}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+const\+\_\+int(const Prim\+Expr \&x, int64\+\_\+t value)}{is_const_int(const PrimExpr &x, int64_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+const\+\_\+int (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x, }
\item[{int64\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a5c414d5e54c099ad7287be302aac8f02}{}\label{namespacetvm_1_1tir_a5c414d5e54c099ad7287be302aac8f02}


Check whether x is a constant integer expression. 


\begin{DoxyParams}{Parameters}
{\em x} & The input argument \\
\hline
{\em value} & the value to be compared against. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether x is constant expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer@{is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer}}
\index{is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer@{is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer(const Prim\+Expr \&x, int $\ast$shift)}{is_const_power_of_two_integer(const PrimExpr &x, int *shift)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+const\+\_\+power\+\_\+of\+\_\+two\+\_\+integer (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x, }
\item[{int $\ast$}]{shift}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a246623a4a0c9cd8f8a209ec952a8d1c3}{}\label{namespacetvm_1_1tir_a246623a4a0c9cd8f8a209ec952a8d1c3}


Check whether x is a constant power of two If x is power of two, write the power to the shift. 


\begin{DoxyParams}{Parameters}
{\em x} & The input expression. \\
\hline
{\em shift} & The output shift if x is power of two. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether x is constant power of two 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+negative\+\_\+const@{is\+\_\+negative\+\_\+const}}
\index{is\+\_\+negative\+\_\+const@{is\+\_\+negative\+\_\+const}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+negative\+\_\+const(const Prim\+Expr \&a)}{is_negative_const(const PrimExpr &a)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+negative\+\_\+const (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a51d552441331effb387b7c8fb241c454}{}\label{namespacetvm_1_1tir_a51d552441331effb387b7c8fb241c454}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+no\+\_\+op@{is\+\_\+no\+\_\+op}}
\index{is\+\_\+no\+\_\+op@{is\+\_\+no\+\_\+op}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+no\+\_\+op(const tir\+::\+Stmt \&stmt)}{is_no_op(const tir::Stmt &stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+no\+\_\+op (
\begin{DoxyParamCaption}
\item[{const {\bf tir\+::\+Stmt} \&}]{stmt}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a8de8f843c6eb433b6ddfbf34e24099ef}{}\label{namespacetvm_1_1tir_a8de8f843c6eb433b6ddfbf34e24099ef}


Check whether stmt is nop. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The input statement \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether stmt is nop 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+one@{is\+\_\+one}}
\index{is\+\_\+one@{is\+\_\+one}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+one(const Prim\+Expr \&x)}{is_one(const PrimExpr &x)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+one (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a9b5104dcf0933da31329bb0b2580a947}{}\label{namespacetvm_1_1tir_a9b5104dcf0933da31329bb0b2580a947}


Check whether x is a constant integer 1. 


\begin{DoxyParams}{Parameters}
{\em x} & The input argument. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This only return true for integer types. 
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
whether x is constant 1 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+positive\+\_\+const@{is\+\_\+positive\+\_\+const}}
\index{is\+\_\+positive\+\_\+const@{is\+\_\+positive\+\_\+const}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+positive\+\_\+const(const Prim\+Expr \&a)}{is_positive_const(const PrimExpr &a)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+positive\+\_\+const (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{a}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a782dc226f8b2b537efdc56b1f76351d1}{}\label{namespacetvm_1_1tir_a782dc226f8b2b537efdc56b1f76351d1}
\index{tvm\+::tir@{tvm\+::tir}!is\+\_\+zero@{is\+\_\+zero}}
\index{is\+\_\+zero@{is\+\_\+zero}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{is\+\_\+zero(const Prim\+Expr \&x)}{is_zero(const PrimExpr &x)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::is\+\_\+zero (
\begin{DoxyParamCaption}
\item[{const {\bf Prim\+Expr} \&}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a48bad3db162b334837716bf8e7ba9285}{}\label{namespacetvm_1_1tir_a48bad3db162b334837716bf8e7ba9285}


Check whether x is a constant integer 0. 


\begin{DoxyParams}{Parameters}
{\em x} & The input argument \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether x is constant 0 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This only return true for integer types. 
\end{DoxyNote}
\index{tvm\+::tir@{tvm\+::tir}!Iter\+Var\+Type2\+String@{Iter\+Var\+Type2\+String}}
\index{Iter\+Var\+Type2\+String@{Iter\+Var\+Type2\+String}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Iter\+Var\+Type2\+String(\+Iter\+Var\+Type t)}{IterVarType2String(IterVarType t)}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ tvm\+::tir\+::\+Iter\+Var\+Type2\+String (
\begin{DoxyParamCaption}
\item[{{\bf Iter\+Var\+Type}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_afc0fdee9fc81462318d59dbe64c8df26}{}\label{namespacetvm_1_1tir_afc0fdee9fc81462318d59dbe64c8df26}
\index{tvm\+::tir@{tvm\+::tir}!Lift\+Attr\+Scope@{Lift\+Attr\+Scope}}
\index{Lift\+Attr\+Scope@{Lift\+Attr\+Scope}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lift\+Attr\+Scope(\+Stmt stmt, std\+::string attr\+\_\+key)}{LiftAttrScope(Stmt stmt, std::string attr_key)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Lift\+Attr\+Scope (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{std\+::string}]{attr\+\_\+key}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a799dff4f3a280576d6838694c151e657}{}\label{namespacetvm_1_1tir_a799dff4f3a280576d6838694c151e657}


Lift common attrs with attr\+\_\+key to outer scope. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be transformed \\
\hline
{\em attr\+\_\+key} & The attribute key to be checked. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Loop\+Partition@{Loop\+Partition}}
\index{Loop\+Partition@{Loop\+Partition}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Loop\+Partition(\+Stmt stmt, bool split\+\_\+const\+\_\+loop)}{LoopPartition(Stmt stmt, bool split_const_loop)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Loop\+Partition (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{bool}]{split\+\_\+const\+\_\+loop}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae0606ab38faf2f31d42759f217fdec93}{}\label{namespacetvm_1_1tir_ae0606ab38faf2f31d42759f217fdec93}


partition loops in the stmt 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to do loop partition \\
\hline
{\em split\+\_\+const\+\_\+loop} & flag to enable partition for const loop \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Custom\+Datatypes@{Lower\+Custom\+Datatypes}}
\index{Lower\+Custom\+Datatypes@{Lower\+Custom\+Datatypes}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Custom\+Datatypes(\+Lowered\+Func f, const std\+::string \&target)}{LowerCustomDatatypes(LoweredFunc f, const std::string &target)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+Custom\+Datatypes (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f, }
\item[{const std\+::string \&}]{target}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ac8725d2ad12962353ec11b6285cc6b3d}{}\label{namespacetvm_1_1tir_ac8725d2ad12962353ec11b6285cc6b3d}


Lower custom datatypes. 

See tvm\+::datatypes\+::\+Registry for more information on adding custom datatypes.


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
{\em target} & The target device. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Device\+Storage\+Access\+Info@{Lower\+Device\+Storage\+Access\+Info}}
\index{Lower\+Device\+Storage\+Access\+Info@{Lower\+Device\+Storage\+Access\+Info}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Device\+Storage\+Access\+Info(\+Lowered\+Func func)}{LowerDeviceStorageAccessInfo(LoweredFunc func)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+Device\+Storage\+Access\+Info (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_afcbd367b40fe2cd31d101c88a63a0b25}{}\label{namespacetvm_1_1tir_afcbd367b40fe2cd31d101c88a63a0b25}


Lower attached storage access information on device. Do this pass after all storage access analysis finish. 


\begin{DoxyParams}{Parameters}
{\em func} & The device function to be lowered. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Intrin@{Lower\+Intrin}}
\index{Lower\+Intrin@{Lower\+Intrin}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Intrin(\+Lowered\+Func f, const std\+::string \&target)}{LowerIntrin(LoweredFunc f, const std::string &target)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+Intrin (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f, }
\item[{const std\+::string \&}]{target}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_adb8b5d13c11411299808c564adda2713}{}\label{namespacetvm_1_1tir_adb8b5d13c11411299808c564adda2713}


Lower intrinsic function calls. 


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
{\em target} & The target device. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Storage\+Access\+Info@{Lower\+Storage\+Access\+Info}}
\index{Lower\+Storage\+Access\+Info@{Lower\+Storage\+Access\+Info}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Storage\+Access\+Info(\+Stmt stmt)}{LowerStorageAccessInfo(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Lower\+Storage\+Access\+Info (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a3b6c7e53cce5184e897b0bd24adb06b6}{}\label{namespacetvm_1_1tir_a3b6c7e53cce5184e897b0bd24adb06b6}


Lower attached storage access information. Do this pass after all storage access analysis finish. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be transformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Thread\+Allreduce@{Lower\+Thread\+Allreduce}}
\index{Lower\+Thread\+Allreduce@{Lower\+Thread\+Allreduce}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Thread\+Allreduce(\+Lowered\+Func f, int warp\+\_\+size)}{LowerThreadAllreduce(LoweredFunc f, int warp_size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+Thread\+Allreduce (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f, }
\item[{int}]{warp\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a438729b72b0e38a28289d763b48995b1}{}\label{namespacetvm_1_1tir_a438729b72b0e38a28289d763b48995b1}


Lower cross thread alleduce in the stmt. 


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
{\em warp\+\_\+size} & the size of warp where no sync is needed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+T\+V\+M\+Builtin@{Lower\+T\+V\+M\+Builtin}}
\index{Lower\+T\+V\+M\+Builtin@{Lower\+T\+V\+M\+Builtin}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+T\+V\+M\+Builtin(\+Lowered\+Func f)}{LowerTVMBuiltin(LoweredFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+T\+V\+M\+Builtin (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a9d59ba0cb48da1661593b7eeb2e96821}{}\label{namespacetvm_1_1tir_a9d59ba0cb48da1661593b7eeb2e96821}


Lower packed function call. 


\begin{DoxyParams}{Parameters}
{\em f} & The function to be lowered. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Lower\+Warp\+Memory@{Lower\+Warp\+Memory}}
\index{Lower\+Warp\+Memory@{Lower\+Warp\+Memory}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Lower\+Warp\+Memory(\+Lowered\+Func f, int warp\+\_\+size)}{LowerWarpMemory(LoweredFunc f, int warp_size)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Lower\+Warp\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f, }
\item[{int}]{warp\+\_\+size}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_af5111eb3e9b9d2f52998c5db4b4e3ae9}{}\label{namespacetvm_1_1tir_af5111eb3e9b9d2f52998c5db4b4e3ae9}


Lower warp memory in stmt. 


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
{\em warp\+\_\+size} & the size of warp where no sync is needed. this function will only take in effect if warp\+\_\+size is bigger than one. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!make\+\_\+const@{make\+\_\+const}}
\index{make\+\_\+const@{make\+\_\+const}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{make\+\_\+const(\+Data\+Type t, Value\+Type value)}{make_const(DataType t, ValueType value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Value\+Type , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+pod$<$\+Value\+Type$>$\+::value$>$\+::type$>$ {\bf Prim\+Expr} tvm\+::tir\+::make\+\_\+const (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{t, }
\item[{Value\+Type}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_a4ea566597880d04bd62fbec687e338b5}{}\label{namespacetvm_1_1tir_a4ea566597880d04bd62fbec687e338b5}


Make a const value with certain data type. 


\begin{DoxyParams}{Parameters}
{\em t} & The target type. \\
\hline
{\em value} & The input value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the result expression. 
\end{DoxyReturn}

\begin{DoxyTemplParams}{Template Parameters}
{\em Value\+Type} & The constant value type \\
\hline
\end{DoxyTemplParams}
\index{tvm\+::tir@{tvm\+::tir}!make\+\_\+zero@{make\+\_\+zero}}
\index{make\+\_\+zero@{make\+\_\+zero}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{make\+\_\+zero(\+Data\+Type t)}{make_zero(DataType t)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::make\+\_\+zero (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_adc4408508a413fb7f3b2567f8d847dbb}{}\label{namespacetvm_1_1tir_adc4408508a413fb7f3b2567f8d847dbb}


Make a const zero expr. 


\begin{DoxyParams}{Parameters}
{\em t} & The target type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the result expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Make\+A\+PI@{Make\+A\+PI}}
\index{Make\+A\+PI@{Make\+A\+PI}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Make\+A\+P\+I(\+Stmt body, std\+::string name, Array$<$ Object\+Ref $>$ api\+\_\+args, int num\+\_\+unpacked\+\_\+args, bool is\+\_\+restricted)}{MakeAPI(Stmt body, std::string name, Array< ObjectRef > api_args, int num_unpacked_args, bool is_restricted)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Make\+A\+PI (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{body, }
\item[{std\+::string}]{name, }
\item[{{\bf Array}$<$ Object\+Ref $>$}]{api\+\_\+args, }
\item[{int}]{num\+\_\+unpacked\+\_\+args, }
\item[{bool}]{is\+\_\+restricted}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ab2d44994c14f11c500586a007c782c84}{}\label{namespacetvm_1_1tir_ab2d44994c14f11c500586a007c782c84}


Make an user callable A\+PI \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func}. 

The main task of this function is to create code to \+:
\begin{DoxyItemize}
\item \hyperlink{classtvm_1_1Map}{Map} the values in the api\+\_\+args to \hyperlink{classtvm_1_1tir_1_1Var}{Var} that is required by body.
\item Insert assertions to check type/value of the passed arguments.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em body} & The body of the function. \\
\hline
{\em name} & The name of the function. \\
\hline
{\em api\+\_\+args} & Arguments to the function, can be either \hyperlink{classtvm_1_1tir_1_1Var}{Var}, or \hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} \\
\hline
{\em num\+\_\+unpacked\+\_\+args} & Number of arguments that are processed in plain form instead of packed form. \\
\hline
{\em is\+\_\+restricted} & Whether the caller can guarantee that each buffer argument do not overlap. It is recommended to set to true for optimized code if such invariant holds.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} with the specified signiture.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The function signature have two cases
\end{DoxyNote}
let num\+\_\+packed\+\_\+args = len(api\+\_\+args) -\/ num\+\_\+unpacked\+\_\+args;

if num\+\_\+packed\+\_\+args is zero\+: f(api\+\_\+arg\+\_\+0, api\+\_\+arg\+\_\+1, .., api\+\_\+arg\+\_\+n) where n == len(api\+\_\+args)

if num\+\_\+packed\+\_\+args is not zero\+: f(T\+V\+M\+Arg$\ast$ packed\+\_\+args, int$\ast$ packed\+\_\+arg\+\_\+type\+\_\+ids, int num\+\_\+packed\+\_\+args, api\+\_\+arg\+\_\+k, api\+\_\+arg\+\_\+k+1, ... api\+\_\+arg\+\_\+n, T\+V\+M\+Value$\ast$ out\+\_\+ret\+\_\+val, int$\ast$ out\+\_\+ret\+\_\+tcode)

where n == len(api\+\_\+args), k == num\+\_\+packed\+\_\+args

There is no thread\+\_\+axis in generated function. \index{tvm\+::tir@{tvm\+::tir}!Make\+Const\+Scalar@{Make\+Const\+Scalar}}
\index{Make\+Const\+Scalar@{Make\+Const\+Scalar}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Make\+Const\+Scalar(\+Data\+Type t, Value\+Type value)}{MakeConstScalar(DataType t, ValueType value)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Value\+Type $>$ {\bf Prim\+Expr} tvm\+::tir\+::\+Make\+Const\+Scalar (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{t, }
\item[{Value\+Type}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_af2ca71170aca9d397c2125eb4f55c197}{}\label{namespacetvm_1_1tir_af2ca71170aca9d397c2125eb4f55c197}
\index{tvm\+::tir@{tvm\+::tir}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, For\+Type for\+\_\+type)}{operator<<(std::ostream &os, ForType for_type)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& tvm\+::tir\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf For\+Type}}]{for\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a12a98cd1a8440b18d6bac0ad3eaa42ed}{}\label{namespacetvm_1_1tir_a12a98cd1a8440b18d6bac0ad3eaa42ed}
\index{tvm\+::tir@{tvm\+::tir}!Pointer\+Value\+Type\+Rewrite@{Pointer\+Value\+Type\+Rewrite}}
\index{Pointer\+Value\+Type\+Rewrite@{Pointer\+Value\+Type\+Rewrite}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Pointer\+Value\+Type\+Rewrite(\+Lowered\+Func f)}{PointerValueTypeRewrite(LoweredFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Pointer\+Value\+Type\+Rewrite (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ad2814a5568d2e1329a5c5aab2e35091e}{}\label{namespacetvm_1_1tir_ad2814a5568d2e1329a5c5aab2e35091e}


Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. 

\begin{DoxyNote}{Note}
implemeneted in storage\+\_\+rewrite.\+cc 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em f} & The function to be trasnformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Pointer\+Value\+Type\+Rewrite@{Pointer\+Value\+Type\+Rewrite}}
\index{Pointer\+Value\+Type\+Rewrite@{Pointer\+Value\+Type\+Rewrite}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Pointer\+Value\+Type\+Rewrite(\+Prim\+Func f)}{PointerValueTypeRewrite(PrimFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Func} tvm\+::tir\+::\+Pointer\+Value\+Type\+Rewrite (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_abbf2681c6850628b3c9b213298f056b3}{}\label{namespacetvm_1_1tir_abbf2681c6850628b3c9b213298f056b3}


Rewrite the pointer content type of arguments, as well as Alloc internal to the function to use the most frequently accessed type for load/store to avoid pointer casting in backend when possible. 

\begin{DoxyNote}{Note}
implemeneted in storage\+\_\+rewrite.\+cc 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em f} & The function to be trasnformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Post\+Order\+Visit@{Post\+Order\+Visit}}
\index{Post\+Order\+Visit@{Post\+Order\+Visit}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Post\+Order\+Visit(const Object\+Ref \&node, std\+::function$<$ void(const Object\+Ref \&)$>$ fvisit)}{PostOrderVisit(const ObjectRef &node, std::function< void(const ObjectRef &)> fvisit)}}]{\setlength{\rightskip}{0pt plus 5cm}void tvm\+::tir\+::\+Post\+Order\+Visit (
\begin{DoxyParamCaption}
\item[{const Object\+Ref \&}]{node, }
\item[{std\+::function$<$ void(const Object\+Ref \&)$>$}]{fvisit}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a4b5067fa233d111c9db9cc402ed599c3}{}\label{namespacetvm_1_1tir_a4b5067fa233d111c9db9cc402ed599c3}


recursively visit the ir in post D\+FS order node, apply fvisit Each node is guaranteed to be visited only once. 


\begin{DoxyParams}{Parameters}
{\em node} & The ir to be visited. \\
\hline
{\em fvisit} & The visitor function to be applied. \\
\hline
\end{DoxyParams}
\index{tvm\+::tir@{tvm\+::tir}!Remap\+Thread\+Axis@{Remap\+Thread\+Axis}}
\index{Remap\+Thread\+Axis@{Remap\+Thread\+Axis}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Remap\+Thread\+Axis(\+Lowered\+Func f, Map$<$ Prim\+Expr, Iter\+Var $>$ axis\+\_\+map)}{RemapThreadAxis(LoweredFunc f, Map< PrimExpr, IterVar > axis_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Remap\+Thread\+Axis (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f, }
\item[{{\bf Map}$<$ {\bf Prim\+Expr}, {\bf Iter\+Var} $>$}]{axis\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ad55f17f026155f1424b3d0fdd3f86435}{}\label{namespacetvm_1_1tir_ad55f17f026155f1424b3d0fdd3f86435}


Remap the thread axis. 

This can be used to get equivalent program which uses thread\+Idx.\+y in place of thread\+Idx.\+x by passing \{\char`\"{}thread\+Idx.\+x\char`\"{}\+: thread\+\_\+axis(\char`\"{}thread\+Idx.\+y\char`\"{})\}


\begin{DoxyParams}{Parameters}
{\em f} & The device function to be lowered. \\
\hline
{\em axis\+\_\+map} & The map from \hyperlink{classtvm_1_1tir_1_1StringImm}{String\+Imm} -\/$>$ Itr\+Var \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Remove\+No\+Op@{Remove\+No\+Op}}
\index{Remove\+No\+Op@{Remove\+No\+Op}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Remove\+No\+Op(\+Stmt stmt)}{RemoveNoOp(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Remove\+No\+Op (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a64dd52c904c2944a4771b81a2cf8f08a}{}\label{namespacetvm_1_1tir_a64dd52c904c2944a4771b81a2cf8f08a}


Remove No \hyperlink{classtvm_1_1Op}{Op} from the \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt}. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be trasnformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Rewrite\+For\+Tensor\+Core@{Rewrite\+For\+Tensor\+Core}}
\index{Rewrite\+For\+Tensor\+Core@{Rewrite\+For\+Tensor\+Core}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Rewrite\+For\+Tensor\+Core(\+Stmt stmt, te\+::\+Schedule schedule, Map$<$ te\+::\+Tensor, Buffer $>$ extern\+\_\+buffer)}{RewriteForTensorCore(Stmt stmt, te::Schedule schedule, Map< te::Tensor, Buffer > extern_buffer)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Rewrite\+For\+Tensor\+Core (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf te\+::\+Schedule}}]{schedule, }
\item[{{\bf Map}$<$ {\bf te\+::\+Tensor}, {\bf Buffer} $>$}]{extern\+\_\+buffer}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a00e711fe4801fd2d11f85cb64bc64d56}{}\label{namespacetvm_1_1tir_a00e711fe4801fd2d11f85cb64bc64d56}


Try to modify the A\+ST to support Tensor\+Core. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be trasnformed. \\
\hline
{\em schedule} & The original schedule. \\
\hline
{\em extern\+\_\+buffer} & \hyperlink{classtvm_1_1Map}{Map} specifies external buffer assignment of input and outputs. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Rewrite\+Unsafe\+Select@{Rewrite\+Unsafe\+Select}}
\index{Rewrite\+Unsafe\+Select@{Rewrite\+Unsafe\+Select}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Rewrite\+Unsafe\+Select(\+Stmt stmt)}{RewriteUnsafeSelect(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Rewrite\+Unsafe\+Select (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a2c3a142f48991df5a96ee1791685ca64}{}\label{namespacetvm_1_1tir_a2c3a142f48991df5a96ee1791685ca64}


Detect and rewrite unsafe select that contains memory access. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be rewritten. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Simplify@{Simplify}}
\index{Simplify@{Simplify}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Simplify(\+Prim\+Expr expr, Map$<$ Var, Range $>$ vrange=\+Map$<$ Var, Range $>$())}{Simplify(PrimExpr expr, Map< Var, Range > vrange=Map< Var, Range >())}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::\+Simplify (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{expr, }
\item[{{\bf Map}$<$ {\bf Var}, {\bf Range} $>$}]{vrange = {\ttfamily {\bf Map}$<$~{\bf Var},~{\bf Range}~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a923d1bb833c984008772782e90cda37a}{}\label{namespacetvm_1_1tir_a923d1bb833c984008772782e90cda37a}


Simplify the expression. 


\begin{DoxyParams}{Parameters}
{\em expr} & The expression to be simplifed. \\
\hline
{\em vrange} & The range information about the variable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Canonicalized statement. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Simplify@{Simplify}}
\index{Simplify@{Simplify}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Simplify(\+Stmt stmt, Map$<$ Var, Range $>$ vrange=\+Map$<$ Var, Range $>$())}{Simplify(Stmt stmt, Map< Var, Range > vrange=Map< Var, Range >())}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Simplify (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf Map}$<$ {\bf Var}, {\bf Range} $>$}]{vrange = {\ttfamily {\bf Map}$<$~{\bf Var},~{\bf Range}~$>$()}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a49287db98b766f8900dbbfcc466cb596}{}\label{namespacetvm_1_1tir_a49287db98b766f8900dbbfcc466cb596}


Simplify the statement. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be simplifed. \\
\hline
{\em vrange} & The range information about the variable. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Canonicalized statement. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Skip\+Assert@{Skip\+Assert}}
\index{Skip\+Assert@{Skip\+Assert}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Skip\+Assert(\+Lowered\+Func f)}{SkipAssert(LoweredFunc f)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Skip\+Assert (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{f}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a9968b6563c42117a9a1cd4576054400f}{}\label{namespacetvm_1_1tir_a9968b6563c42117a9a1cd4576054400f}


skip assert stmt generation 


\begin{DoxyParams}{Parameters}
{\em f} & The function to be transformed. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed function. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Skip\+Vectorize@{Skip\+Vectorize}}
\index{Skip\+Vectorize@{Skip\+Vectorize}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Skip\+Vectorize(\+Stmt stmt)}{SkipVectorize(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Skip\+Vectorize (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a2f8fc7370ebc9a6b0de19ae9e597576f}{}\label{namespacetvm_1_1tir_a2f8fc7370ebc9a6b0de19ae9e597576f}


convert vectorized loops into serialized loops 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to skip vectorization on. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Split\+Host\+Device@{Split\+Host\+Device}}
\index{Split\+Host\+Device@{Split\+Host\+Device}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Split\+Host\+Device(\+Lowered\+Func func)}{SplitHostDevice(LoweredFunc func)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Array}$<${\bf Lowered\+Func}$>$ tvm\+::tir\+::\+Split\+Host\+Device (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{func}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ac7f5e04aea66d87ad42baf957768c451}{}\label{namespacetvm_1_1tir_ac7f5e04aea66d87ad42baf957768c451}


Split the function into a host function and device functions. 


\begin{DoxyParams}{Parameters}
{\em func} & The function to be splitted.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classtvm_1_1Array}{Array} of functions, the first one is host function, the others are device functions. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Storage\+Flatten@{Storage\+Flatten}}
\index{Storage\+Flatten@{Storage\+Flatten}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Storage\+Flatten(\+Stmt stmt, Map$<$ te\+::\+Tensor, Buffer $>$ extern\+\_\+buffer, int cache\+\_\+line\+\_\+size, bool create\+\_\+bound\+\_\+attribute=false)}{StorageFlatten(Stmt stmt, Map< te::Tensor, Buffer > extern_buffer, int cache_line_size, bool create_bound_attribute=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Storage\+Flatten (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf Map}$<$ {\bf te\+::\+Tensor}, {\bf Buffer} $>$}]{extern\+\_\+buffer, }
\item[{int}]{cache\+\_\+line\+\_\+size, }
\item[{bool}]{create\+\_\+bound\+\_\+attribute = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a2c63e0decac1e98ee375d32dee15526e}{}\label{namespacetvm_1_1tir_a2c63e0decac1e98ee375d32dee15526e}


Flatten the multi-\/dimensional read/write to single dimensional Load/\+Store. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be trasnformed. \\
\hline
{\em extern\+\_\+buffer} & \hyperlink{classtvm_1_1Map}{Map} specifies external buffer assignment of input and outputs. \\
\hline
{\em cache\+\_\+line\+\_\+size} & The size of C\+PU cache line. \\
\hline
{\em create\+\_\+bound\+\_\+attribute} & Whether to create bound attributes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Storage\+Rewrite@{Storage\+Rewrite}}
\index{Storage\+Rewrite@{Storage\+Rewrite}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Storage\+Rewrite(\+Stmt stmt)}{StorageRewrite(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Storage\+Rewrite (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a5b70ca88f988211332570160c82e3026}{}\label{namespacetvm_1_1tir_a5b70ca88f988211332570160c82e3026}


Rewrite storage allocation pattern. Moves the allocation to outer most possible scope. Trying to share space between allocations to make a static allocation plan when possible. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be transformed \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Substitute@{Substitute}}
\index{Substitute@{Substitute}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Substitute(\+Stmt stmt, const std\+::unordered\+\_\+map$<$ const Var\+Node $\ast$, Prim\+Expr $>$ \&value\+\_\+map)}{Substitute(Stmt stmt, const std::unordered_map< const VarNode *, PrimExpr > &value_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Substitute (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{const std\+::unordered\+\_\+map$<$ const {\bf Var\+Node} $\ast$, {\bf Prim\+Expr} $>$ \&}]{value\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a4b122873fd63b721684ffb4cd9913bb4}{}\label{namespacetvm_1_1tir_a4b122873fd63b721684ffb4cd9913bb4}


Substitute the var specified in key-\/$>$var to be value. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The source statement to be substituted \\
\hline
{\em value\+\_\+map} & The map of new values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted form. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Substitute@{Substitute}}
\index{Substitute@{Substitute}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Substitute(\+Prim\+Expr expr, const std\+::unordered\+\_\+map$<$ const Var\+Node $\ast$, Prim\+Expr $>$ \&value\+\_\+map)}{Substitute(PrimExpr expr, const std::unordered_map< const VarNode *, PrimExpr > &value_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::\+Substitute (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{expr, }
\item[{const std\+::unordered\+\_\+map$<$ const {\bf Var\+Node} $\ast$, {\bf Prim\+Expr} $>$ \&}]{value\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a1753495736a7c0ab703ed01c673ec5d0}{}\label{namespacetvm_1_1tir_a1753495736a7c0ab703ed01c673ec5d0}


Substitute the var specified in key-\/$>$var to be value. 


\begin{DoxyParams}{Parameters}
{\em expr} & The source expression to be substituted \\
\hline
{\em value\+\_\+map} & The map of new values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Substitute@{Substitute}}
\index{Substitute@{Substitute}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Substitute(\+Stmt stmt, const Map$<$ Var, Prim\+Expr $>$ \&value\+\_\+map)}{Substitute(Stmt stmt, const Map< Var, PrimExpr > &value_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Substitute (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{const {\bf Map}$<$ {\bf Var}, {\bf Prim\+Expr} $>$ \&}]{value\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_abc79c4131e8b95c4ae4be56d4ab3c494}{}\label{namespacetvm_1_1tir_abc79c4131e8b95c4ae4be56d4ab3c494}


Substitute the var specified in key-\/$>$var to be value. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The source statement to be substituted \\
\hline
{\em value\+\_\+map} & The map of new values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted form. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Substitute@{Substitute}}
\index{Substitute@{Substitute}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Substitute(\+Prim\+Expr expr, const Map$<$ Var, Prim\+Expr $>$ \&value\+\_\+map)}{Substitute(PrimExpr expr, const Map< Var, PrimExpr > &value_map)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::\+Substitute (
\begin{DoxyParamCaption}
\item[{{\bf Prim\+Expr}}]{expr, }
\item[{const {\bf Map}$<$ {\bf Var}, {\bf Prim\+Expr} $>$ \&}]{value\+\_\+map}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a34e6a1e27339fcc255f664dd14e7c6cc}{}\label{namespacetvm_1_1tir_a34e6a1e27339fcc255f664dd14e7c6cc}


Substitute the var specified in key-\/$>$var to be value. 


\begin{DoxyParams}{Parameters}
{\em expr} & The source expression to be substituted \\
\hline
{\em value\+\_\+map} & The map of new values. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted expression. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Thread\+Sync@{Thread\+Sync}}
\index{Thread\+Sync@{Thread\+Sync}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Thread\+Sync(\+Lowered\+Func stmt, std\+::string storage\+\_\+scope)}{ThreadSync(LoweredFunc stmt, std::string storage_scope)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Lowered\+Func} tvm\+::tir\+::\+Thread\+Sync (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{stmt, }
\item[{std\+::string}]{storage\+\_\+scope}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ab0df6d882d69f4ec8e1b146a0d8728f9}{}\label{namespacetvm_1_1tir_ab0df6d882d69f4ec8e1b146a0d8728f9}


Insert sync between parallel read/write of shared buffers. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be trasnformed. \\
\hline
{\em storage\+\_\+scope} & The storage scope considered. \\
\hline
\end{DoxyParams}
\index{tvm\+::tir@{tvm\+::tir}!Type\+Annotation@{Type\+Annotation}}
\index{Type\+Annotation@{Type\+Annotation}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Type\+Annotation(\+Data\+Type dtype)}{TypeAnnotation(DataType dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Prim\+Expr} tvm\+::tir\+::\+Type\+Annotation (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{dtype}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_afb1743e78389c4beaf0b788c631d424e}{}\label{namespacetvm_1_1tir_afb1743e78389c4beaf0b788c631d424e}


Create a type annotation expression. 


\begin{DoxyParams}{Parameters}
{\em dtype} & The data type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Expr a expression with dtype. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Undefined\+Vars@{Undefined\+Vars}}
\index{Undefined\+Vars@{Undefined\+Vars}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Undefined\+Vars(const Stmt \&stmt, const Array$<$ Var $>$ \&defs)}{UndefinedVars(const Stmt &stmt, const Array< Var > &defs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Array}$<${\bf Var}$>$ tvm\+::tir\+::\+Undefined\+Vars (
\begin{DoxyParamCaption}
\item[{const {\bf Stmt} \&}]{stmt, }
\item[{const {\bf Array}$<$ {\bf Var} $>$ \&}]{defs}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae110e02855d8bc12eb8b6f92ed391844}{}\label{namespacetvm_1_1tir_ae110e02855d8bc12eb8b6f92ed391844}


Find undefined vars in the statment. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The function to be checked. \\
\hline
{\em defs} & The vars that is defined. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{classtvm_1_1Array}{Array} of undefined vars. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Unroll\+Loop@{Unroll\+Loop}}
\index{Unroll\+Loop@{Unroll\+Loop}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Unroll\+Loop(\+Stmt stmt, int auto\+\_\+max\+\_\+step, int auto\+\_\+max\+\_\+depth, int auto\+\_\+max\+\_\+extent, bool explicit\+\_\+unroll)}{UnrollLoop(Stmt stmt, int auto_max_step, int auto_max_depth, int auto_max_extent, bool explicit_unroll)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Unroll\+Loop (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{int}]{auto\+\_\+max\+\_\+step, }
\item[{int}]{auto\+\_\+max\+\_\+depth, }
\item[{int}]{auto\+\_\+max\+\_\+extent, }
\item[{bool}]{explicit\+\_\+unroll}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a319c8f6b65c8c053c87b429d6d791343}{}\label{namespacetvm_1_1tir_a319c8f6b65c8c053c87b429d6d791343}


unroll the constant loop marked by unroll. This pass also automatically attach pragma unroll tag to loops which meets the standard. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statment to be unrolled. \\
\hline
{\em auto\+\_\+max\+\_\+step} & The maximum step before stop attach automatic unroll \\
\hline
{\em auto\+\_\+max\+\_\+depth} & The maximum depth before stop attach automatic unroll \\
\hline
{\em auto\+\_\+max\+\_\+extent} & The maximum extent of the loop we can unroll, this is an legacy option that do not take the loop total steps into account. \\
\hline
{\em explicit\+\_\+unroll} & Whether explicitly unroll the loop, or leave unroll annotation to codegen. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Vectorize\+Loop@{Vectorize\+Loop}}
\index{Vectorize\+Loop@{Vectorize\+Loop}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Vectorize\+Loop(\+Stmt stmt)}{VectorizeLoop(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stmt} tvm\+::tir\+::\+Vectorize\+Loop (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_abdd6d56877b9dd03803f433352b09060}{}\label{namespacetvm_1_1tir_abdd6d56877b9dd03803f433352b09060}


vectorize the constant loops 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be vectorized. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Transformed stmt. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Verify\+Compact\+Buffer@{Verify\+Compact\+Buffer}}
\index{Verify\+Compact\+Buffer@{Verify\+Compact\+Buffer}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Verify\+Compact\+Buffer(\+Stmt stmt)}{VerifyCompactBuffer(Stmt stmt)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Verify\+Compact\+Buffer (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae892521d99d9475a59e2d01df9413b49}{}\label{namespacetvm_1_1tir_ae892521d99d9475a59e2d01df9413b49}


Verify if there is any argument bound to compact buffer. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The stmt to be verified. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if there is any buffer\+\_\+bind\+\_\+scope attribute found, otherwise, false. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Verify\+G\+P\+U\+Code@{Verify\+G\+P\+U\+Code}}
\index{Verify\+G\+P\+U\+Code@{Verify\+G\+P\+U\+Code}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Verify\+G\+P\+U\+Code(\+Stmt stmt, Map$<$ std\+::string, Prim\+Expr $>$ constraints)}{VerifyGPUCode(Stmt stmt, Map< std::string, PrimExpr > constraints)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Verify\+G\+P\+U\+Code (
\begin{DoxyParamCaption}
\item[{{\bf Stmt}}]{stmt, }
\item[{{\bf Map}$<$ std\+::string, {\bf Prim\+Expr} $>$}]{constraints}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_a705b3e58180a12eba5297cb2442fd1a2}{}\label{namespacetvm_1_1tir_a705b3e58180a12eba5297cb2442fd1a2}


Verify the correctness of a G\+PU code It will check the whether the amount of memory usage or the number of threads in a block exceeds the limit. 


\begin{DoxyParams}{Parameters}
{\em stmt} & The statement to be checked \\
\hline
{\em constraints} & The dict to specify constraints to check. Possible keys are\\
\hline
\end{DoxyParams}
\char`\"{}max\+\_\+local\+\_\+memory\+\_\+per\+\_\+block\char`\"{}\+: Total amount of local memory per block (in bytes). \char`\"{}max\+\_\+shared\+\_\+memory\+\_\+per\+\_\+block\char`\"{}\+: Total amount of shared memory per block (in bytes). \char`\"{}max\+\_\+threads\+\_\+per\+\_\+block\char`\"{}\+: Maximum number of threads per block. \char`\"{}max\+\_\+thread\+\_\+x\char`\"{}\+: Maximum length of thread\+Idx.\+x. \char`\"{}max\+\_\+thread\+\_\+y\char`\"{}\+: Maximum length of thread\+Idx.\+y. \char`\"{}max\+\_\+thread\+\_\+z\char`\"{}\+: Maximum length of thread\+Idx.\+z.

If one key is missing in this argument, the pass won\textquotesingle{}t check for that item. \begin{DoxyReturn}{Returns}
valid Whether it is a valid G\+PU code 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Verify\+Memory@{Verify\+Memory}}
\index{Verify\+Memory@{Verify\+Memory}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Verify\+Memory(\+Lowered\+Func func, int device\+\_\+type)}{VerifyMemory(LoweredFunc func, int device_type)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Verify\+Memory (
\begin{DoxyParamCaption}
\item[{{\bf Lowered\+Func}}]{func, }
\item[{int}]{device\+\_\+type}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_aa649448c69d8324ba1fd7ec5e3e54731}{}\label{namespacetvm_1_1tir_aa649448c69d8324ba1fd7ec5e3e54731}


Verify if memory accesses are legal for a specific target device type. 

In the case that tgt is cuda, if not all workload is bound with threads, C\+PU code is generated that tries to access G\+PU memory, which is illegal. This pass performs verification for this case.


\begin{DoxyParams}{Parameters}
{\em func} & The function to be verified. \\
\hline
{\em device\+\_\+type} & The target device type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Success of memory verification. 
\end{DoxyReturn}
\index{tvm\+::tir@{tvm\+::tir}!Verify\+S\+SA@{Verify\+S\+SA}}
\index{Verify\+S\+SA@{Verify\+S\+SA}!tvm\+::tir@{tvm\+::tir}}
\subsubsection[{\texorpdfstring{Verify\+S\+S\+A(const Stmt \&ir)}{VerifySSA(const Stmt &ir)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::\+Verify\+S\+SA (
\begin{DoxyParamCaption}
\item[{const {\bf Stmt} \&}]{ir}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1tir_ae4506ebe76b8f44653dafdf0aef263f1}{}\label{namespacetvm_1_1tir_ae4506ebe76b8f44653dafdf0aef263f1}


verifies whether the IR stmt or Expr is in S\+SA form. That is\+: each Var\+Expr is defined and assigned once(in Let/\+For) 


\begin{DoxyParams}{Parameters}
{\em ir} & The root of the IR D\+AG. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether IR is in S\+SA form. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
All the passes in this file uses S\+SA form and outputs S\+SA form. 
\end{DoxyNote}
