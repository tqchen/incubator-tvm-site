\hypertarget{namespacetvm_1_1runtime}{}\section{tvm\+:\+:runtime Namespace Reference}
\label{namespacetvm_1_1runtime}\index{tvm\+::runtime@{tvm\+::runtime}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \hyperlink{namespacetvm_1_1runtime_1_1symbol}{symbol}
\begin{DoxyCompactList}\small\item\em namespace for constant symbols \end{DoxyCompactList}\item 
 \hyperlink{namespacetvm_1_1runtime_1_1threading}{threading}
\item 
 \hyperlink{namespacetvm_1_1runtime_1_1vm}{vm}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classtvm_1_1runtime_1_1ADT}{A\+DT}
\begin{DoxyCompactList}\small\item\em reference to algebraic data type objects. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1ADTObj}{A\+D\+T\+Obj}
\begin{DoxyCompactList}\small\item\em An object representing a structure or enumeration. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1DataType}{Data\+Type}
\begin{DoxyCompactList}\small\item\em Runtime primitive data type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1DeviceAPI}{Device\+A\+PI}
\begin{DoxyCompactList}\small\item\em T\+VM Runtime Device A\+PI, abstracts the device specific interface for memory management. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1InplaceArrayBase}{Inplace\+Array\+Base}
\begin{DoxyCompactList}\small\item\em Base template for classes with array like memory layout. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1Module}{Module}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1runtime_1_1Module}{Module} container of T\+VM. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1ModuleNode}{Module\+Node}
\begin{DoxyCompactList}\small\item\em Base container of module. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array}
\begin{DoxyCompactList}\small\item\em Managed \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array}. The array is backed by reference counted blocks. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1ObjAllocatorBase}{Obj\+Allocator\+Base}
\begin{DoxyCompactList}\small\item\em Base class of object allocators that implements make. Use curiously recurring template pattern. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1Object}{Object}
\begin{DoxyCompactList}\small\item\em base class of all object containers. \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1runtime_1_1ObjectEqual}{Object\+Equal}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref} equal functor. \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1runtime_1_1ObjectHash}{Object\+Hash}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref} hash functor. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}
\begin{DoxyCompactList}\small\item\em A custom smart pointer for \hyperlink{classtvm_1_1runtime_1_1Object}{Object}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref}
\begin{DoxyCompactList}\small\item\em Base class of all object reference. \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker}{Object\+Type\+Checker}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1Type}{Type} traits for runtime type check during F\+FI conversion. \end{DoxyCompactList}\item 
struct \hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4}{Object\+Type\+Checker$<$ Array$<$ T $>$ $>$}
\item 
struct \hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4}{Object\+Type\+Checker$<$ Map$<$ K, V $>$ $>$}
\item 
struct {\bfseries Object\+Type\+Checker$<$ Map$<$ std\+::string, V $>$ $>$}
\item 
class \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func}
\begin{DoxyCompactList}\small\item\em Packed function is a type-\/erased function. The arguments are passed by packed format. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1Registry}{Registry}
\begin{DoxyCompactList}\small\item\em \hyperlink{classtvm_1_1runtime_1_1Registry}{Registry} for global function. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1SimpleObjAllocator}{Simple\+Obj\+Allocator}
\item 
class \hyperlink{classtvm_1_1runtime_1_1String}{String}
\begin{DoxyCompactList}\small\item\em Reference to string objects. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1StringObj}{String\+Obj}
\begin{DoxyCompactList}\small\item\em An object representing string. It\textquotesingle{}s P\+OD type. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TVMArgs}{T\+V\+M\+Args}
\begin{DoxyCompactList}\small\item\em Arguments into T\+VM functions. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TVMArgsSetter}{T\+V\+M\+Args\+Setter}
\item 
class \hyperlink{classtvm_1_1runtime_1_1TVMArgValue}{T\+V\+M\+Arg\+Value}
\begin{DoxyCompactList}\small\item\em A single argument value to \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func}. Containing both type\+\_\+code and \hyperlink{unionTVMValue}{T\+V\+M\+Value}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TVMPODValue__}{T\+V\+M\+P\+O\+D\+Value\+\_\+}
\begin{DoxyCompactList}\small\item\em Internal base class to handle conversion to P\+OD values. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TVMRetValue}{T\+V\+M\+Ret\+Value}
\begin{DoxyCompactList}\small\item\em Return Value container, Unlike \hyperlink{classtvm_1_1runtime_1_1TVMArgValue}{T\+V\+M\+Arg\+Value}, which only holds reference and do not delete the underlying container during destruction. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc}{Typed\+Packed\+Func}
\begin{DoxyCompactList}\small\item\em Please refer to \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4_TypedPackedFuncAnchor}{Typed\+Packed\+Func$<$R(Args..)$>$}. \end{DoxyCompactList}\item 
class \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4}{Typed\+Packed\+Func$<$ R(\+Args...)$>$}
\begin{DoxyCompactList}\small\item\em A \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} wrapper to provide typed function signature. It is backed by a \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} internally. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619}{Device\+Attr\+Kind} \+: int \{ \\*
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb}{k\+Exist} = 0, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4}{k\+Max\+Threads\+Per\+Block} = 1, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da}{k\+Warp\+Size} = 2, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264}{k\+Max\+Shared\+Memory\+Per\+Block} = 3, 
\\*
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b}{k\+Compute\+Version} = 4, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca}{k\+Device\+Name} = 5, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630}{k\+Max\+Clock\+Rate} = 6, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd}{k\+Multi\+Processor\+Count} = 7, 
\\*
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991}{k\+Max\+Thread\+Dimensions} = 8, 
\hyperlink{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201}{k\+Gcn\+Arch} = 9
 \}\begin{DoxyCompactList}\small\item\em the query type into Get\+Attr \end{DoxyCompactList}
\item 
enum \hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4}{Type\+Index} \{ \\*
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a1b73281b45b997205b5082ba53300d6a}{k\+Root} = 0, 
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a626309e16a9075cc8009c93adf3fbc9f}{k\+Closure} = 1, 
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a86d9bc218c0f54443cbbe3fcc5c8382e}{k\+V\+M\+A\+DT} = 2, 
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4af5474ebdbaaa19e977334eefa4bbd611}{k\+Runtime\+Module} = 3, 
\\*
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a548302094bc9afb6bb14dc2a283c1014}{k\+Static\+Index\+End}, 
\hyperlink{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a633f5947b3a79c577b538cec7528f5aa}{k\+Dynamic} = k\+Static\+Index\+End
 \}\begin{DoxyCompactList}\small\item\em list of the type index. \end{DoxyCompactList}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::ostream \& \hyperlink{namespacetvm_1_1runtime_af22b89284299c81d0c1802199af446d7}{operator$<$$<$} (std\+::ostream \&os, const \hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref} \&n)
\item 
int \hyperlink{namespacetvm_1_1runtime_ad01a53416152b68029d67190c3709d25}{Get\+Vector\+Bytes} (\hyperlink{classtvm_1_1runtime_1_1DataType}{Data\+Type} dtype)
\begin{DoxyCompactList}\small\item\em Get the number of bytes needed in a vector. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1runtime_adbabb7cfb79bfb6d802f65a9803e4eb6}{Type\+Match} (D\+L\+Data\+Type t, int code, int bits, int lanes=1)
\begin{DoxyCompactList}\small\item\em Check whether type matches the given spec. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1runtime_aee574cee6755b0c2f1aa664c6967686f}{Type\+Equal} (D\+L\+Data\+Type lhs, D\+L\+Data\+Type rhs)
\begin{DoxyCompactList}\small\item\em Check whether two types are equal . \end{DoxyCompactList}\item 
const char $\ast$ \hyperlink{namespacetvm_1_1runtime_a9109e4efe269213052ed6a94853c0c00}{Device\+Name} (int type)
\begin{DoxyCompactList}\small\item\em The name of Device A\+PI factory. \end{DoxyCompactList}\item 
std\+::ostream \& \hyperlink{namespacetvm_1_1runtime_a0ce391c2492dfc73b5c6c6459693c6a6}{operator$<$$<$} (std\+::ostream \&os, D\+L\+Context ctx)
\item 
{\footnotesize template$<$typename T , typename... Args$>$ }\\\hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}$<$ T $>$ \hyperlink{namespacetvm_1_1runtime_a93466f4543eedc3925c66ed0e7ef2671}{make\+\_\+object} (Args \&\&...args)
\begin{DoxyCompactList}\small\item\em Allocate an object using default allocator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Array\+Type , typename Elem\+Type , typename... Args$>$ }\\\hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}$<$ Array\+Type $>$ \hyperlink{namespacetvm_1_1runtime_a144496aaff68cd251b6bc0a7b24ca041}{make\+\_\+inplace\+\_\+array\+\_\+object} (size\+\_\+t num\+\_\+elems, Args \&\&...args)
\item 
bool \hyperlink{namespacetvm_1_1runtime_abbea0c23882ae01431ac7fe6506b32a7}{Runtime\+Enabled} (const std\+::string \&target)
\begin{DoxyCompactList}\small\item\em Check if runtime module is enabled for target. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1runtime_a8fb37910dcd9bb6899e6a3a47f006514}{Save\+D\+L\+Tensor} (dmlc\+::\+Stream $\ast$strm, const D\+L\+Tensor $\ast$tensor)
\begin{DoxyCompactList}\small\item\em Save a D\+L\+Tensor to stream. \end{DoxyCompactList}\item 
size\+\_\+t \hyperlink{namespacetvm_1_1runtime_a59940b6d63dd4c5175c0fe875047c1cf}{Get\+Data\+Size} (const D\+L\+Tensor \&arr)
\begin{DoxyCompactList}\small\item\em return the size of data the D\+L\+Tensor hold, in term of number of bytes \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1runtime_adb2ed1227b418f5846d43d3234b52391}{Is\+Contiguous} (const D\+L\+Tensor \&arr)
\begin{DoxyCompactList}\small\item\em check if a D\+L\+Tensor is contiguous. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1Object}{Object} $\ast$ \hyperlink{namespacetvm_1_1runtime_afdd7050eda88b079f0a962bd413a34ea}{T\+V\+M\+Array\+Handle\+To\+Object\+Handle} (\hyperlink{c__runtime__api_8h_a73ca58cb32f4a4adf71d274dc1e27be4}{T\+V\+M\+Array\+Handle} handle)
\item 
{\footnotesize template$<$typename Relay\+Ref\+Type , typename Object\+Type $>$ }\\\hyperlink{classtvm_1_1RelayRefType}{Relay\+Ref\+Type} \hyperlink{namespacetvm_1_1runtime_aa4a97de4fefd23aa5942c6a545544a05}{Get\+Ref} (const Object\+Type $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Get a reference type from a raw object ptr type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Sub\+Ref , typename Base\+Ref $>$ }\\Sub\+Ref \hyperlink{namespacetvm_1_1runtime_a756a222aed384e208f32d35d3412c918}{Downcast} (Base\+Ref ref)
\begin{DoxyCompactList}\small\item\em Downcast a base reference type to a more specific type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Base\+Type , typename Object\+Type $>$ }\\\hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}$<$ Base\+Type $>$ \hyperlink{namespacetvm_1_1runtime_a46bcf7948293194c5b9c7db91da96381}{Get\+Object\+Ptr} (Object\+Type $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Get an object ptr type from a raw object ptr. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Relay\+Ref\+Type , typename Obj\+Type $>$ }\\\hyperlink{classtvm_1_1RelayRefType}{Relay\+Ref\+Type} \hyperlink{namespacetvm_1_1runtime_ad4c790ddcf38a1ef9800466cd0c1a0a2}{Get\+Ref} (const Obj\+Type $\ast$ptr)
\item 
{\footnotesize template$<$typename Base\+Type , typename Obj\+Type $>$ }\\\hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}$<$ Base\+Type $>$ \hyperlink{namespacetvm_1_1runtime_ac2d903012aff56c2bd54ff66f48450c3}{Get\+Object\+Ptr} (Obj\+Type $\ast$ptr)
\item 
std\+::string \hyperlink{namespacetvm_1_1runtime_a06a49d761ea6373557c24c01eaceb07d}{Get\+Custom\+Type\+Name} (uint8\+\_\+t type\+\_\+code)
\begin{DoxyCompactList}\small\item\em Runtime utility for getting custom type name from code. \end{DoxyCompactList}\item 
bool \hyperlink{namespacetvm_1_1runtime_a1b8eedadc5a269b2f9614ce69a9932e7}{Get\+Custom\+Type\+Registered} (uint8\+\_\+t type\+\_\+code)
\begin{DoxyCompactList}\small\item\em Runtime utility for checking whether custom type is registered. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{namespacetvm_1_1runtime_ac6d167947285dff3c780bd5d01ace9b9}{Parse\+Custom\+Datatype} (const std\+::string \&s, const char $\ast$$\ast$scan)
\begin{DoxyCompactList}\small\item\em Runtime utility for parsing string of the form \char`\"{}custom\mbox{[}$<$typename$>$\mbox{]}\char`\"{}. \end{DoxyCompactList}\item 
const char $\ast$ \hyperlink{namespacetvm_1_1runtime_a504dc7b1fd693412576703f44bcc3cfb}{Type\+Code2\+Str} (int type\+\_\+code)
\begin{DoxyCompactList}\small\item\em Convert type code to its name. \end{DoxyCompactList}\item 
D\+L\+Data\+Type \hyperlink{namespacetvm_1_1runtime_a277f104e659f71cd8885744700016341}{String2\+D\+L\+Data\+Type} (std\+::string s)
\begin{DoxyCompactList}\small\item\em convert a string to T\+VM type. \end{DoxyCompactList}\item 
std\+::string \hyperlink{namespacetvm_1_1runtime_ac360f2d9815036ab1b4d84d9cfb46b4f}{D\+L\+Data\+Type2\+String} (D\+L\+Data\+Type t)
\begin{DoxyCompactList}\small\item\em convert a T\+VM type to string. \end{DoxyCompactList}\item 
std\+::ostream \& \hyperlink{namespacetvm_1_1runtime_a11ed99740d7bb838d96617de83ff2363}{operator$<$$<$} (std\+::ostream \&os, D\+L\+Data\+Type t)
\item 
std\+::ostream \& \hyperlink{namespacetvm_1_1runtime_a59d447b7bdac52d26bca3422fe098f6f}{operator$<$$<$} (std\+::ostream \&os, const \hyperlink{classtvm_1_1runtime_1_1DataType}{Data\+Type} \&dtype)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr int \hyperlink{namespacetvm_1_1runtime_ac8a77303649fb143634796b3dc50a286}{k\+Alloc\+Alignment} = 64
\begin{DoxyCompactList}\small\item\em Number of bytes each allocation must align to. \end{DoxyCompactList}\item 
constexpr int \hyperlink{namespacetvm_1_1runtime_a8f5819cabea098a1818cf7cda40fdb1f}{k\+Temp\+Alloca\+Alignment} = 64
\begin{DoxyCompactList}\small\item\em Number of bytes each allocation must align to in temporary allocation. \end{DoxyCompactList}\item 
constexpr int \hyperlink{namespacetvm_1_1runtime_a2f6f769f6dbbbb24929b7c9f91a48c90}{k\+Max\+Stack\+Alloca} = 1024
\begin{DoxyCompactList}\small\item\em Maximum size that can be allocated on stack. \end{DoxyCompactList}\item 
constexpr int \hyperlink{namespacetvm_1_1runtime_a48cbe06e6c95ca6fabc20dd1cbacc2c9}{k\+R\+P\+C\+Sess\+Mask} = 128
\begin{DoxyCompactList}\small\item\em The device type bigger than this is R\+PC device. \end{DoxyCompactList}\item 
constexpr uint64\+\_\+t \hyperlink{namespacetvm_1_1runtime_acf4599f17bfe79ae1fe8afc1af053b43}{k\+T\+V\+M\+N\+D\+Array\+Magic} = 0x\+D\+D5\+E40\+F096\+B4\+A13F
\begin{DoxyCompactList}\small\item\em Magic number for \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array} file. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Enumeration Type Documentation}
\index{tvm\+::runtime@{tvm\+::runtime}!Device\+Attr\+Kind@{Device\+Attr\+Kind}}
\index{Device\+Attr\+Kind@{Device\+Attr\+Kind}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Device\+Attr\+Kind}{DeviceAttrKind}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::runtime\+::\+Device\+Attr\+Kind} \+: int}\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619}


the query type into Get\+Attr 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Exist@{k\+Exist}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Exist@{k\+Exist}}\item[{\em 
k\+Exist\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619afae6abc73ecd8ccc7f556da2f56e40eb}
}]\index{k\+Max\+Threads\+Per\+Block@{k\+Max\+Threads\+Per\+Block}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Max\+Threads\+Per\+Block@{k\+Max\+Threads\+Per\+Block}}\item[{\em 
k\+Max\+Threads\+Per\+Block\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a1d8a0b62ddd4995257333b10b8e090c4}
}]\index{k\+Warp\+Size@{k\+Warp\+Size}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Warp\+Size@{k\+Warp\+Size}}\item[{\em 
k\+Warp\+Size\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619aa707ea3fd97e625364ad60daa89be2da}
}]\index{k\+Max\+Shared\+Memory\+Per\+Block@{k\+Max\+Shared\+Memory\+Per\+Block}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Max\+Shared\+Memory\+Per\+Block@{k\+Max\+Shared\+Memory\+Per\+Block}}\item[{\em 
k\+Max\+Shared\+Memory\+Per\+Block\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619adff7742765a9f6f50973675bf34ad264}
}]\index{k\+Compute\+Version@{k\+Compute\+Version}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Compute\+Version@{k\+Compute\+Version}}\item[{\em 
k\+Compute\+Version\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ba910261fb30889f38c93be3fff05b}
}]\index{k\+Device\+Name@{k\+Device\+Name}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Device\+Name@{k\+Device\+Name}}\item[{\em 
k\+Device\+Name\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a0ac04959bdda893a53c05024409de9ca}
}]\index{k\+Max\+Clock\+Rate@{k\+Max\+Clock\+Rate}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Max\+Clock\+Rate@{k\+Max\+Clock\+Rate}}\item[{\em 
k\+Max\+Clock\+Rate\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a90ebfaf325917db841553c65ce2ae630}
}]\index{k\+Multi\+Processor\+Count@{k\+Multi\+Processor\+Count}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Multi\+Processor\+Count@{k\+Multi\+Processor\+Count}}\item[{\em 
k\+Multi\+Processor\+Count\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a463bdbf9ce7f9dc87a73d0b787da43cd}
}]\index{k\+Max\+Thread\+Dimensions@{k\+Max\+Thread\+Dimensions}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Max\+Thread\+Dimensions@{k\+Max\+Thread\+Dimensions}}\item[{\em 
k\+Max\+Thread\+Dimensions\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619a66b772d7dc87aede55f700793ab15991}
}]\index{k\+Gcn\+Arch@{k\+Gcn\+Arch}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Gcn\+Arch@{k\+Gcn\+Arch}}\item[{\em 
k\+Gcn\+Arch\hypertarget{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201}{}\label{namespacetvm_1_1runtime_a46fef1ca0ccc05473e9bb0a8c6b66619ad7ca96c2095b4670de00ee1d0ca79201}
}]\end{description}
\end{Desc}
\index{tvm\+::runtime@{tvm\+::runtime}!Type\+Index@{Type\+Index}}
\index{Type\+Index@{Type\+Index}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Type\+Index}{TypeIndex}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf tvm\+::runtime\+::\+Type\+Index}}\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4}


list of the type index. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Root@{k\+Root}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Root@{k\+Root}}\item[{\em 
k\+Root\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a1b73281b45b997205b5082ba53300d6a}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a1b73281b45b997205b5082ba53300d6a}
}]Root object type. \index{k\+Closure@{k\+Closure}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Closure@{k\+Closure}}\item[{\em 
k\+Closure\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a626309e16a9075cc8009c93adf3fbc9f}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a626309e16a9075cc8009c93adf3fbc9f}
}]\index{k\+V\+M\+A\+DT@{k\+V\+M\+A\+DT}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+V\+M\+A\+DT@{k\+V\+M\+A\+DT}}\item[{\em 
k\+V\+M\+A\+DT\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a86d9bc218c0f54443cbbe3fcc5c8382e}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a86d9bc218c0f54443cbbe3fcc5c8382e}
}]\index{k\+Runtime\+Module@{k\+Runtime\+Module}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Runtime\+Module@{k\+Runtime\+Module}}\item[{\em 
k\+Runtime\+Module\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4af5474ebdbaaa19e977334eefa4bbd611}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4af5474ebdbaaa19e977334eefa4bbd611}
}]\index{k\+Static\+Index\+End@{k\+Static\+Index\+End}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Static\+Index\+End@{k\+Static\+Index\+End}}\item[{\em 
k\+Static\+Index\+End\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a548302094bc9afb6bb14dc2a283c1014}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a548302094bc9afb6bb14dc2a283c1014}
}]\index{k\+Dynamic@{k\+Dynamic}!tvm\+::runtime@{tvm\+::runtime}}\index{tvm\+::runtime@{tvm\+::runtime}!k\+Dynamic@{k\+Dynamic}}\item[{\em 
k\+Dynamic\hypertarget{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a633f5947b3a79c577b538cec7528f5aa}{}\label{namespacetvm_1_1runtime_a7d395cd724f727e86358b73b5cdeb4e4a633f5947b3a79c577b538cec7528f5aa}
}]\hyperlink{classtvm_1_1Type}{Type} index is allocated during runtime. \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{tvm\+::runtime@{tvm\+::runtime}!Device\+Name@{Device\+Name}}
\index{Device\+Name@{Device\+Name}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Device\+Name(int type)}{DeviceName(int type)}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ tvm\+::runtime\+::\+Device\+Name (
\begin{DoxyParamCaption}
\item[{int}]{type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a9109e4efe269213052ed6a94853c0c00}{}\label{namespacetvm_1_1runtime_a9109e4efe269213052ed6a94853c0c00}


The name of Device A\+PI factory. 


\begin{DoxyParams}{Parameters}
{\em type} & The device type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the device name. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!D\+L\+Data\+Type2\+String@{D\+L\+Data\+Type2\+String}}
\index{D\+L\+Data\+Type2\+String@{D\+L\+Data\+Type2\+String}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{D\+L\+Data\+Type2\+String(\+D\+L\+Data\+Type t)}{DLDataType2String(DLDataType t)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string tvm\+::runtime\+::\+D\+L\+Data\+Type2\+String (
\begin{DoxyParamCaption}
\item[{D\+L\+Data\+Type}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_ac360f2d9815036ab1b4d84d9cfb46b4f}{}\label{namespacetvm_1_1runtime_ac360f2d9815036ab1b4d84d9cfb46b4f}


convert a T\+VM type to string. 


\begin{DoxyParams}{Parameters}
{\em t} & The type to be converted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding tvm type in string. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Downcast@{Downcast}}
\index{Downcast@{Downcast}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Downcast(\+Base\+Ref ref)}{Downcast(BaseRef ref)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Sub\+Ref , typename Base\+Ref $>$ Sub\+Ref tvm\+::runtime\+::\+Downcast (
\begin{DoxyParamCaption}
\item[{Base\+Ref}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a756a222aed384e208f32d35d3412c918}{}\label{namespacetvm_1_1runtime_a756a222aed384e208f32d35d3412c918}


Downcast a base reference type to a more specific type. 


\begin{DoxyParams}{Parameters}
{\em ref} & The inptut reference \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding Sub\+Ref. 
\end{DoxyReturn}

\begin{DoxyTemplParams}{Template Parameters}
{\em Sub\+Ref} & The target specific reference type. \\
\hline
{\em Base\+Ref} & the current reference type. \\
\hline
\end{DoxyTemplParams}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Custom\+Type\+Name@{Get\+Custom\+Type\+Name}}
\index{Get\+Custom\+Type\+Name@{Get\+Custom\+Type\+Name}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Custom\+Type\+Name(uint8\+\_\+t type\+\_\+code)}{GetCustomTypeName(uint8_t type_code)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string tvm\+::runtime\+::\+Get\+Custom\+Type\+Name (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type\+\_\+code}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1runtime_a06a49d761ea6373557c24c01eaceb07d}{}\label{namespacetvm_1_1runtime_a06a49d761ea6373557c24c01eaceb07d}


Runtime utility for getting custom type name from code. 


\begin{DoxyParams}{Parameters}
{\em type\+\_\+code} & Custom type code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Custom type name 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Custom\+Type\+Registered@{Get\+Custom\+Type\+Registered}}
\index{Get\+Custom\+Type\+Registered@{Get\+Custom\+Type\+Registered}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Custom\+Type\+Registered(uint8\+\_\+t type\+\_\+code)}{GetCustomTypeRegistered(uint8_t type_code)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Get\+Custom\+Type\+Registered (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{type\+\_\+code}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1runtime_a1b8eedadc5a269b2f9614ce69a9932e7}{}\label{namespacetvm_1_1runtime_a1b8eedadc5a269b2f9614ce69a9932e7}


Runtime utility for checking whether custom type is registered. 


\begin{DoxyParams}{Parameters}
{\em type\+\_\+code} & Custom type code \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Bool representing whether type is registered 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Data\+Size@{Get\+Data\+Size}}
\index{Get\+Data\+Size@{Get\+Data\+Size}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Data\+Size(const D\+L\+Tensor \&arr)}{GetDataSize(const DLTensor &arr)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t tvm\+::runtime\+::\+Get\+Data\+Size (
\begin{DoxyParamCaption}
\item[{const D\+L\+Tensor \&}]{arr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a59940b6d63dd4c5175c0fe875047c1cf}{}\label{namespacetvm_1_1runtime_a59940b6d63dd4c5175c0fe875047c1cf}


return the size of data the D\+L\+Tensor hold, in term of number of bytes 


\begin{DoxyParams}{Parameters}
{\em arr} & the input D\+L\+Tensor \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes of data in the D\+L\+Tensor. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Object\+Ptr@{Get\+Object\+Ptr}}
\index{Get\+Object\+Ptr@{Get\+Object\+Ptr}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Object\+Ptr(\+Object\+Type $\ast$ptr)}{GetObjectPtr(ObjectType *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Base\+Type , typename Object\+Type $>$ {\bf Object\+Ptr}$<$Base\+Type$>$ tvm\+::runtime\+::\+Get\+Object\+Ptr (
\begin{DoxyParamCaption}
\item[{Object\+Type $\ast$}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a46bcf7948293194c5b9c7db91da96381}{}\label{namespacetvm_1_1runtime_a46bcf7948293194c5b9c7db91da96381}


Get an object ptr type from a raw object ptr. 


\begin{DoxyParams}{Parameters}
{\em ptr} & The object pointer \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Base\+Type} & The reference type \\
\hline
{\em Object\+Type} & The object type \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
The corresponding Ref\+Type 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Object\+Ptr@{Get\+Object\+Ptr}}
\index{Get\+Object\+Ptr@{Get\+Object\+Ptr}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Object\+Ptr(\+Obj\+Type $\ast$ptr)}{GetObjectPtr(ObjType *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Base\+Type , typename Obj\+Type $>$ {\bf Object\+Ptr}$<$Base\+Type$>$ tvm\+::runtime\+::\+Get\+Object\+Ptr (
\begin{DoxyParamCaption}
\item[{Obj\+Type $\ast$}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_ac2d903012aff56c2bd54ff66f48450c3}{}\label{namespacetvm_1_1runtime_ac2d903012aff56c2bd54ff66f48450c3}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Ref@{Get\+Ref}}
\index{Get\+Ref@{Get\+Ref}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Ref(const Object\+Type $\ast$ptr)}{GetRef(const ObjectType *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Relay\+Ref\+Type , typename Object\+Type $>$ {\bf Relay\+Ref\+Type} tvm\+::runtime\+::\+Get\+Ref (
\begin{DoxyParamCaption}
\item[{const Object\+Type $\ast$}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_aa4a97de4fefd23aa5942c6a545544a05}{}\label{namespacetvm_1_1runtime_aa4a97de4fefd23aa5942c6a545544a05}


Get a reference type from a raw object ptr type. 

It is always important to get a reference type if we want to return a value as reference or keep the object alive beyond the scope of the function.


\begin{DoxyParams}{Parameters}
{\em ptr} & The object pointer \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em Ref\+Type} & The reference type \\
\hline
{\em Object\+Type} & The object type \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
The corresponding Ref\+Type 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Ref@{Get\+Ref}}
\index{Get\+Ref@{Get\+Ref}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Ref(const Obj\+Type $\ast$ptr)}{GetRef(const ObjType *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Relay\+Ref\+Type , typename Obj\+Type $>$ {\bf Relay\+Ref\+Type} tvm\+::runtime\+::\+Get\+Ref (
\begin{DoxyParamCaption}
\item[{const Obj\+Type $\ast$}]{ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_ad4c790ddcf38a1ef9800466cd0c1a0a2}{}\label{namespacetvm_1_1runtime_ad4c790ddcf38a1ef9800466cd0c1a0a2}
\index{tvm\+::runtime@{tvm\+::runtime}!Get\+Vector\+Bytes@{Get\+Vector\+Bytes}}
\index{Get\+Vector\+Bytes@{Get\+Vector\+Bytes}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Get\+Vector\+Bytes(\+Data\+Type dtype)}{GetVectorBytes(DataType dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}int tvm\+::runtime\+::\+Get\+Vector\+Bytes (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Type}}]{dtype}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_ad01a53416152b68029d67190c3709d25}{}\label{namespacetvm_1_1runtime_ad01a53416152b68029d67190c3709d25}


Get the number of bytes needed in a vector. 


\begin{DoxyParams}{Parameters}
{\em dtype} & The data type. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes needed. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Is\+Contiguous@{Is\+Contiguous}}
\index{Is\+Contiguous@{Is\+Contiguous}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Is\+Contiguous(const D\+L\+Tensor \&arr)}{IsContiguous(const DLTensor &arr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Is\+Contiguous (
\begin{DoxyParamCaption}
\item[{const D\+L\+Tensor \&}]{arr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_adb2ed1227b418f5846d43d3234b52391}{}\label{namespacetvm_1_1runtime_adb2ed1227b418f5846d43d3234b52391}


check if a D\+L\+Tensor is contiguous. 


\begin{DoxyParams}{Parameters}
{\em arr} & The input D\+L\+Tensor. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The check result. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!make\+\_\+inplace\+\_\+array\+\_\+object@{make\+\_\+inplace\+\_\+array\+\_\+object}}
\index{make\+\_\+inplace\+\_\+array\+\_\+object@{make\+\_\+inplace\+\_\+array\+\_\+object}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{make\+\_\+inplace\+\_\+array\+\_\+object(size\+\_\+t num\+\_\+elems, Args \&\&...\+args)}{make_inplace_array_object(size_t num_elems, Args &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Array\+Type , typename Elem\+Type , typename... Args$>$ {\bf Object\+Ptr}$<$Array\+Type$>$ tvm\+::runtime\+::make\+\_\+inplace\+\_\+array\+\_\+object (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{num\+\_\+elems, }
\item[{Args \&\&...}]{args}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a144496aaff68cd251b6bc0a7b24ca041}{}\label{namespacetvm_1_1runtime_a144496aaff68cd251b6bc0a7b24ca041}
\index{tvm\+::runtime@{tvm\+::runtime}!make\+\_\+object@{make\+\_\+object}}
\index{make\+\_\+object@{make\+\_\+object}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{make\+\_\+object(\+Args \&\&...\+args)}{make_object(Args &&...args)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename... Args$>$ {\bf Object\+Ptr}$<$ T $>$ tvm\+::runtime\+::make\+\_\+object (
\begin{DoxyParamCaption}
\item[{Args \&\&...}]{args}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a93466f4543eedc3925c66ed0e7ef2671}{}\label{namespacetvm_1_1runtime_a93466f4543eedc3925c66ed0e7ef2671}


Allocate an object using default allocator. 


\begin{DoxyParams}{Parameters}
{\em args} & arguments to the constructor. \\
\hline
\end{DoxyParams}

\begin{DoxyTemplParams}{Template Parameters}
{\em T} & the node type. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
The \hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr} to the allocated object. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, const Object\+Ref \&n)}{operator<<(std::ostream &os, const ObjectRef &n)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& tvm\+::runtime\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Object\+Ref} \&}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_af22b89284299c81d0c1802199af446d7}{}\label{namespacetvm_1_1runtime_af22b89284299c81d0c1802199af446d7}
\index{tvm\+::runtime@{tvm\+::runtime}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, D\+L\+Context ctx)}{operator<<(std::ostream &os, DLContext ctx)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& tvm\+::runtime\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{D\+L\+Context}]{ctx}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a0ce391c2492dfc73b5c6c6459693c6a6}{}\label{namespacetvm_1_1runtime_a0ce391c2492dfc73b5c6c6459693c6a6}
\index{tvm\+::runtime@{tvm\+::runtime}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, D\+L\+Data\+Type t)}{operator<<(std::ostream &os, DLDataType t)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& tvm\+::runtime\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{D\+L\+Data\+Type}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a11ed99740d7bb838d96617de83ff2363}{}\label{namespacetvm_1_1runtime_a11ed99740d7bb838d96617de83ff2363}
\index{tvm\+::runtime@{tvm\+::runtime}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{operator$<$$<$(std\+::ostream \&os, const Data\+Type \&dtype)}{operator<<(std::ostream &os, const DataType &dtype)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& tvm\+::runtime\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Data\+Type} \&}]{dtype}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a59d447b7bdac52d26bca3422fe098f6f}{}\label{namespacetvm_1_1runtime_a59d447b7bdac52d26bca3422fe098f6f}
\index{tvm\+::runtime@{tvm\+::runtime}!Parse\+Custom\+Datatype@{Parse\+Custom\+Datatype}}
\index{Parse\+Custom\+Datatype@{Parse\+Custom\+Datatype}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Parse\+Custom\+Datatype(const std\+::string \&s, const char $\ast$$\ast$scan)}{ParseCustomDatatype(const std::string &s, const char **scan)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t tvm\+::runtime\+::\+Parse\+Custom\+Datatype (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{s, }
\item[{const char $\ast$$\ast$}]{scan}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1runtime_ac6d167947285dff3c780bd5d01ace9b9}{}\label{namespacetvm_1_1runtime_ac6d167947285dff3c780bd5d01ace9b9}


Runtime utility for parsing string of the form \char`\"{}custom\mbox{[}$<$typename$>$\mbox{]}\char`\"{}. 


\begin{DoxyParams}{Parameters}
{\em s} & \hyperlink{classtvm_1_1runtime_1_1String}{String} to parse \\
\hline
{\em scan} & pointer to parsing pointer, which is scanning across s \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
type code of custom type parsed 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Runtime\+Enabled@{Runtime\+Enabled}}
\index{Runtime\+Enabled@{Runtime\+Enabled}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Runtime\+Enabled(const std\+::string \&target)}{RuntimeEnabled(const std::string &target)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Runtime\+Enabled (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{target}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1runtime_abbea0c23882ae01431ac7fe6506b32a7}{}\label{namespacetvm_1_1runtime_abbea0c23882ae01431ac7fe6506b32a7}


Check if runtime module is enabled for target. 


\begin{DoxyParams}{Parameters}
{\em target} & The target module name. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether runtime is enabled. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Save\+D\+L\+Tensor@{Save\+D\+L\+Tensor}}
\index{Save\+D\+L\+Tensor@{Save\+D\+L\+Tensor}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Save\+D\+L\+Tensor(dmlc\+::\+Stream $\ast$strm, const D\+L\+Tensor $\ast$tensor)}{SaveDLTensor(dmlc::Stream *strm, const DLTensor *tensor)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Save\+D\+L\+Tensor (
\begin{DoxyParamCaption}
\item[{dmlc\+::\+Stream $\ast$}]{strm, }
\item[{const D\+L\+Tensor $\ast$}]{tensor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a8fb37910dcd9bb6899e6a3a47f006514}{}\label{namespacetvm_1_1runtime_a8fb37910dcd9bb6899e6a3a47f006514}


Save a D\+L\+Tensor to stream. 


\begin{DoxyParams}{Parameters}
{\em strm} & The output stream \\
\hline
{\em tensor} & The tensor to be saved. \\
\hline
\end{DoxyParams}
\index{tvm\+::runtime@{tvm\+::runtime}!String2\+D\+L\+Data\+Type@{String2\+D\+L\+Data\+Type}}
\index{String2\+D\+L\+Data\+Type@{String2\+D\+L\+Data\+Type}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{String2\+D\+L\+Data\+Type(std\+::string s)}{String2DLDataType(std::string s)}}]{\setlength{\rightskip}{0pt plus 5cm}D\+L\+Data\+Type tvm\+::runtime\+::\+String2\+D\+L\+Data\+Type (
\begin{DoxyParamCaption}
\item[{std\+::string}]{s}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a277f104e659f71cd8885744700016341}{}\label{namespacetvm_1_1runtime_a277f104e659f71cd8885744700016341}


convert a string to T\+VM type. 


\begin{DoxyParams}{Parameters}
{\em s} & The string to be converted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding tvm type. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!T\+V\+M\+Array\+Handle\+To\+Object\+Handle@{T\+V\+M\+Array\+Handle\+To\+Object\+Handle}}
\index{T\+V\+M\+Array\+Handle\+To\+Object\+Handle@{T\+V\+M\+Array\+Handle\+To\+Object\+Handle}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Array\+Handle\+To\+Object\+Handle(\+T\+V\+M\+Array\+Handle handle)}{TVMArrayHandleToObjectHandle(TVMArrayHandle handle)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Object}$\ast$ tvm\+::runtime\+::\+T\+V\+M\+Array\+Handle\+To\+Object\+Handle (
\begin{DoxyParamCaption}
\item[{{\bf T\+V\+M\+Array\+Handle}}]{handle}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_afdd7050eda88b079f0a962bd413a34ea}{}\label{namespacetvm_1_1runtime_afdd7050eda88b079f0a962bd413a34ea}
\index{tvm\+::runtime@{tvm\+::runtime}!Type\+Code2\+Str@{Type\+Code2\+Str}}
\index{Type\+Code2\+Str@{Type\+Code2\+Str}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Type\+Code2\+Str(int type\+\_\+code)}{TypeCode2Str(int type_code)}}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ tvm\+::runtime\+::\+Type\+Code2\+Str (
\begin{DoxyParamCaption}
\item[{int}]{type\+\_\+code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_a504dc7b1fd693412576703f44bcc3cfb}{}\label{namespacetvm_1_1runtime_a504dc7b1fd693412576703f44bcc3cfb}


Convert type code to its name. 


\begin{DoxyParams}{Parameters}
{\em type\+\_\+code} & The type code . \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The name of type code. 
\end{DoxyReturn}
\index{tvm\+::runtime@{tvm\+::runtime}!Type\+Equal@{Type\+Equal}}
\index{Type\+Equal@{Type\+Equal}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Type\+Equal(\+D\+L\+Data\+Type lhs, D\+L\+Data\+Type rhs)}{TypeEqual(DLDataType lhs, DLDataType rhs)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Type\+Equal (
\begin{DoxyParamCaption}
\item[{D\+L\+Data\+Type}]{lhs, }
\item[{D\+L\+Data\+Type}]{rhs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_aee574cee6755b0c2f1aa664c6967686f}{}\label{namespacetvm_1_1runtime_aee574cee6755b0c2f1aa664c6967686f}


Check whether two types are equal . 


\begin{DoxyParams}{Parameters}
{\em lhs} & The left operand. \\
\hline
{\em rhs} & The right operand. \\
\hline
\end{DoxyParams}
\index{tvm\+::runtime@{tvm\+::runtime}!Type\+Match@{Type\+Match}}
\index{Type\+Match@{Type\+Match}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{Type\+Match(\+D\+L\+Data\+Type t, int code, int bits, int lanes=1)}{TypeMatch(DLDataType t, int code, int bits, int lanes=1)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::runtime\+::\+Type\+Match (
\begin{DoxyParamCaption}
\item[{D\+L\+Data\+Type}]{t, }
\item[{int}]{code, }
\item[{int}]{bits, }
\item[{int}]{lanes = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1runtime_adbabb7cfb79bfb6d802f65a9803e4eb6}{}\label{namespacetvm_1_1runtime_adbabb7cfb79bfb6d802f65a9803e4eb6}


Check whether type matches the given spec. 


\begin{DoxyParams}{Parameters}
{\em t} & The type \\
\hline
{\em code} & The type code. \\
\hline
{\em bits} & The number of bits to be matched. \\
\hline
{\em lanes} & The number of lanes in the type. \\
\hline
\end{DoxyParams}


\subsection{Variable Documentation}
\index{tvm\+::runtime@{tvm\+::runtime}!k\+Alloc\+Alignment@{k\+Alloc\+Alignment}}
\index{k\+Alloc\+Alignment@{k\+Alloc\+Alignment}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{k\+Alloc\+Alignment}{kAllocAlignment}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr int tvm\+::runtime\+::k\+Alloc\+Alignment = 64}\hypertarget{namespacetvm_1_1runtime_ac8a77303649fb143634796b3dc50a286}{}\label{namespacetvm_1_1runtime_ac8a77303649fb143634796b3dc50a286}


Number of bytes each allocation must align to. 

\index{tvm\+::runtime@{tvm\+::runtime}!k\+Max\+Stack\+Alloca@{k\+Max\+Stack\+Alloca}}
\index{k\+Max\+Stack\+Alloca@{k\+Max\+Stack\+Alloca}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{k\+Max\+Stack\+Alloca}{kMaxStackAlloca}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr int tvm\+::runtime\+::k\+Max\+Stack\+Alloca = 1024}\hypertarget{namespacetvm_1_1runtime_a2f6f769f6dbbbb24929b7c9f91a48c90}{}\label{namespacetvm_1_1runtime_a2f6f769f6dbbbb24929b7c9f91a48c90}


Maximum size that can be allocated on stack. 

\index{tvm\+::runtime@{tvm\+::runtime}!k\+R\+P\+C\+Sess\+Mask@{k\+R\+P\+C\+Sess\+Mask}}
\index{k\+R\+P\+C\+Sess\+Mask@{k\+R\+P\+C\+Sess\+Mask}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{k\+R\+P\+C\+Sess\+Mask}{kRPCSessMask}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr int tvm\+::runtime\+::k\+R\+P\+C\+Sess\+Mask = 128}\hypertarget{namespacetvm_1_1runtime_a48cbe06e6c95ca6fabc20dd1cbacc2c9}{}\label{namespacetvm_1_1runtime_a48cbe06e6c95ca6fabc20dd1cbacc2c9}


The device type bigger than this is R\+PC device. 

\index{tvm\+::runtime@{tvm\+::runtime}!k\+Temp\+Alloca\+Alignment@{k\+Temp\+Alloca\+Alignment}}
\index{k\+Temp\+Alloca\+Alignment@{k\+Temp\+Alloca\+Alignment}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{k\+Temp\+Alloca\+Alignment}{kTempAllocaAlignment}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr int tvm\+::runtime\+::k\+Temp\+Alloca\+Alignment = 64}\hypertarget{namespacetvm_1_1runtime_a8f5819cabea098a1818cf7cda40fdb1f}{}\label{namespacetvm_1_1runtime_a8f5819cabea098a1818cf7cda40fdb1f}


Number of bytes each allocation must align to in temporary allocation. 

\index{tvm\+::runtime@{tvm\+::runtime}!k\+T\+V\+M\+N\+D\+Array\+Magic@{k\+T\+V\+M\+N\+D\+Array\+Magic}}
\index{k\+T\+V\+M\+N\+D\+Array\+Magic@{k\+T\+V\+M\+N\+D\+Array\+Magic}!tvm\+::runtime@{tvm\+::runtime}}
\subsubsection[{\texorpdfstring{k\+T\+V\+M\+N\+D\+Array\+Magic}{kTVMNDArrayMagic}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr uint64\+\_\+t tvm\+::runtime\+::k\+T\+V\+M\+N\+D\+Array\+Magic = 0x\+D\+D5\+E40\+F096\+B4\+A13F}\hypertarget{namespacetvm_1_1runtime_acf4599f17bfe79ae1fe8afc1af053b43}{}\label{namespacetvm_1_1runtime_acf4599f17bfe79ae1fe8afc1af053b43}


Magic number for \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array} file. 

