\hypertarget{namespacetvm_1_1relay_1_1transform}{}\section{tvm\+:\+:relay\+:\+:transform Namespace Reference}
\label{namespacetvm_1_1relay_1_1transform}\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} = \hyperlink{classtvm_1_1transform_1_1Pass}{tvm\+::transform\+::\+Pass}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_aa695a8dfc3d5b087018ddd4ef1eb2487}{Pass\+Node} = \hyperlink{classtvm_1_1transform_1_1PassNode}{tvm\+::transform\+::\+Pass\+Node}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_aa405b5f11938fb8c4fa2ca21926edc9d}{Pass\+Info} = \hyperlink{classtvm_1_1transform_1_1PassInfo}{tvm\+::transform\+::\+Pass\+Info}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_aae88cd0ad69cf64c7e9caf0a0c8ebb45}{Pass\+Info\+Node} = \hyperlink{classtvm_1_1transform_1_1PassInfoNode}{tvm\+::transform\+::\+Pass\+Info\+Node}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_a744a05f8bba3c2ac238ba4569d926184}{Pass\+Context} = \hyperlink{classtvm_1_1transform_1_1PassContext}{tvm\+::transform\+::\+Pass\+Context}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_a72900733e0d3510ae61a1c287c2ec125}{Pass\+Context\+Node} = \hyperlink{classtvm_1_1transform_1_1PassContextNode}{tvm\+::transform\+::\+Pass\+Context\+Node}
\item 
using \hyperlink{namespacetvm_1_1relay_1_1transform_a3ae923037d22b4640b450c06e6c1e33e}{Sequential} = \hyperlink{classtvm_1_1transform_1_1Sequential}{tvm\+::transform\+::\+Sequential}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aba687537c5fd54db0012c745bba74a85}{Create\+Function\+Pass} (const \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc}{runtime\+::\+Typed\+Packed\+Func}$<$ \hyperlink{classtvm_1_1relay_1_1Function}{Function}(\hyperlink{classtvm_1_1relay_1_1Function}{Function}, \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}, \hyperlink{namespacetvm_1_1relay_1_1transform_a744a05f8bba3c2ac238ba4569d926184}{Pass\+Context})$>$ \&pass\+\_\+func, int opt\+\_\+level, const std\+::string \&name, const \hyperlink{classtvm_1_1Array}{tvm\+::\+Array}$<$ \hyperlink{classtvm_1_1PrimExpr}{tvm\+::\+Prim\+Expr} $>$ \&required)
\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aaa08e0ced82fc7efe515d610104b070c}{Dead\+Code\+Elimination} (bool inline\+\_\+once=false)
\begin{DoxyCompactList}\small\item\em Remove expressions which does not effect the program result. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_ab6e60251741cca1e811564b2f03a4a5d}{Lazy\+Gradient\+Init} ()
\begin{DoxyCompactList}\small\item\em Convert all expressions of \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} into Grad\+Cell, an algebraic data type defined in gradient.\+rly. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a41656c71a440f1f9c9eae0aa409d2b22}{Fold\+Constant} ()
\begin{DoxyCompactList}\small\item\em Fold constant expressions. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a2a6be6024a96a84f7230faa2519f1a97}{Fuse\+Ops} (int fuse\+\_\+opt\+\_\+level=-\/1)
\begin{DoxyCompactList}\small\item\em Fuse operations into expr into seperate functions. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a03b053f3d99d5c420ddc8492e6b987bf}{Rewrite\+Annotated\+Ops} (int fallback\+\_\+device)
\begin{DoxyCompactList}\small\item\em Rewrite the annotated program. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a8cb03cf00b2ddf25f183ab837cde713c}{To\+A\+Normal\+Form} ()
\begin{DoxyCompactList}\small\item\em turn a dataflow graph into Administrative Normal Form, or A-\/\+Normal Form (A\+NF). \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_ad90e4d6ac08b62ef553755e759d398fa}{To\+C\+PS} ()
\begin{DoxyCompactList}\small\item\em Turn an expression into continuation passing style(\+C\+P\+S). \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a2cfef0e02cca22f3e0e85e0a10a82f5b}{To\+Graph\+Normal\+Form} ()
\begin{DoxyCompactList}\small\item\em Remove let binding and directly share via pointer instead. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aa270d98da5518969e005c7e30d6eb6fe}{Partial\+Eval} ()
\begin{DoxyCompactList}\small\item\em Aggressive constant propagation/constant folding/inlining. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_add13a2ad7b216ad4683141bbbb4f6943}{Simplify\+Inference} ()
\begin{DoxyCompactList}\small\item\em Simplify certain operators during inference. For example, batch norm will be unpacked into a number of simplified operators. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a22870dd16693b2e3edb5fba7cb5dc3e8}{Fast\+Math} ()
\begin{DoxyCompactList}\small\item\em Replaces non linear activation functions with their fast but approximate counterparts. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a1a4fe2161bf32a60bc2e57debab083ee}{Infer\+Type} ()
\begin{DoxyCompactList}\small\item\em Infer the type of an expression. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_adf21ade01969835b155241d277a94d1c}{Eliminate\+Common\+Subexpr} (\hyperlink{classtvm_1_1runtime_1_1PackedFunc}{runtime\+::\+Packed\+Func} fskip=nullptr)
\begin{DoxyCompactList}\small\item\em Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a3b8f4cbf0bd699d2ca0ab92c534c867d}{Combine\+Parallel\+Conv2D} (uint64\+\_\+t min\+\_\+num\+\_\+branches=3)
\begin{DoxyCompactList}\small\item\em Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than {\ttfamily min\+\_\+num\+\_\+branch}. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a186d1029887d7b33d002798d414f4d31}{Combine\+Parallel\+Dense} (uint64\+\_\+t min\+\_\+num\+\_\+branches=3)
\begin{DoxyCompactList}\small\item\em Combine parallel dense ops into a single batch\+\_\+matmul if the number of branches of this dense operator is not less than {\ttfamily min\+\_\+num\+\_\+branch}. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a3bde64d7774dcda7735f73a4e2ebecf7}{Backward\+Fold\+Scale\+Axis} ()
\begin{DoxyCompactList}\small\item\em Backward fold axis scaling into weights of conv/dense operators. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aab7f62610e05ed0211f17d452ee37f5f}{Forward\+Fold\+Scale\+Axis} ()
\begin{DoxyCompactList}\small\item\em Forward fold axis scaling into weights of conv/dense operators. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a73946a29efe8cf6f186a681296c8e943}{Fold\+Scale\+Axis} ()
\begin{DoxyCompactList}\small\item\em A sequential pass that executes Forward\+Fold\+Scale\+Axis and Backward\+Fold\+Scale\+Axis passes. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_adcddf150ca7da40e20408928421b0086}{Canonicalize\+Ops} ()
\begin{DoxyCompactList}\small\item\em Canonicalize some operators to the simplified operators. For example, bias\+\_\+add can be canonicalized to expand\+\_\+dims and broadcast\+\_\+add. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a64e0426cfa5887f11769a057c09ce8ba}{Alter\+Op\+Layout} ()
\begin{DoxyCompactList}\small\item\em Alternate the layouts of operators or replace primitive operators with other expressions. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_ad12225e2ad26ae24fca669e180026689}{Convert\+Layout} (const std\+::string \&desired\+\_\+layout)
\begin{DoxyCompactList}\small\item\em Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a459fec81f00a7a17c5cf7dabe5e4e363}{Legalize} (const std\+::string \&legalize\+\_\+map\+\_\+attr\+\_\+name=\char`\"{}F\+T\+V\+M\+Legalize\char`\"{})
\begin{DoxyCompactList}\small\item\em Legalizes an expr with another expression. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a93bbf7ab3f612d4f38a6832d6b53b4fd}{Canonicalize\+Cast} ()
\begin{DoxyCompactList}\small\item\em Canonicalize cast expressions to make operator fusion more efficient. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a6e515696ecc9ff4222af99fef361de4e}{Eta\+Expand} (bool expand\+\_\+constructor, bool expand\+\_\+global\+\_\+var)
\begin{DoxyCompactList}\small\item\em Add abstraction over a constructor or global variable bound to a function. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_a065b5d8be6fd8dbfcef44dfa48adeb29}{Print\+IR} (bool show\+\_\+meta\+\_\+data=true)
\begin{DoxyCompactList}\small\item\em Print the IR for a module to help debugging. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aac0bfdaf6d09b360602243c81abe05a1}{Partition\+Graph} ()
\begin{DoxyCompactList}\small\item\em Partition a Relay program into regions that can be executed on different backends. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_aba5e588279a3b19a119c9aa28c364bbe}{Inline} ()
\begin{DoxyCompactList}\small\item\em Inline the global functions marked as {\ttfamily inline} in a given Relay \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}. \end{DoxyCompactList}\item 
\hyperlink{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{Pass} \hyperlink{namespacetvm_1_1relay_1_1transform_abdccee126a74a602e3669bdfaf0f259c}{Remove\+Unused\+Functions} (\hyperlink{classtvm_1_1Array}{Array}$<$ \hyperlink{classtvm_1_1PrimExpr}{tvm\+::\+Prim\+Expr} $>$ entry\+\_\+functions)
\begin{DoxyCompactList}\small\item\em Remove the unused functions in the Relay \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass@{Pass}}
\index{Pass@{Pass}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass}{Pass}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass} = typedef {\bf tvm\+::transform\+::\+Pass}}\hypertarget{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}{}\label{namespacetvm_1_1relay_1_1transform_afa666ade112e9955059095d695238a9a}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass\+Context@{Pass\+Context}}
\index{Pass\+Context@{Pass\+Context}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass\+Context}{PassContext}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass\+Context} = typedef {\bf tvm\+::transform\+::\+Pass\+Context}}\hypertarget{namespacetvm_1_1relay_1_1transform_a744a05f8bba3c2ac238ba4569d926184}{}\label{namespacetvm_1_1relay_1_1transform_a744a05f8bba3c2ac238ba4569d926184}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass\+Context\+Node@{Pass\+Context\+Node}}
\index{Pass\+Context\+Node@{Pass\+Context\+Node}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass\+Context\+Node}{PassContextNode}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass\+Context\+Node} = typedef {\bf tvm\+::transform\+::\+Pass\+Context\+Node}}\hypertarget{namespacetvm_1_1relay_1_1transform_a72900733e0d3510ae61a1c287c2ec125}{}\label{namespacetvm_1_1relay_1_1transform_a72900733e0d3510ae61a1c287c2ec125}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass\+Info@{Pass\+Info}}
\index{Pass\+Info@{Pass\+Info}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass\+Info}{PassInfo}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass\+Info} = typedef {\bf tvm\+::transform\+::\+Pass\+Info}}\hypertarget{namespacetvm_1_1relay_1_1transform_aa405b5f11938fb8c4fa2ca21926edc9d}{}\label{namespacetvm_1_1relay_1_1transform_aa405b5f11938fb8c4fa2ca21926edc9d}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass\+Info\+Node@{Pass\+Info\+Node}}
\index{Pass\+Info\+Node@{Pass\+Info\+Node}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass\+Info\+Node}{PassInfoNode}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass\+Info\+Node} = typedef {\bf tvm\+::transform\+::\+Pass\+Info\+Node}}\hypertarget{namespacetvm_1_1relay_1_1transform_aae88cd0ad69cf64c7e9caf0a0c8ebb45}{}\label{namespacetvm_1_1relay_1_1transform_aae88cd0ad69cf64c7e9caf0a0c8ebb45}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Pass\+Node@{Pass\+Node}}
\index{Pass\+Node@{Pass\+Node}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Pass\+Node}{PassNode}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Pass\+Node} = typedef {\bf tvm\+::transform\+::\+Pass\+Node}}\hypertarget{namespacetvm_1_1relay_1_1transform_aa695a8dfc3d5b087018ddd4ef1eb2487}{}\label{namespacetvm_1_1relay_1_1transform_aa695a8dfc3d5b087018ddd4ef1eb2487}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Sequential@{Sequential}}
\index{Sequential@{Sequential}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Sequential}{Sequential}}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf tvm\+::relay\+::transform\+::\+Sequential} = typedef {\bf tvm\+::transform\+::\+Sequential}}\hypertarget{namespacetvm_1_1relay_1_1transform_a3ae923037d22b4640b450c06e6c1e33e}{}\label{namespacetvm_1_1relay_1_1transform_a3ae923037d22b4640b450c06e6c1e33e}


\subsection{Function Documentation}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Alter\+Op\+Layout@{Alter\+Op\+Layout}}
\index{Alter\+Op\+Layout@{Alter\+Op\+Layout}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Alter\+Op\+Layout()}{AlterOpLayout()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Alter\+Op\+Layout (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a64e0426cfa5887f11769a057c09ce8ba}{}\label{namespacetvm_1_1relay_1_1transform_a64e0426cfa5887f11769a057c09ce8ba}


Alternate the layouts of operators or replace primitive operators with other expressions. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Backward\+Fold\+Scale\+Axis@{Backward\+Fold\+Scale\+Axis}}
\index{Backward\+Fold\+Scale\+Axis@{Backward\+Fold\+Scale\+Axis}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Backward\+Fold\+Scale\+Axis()}{BackwardFoldScaleAxis()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Backward\+Fold\+Scale\+Axis (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a3bde64d7774dcda7735f73a4e2ebecf7}{}\label{namespacetvm_1_1relay_1_1transform_a3bde64d7774dcda7735f73a4e2ebecf7}


Backward fold axis scaling into weights of conv/dense operators. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Canonicalize\+Cast@{Canonicalize\+Cast}}
\index{Canonicalize\+Cast@{Canonicalize\+Cast}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Canonicalize\+Cast()}{CanonicalizeCast()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Canonicalize\+Cast (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a93bbf7ab3f612d4f38a6832d6b53b4fd}{}\label{namespacetvm_1_1relay_1_1transform_a93bbf7ab3f612d4f38a6832d6b53b4fd}


Canonicalize cast expressions to make operator fusion more efficient. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Canonicalize\+Ops@{Canonicalize\+Ops}}
\index{Canonicalize\+Ops@{Canonicalize\+Ops}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Canonicalize\+Ops()}{CanonicalizeOps()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Canonicalize\+Ops (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_adcddf150ca7da40e20408928421b0086}{}\label{namespacetvm_1_1relay_1_1transform_adcddf150ca7da40e20408928421b0086}


Canonicalize some operators to the simplified operators. For example, bias\+\_\+add can be canonicalized to expand\+\_\+dims and broadcast\+\_\+add. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Combine\+Parallel\+Conv2D@{Combine\+Parallel\+Conv2D}}
\index{Combine\+Parallel\+Conv2D@{Combine\+Parallel\+Conv2D}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Combine\+Parallel\+Conv2\+D(uint64\+\_\+t min\+\_\+num\+\_\+branches=3)}{CombineParallelConv2D(uint64_t min_num_branches=3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Combine\+Parallel\+Conv2D (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{min\+\_\+num\+\_\+branches = {\ttfamily 3}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a3b8f4cbf0bd699d2ca0ab92c534c867d}{}\label{namespacetvm_1_1relay_1_1transform_a3b8f4cbf0bd699d2ca0ab92c534c867d}


Combine parallel 2d convolutions into a single convolution if the number of branches of this conv2d operator is not less than {\ttfamily min\+\_\+num\+\_\+branch}. 


\begin{DoxyParams}{Parameters}
{\em min\+\_\+num\+\_\+branches} & The minimun number of branches.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Combine\+Parallel\+Dense@{Combine\+Parallel\+Dense}}
\index{Combine\+Parallel\+Dense@{Combine\+Parallel\+Dense}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Combine\+Parallel\+Dense(uint64\+\_\+t min\+\_\+num\+\_\+branches=3)}{CombineParallelDense(uint64_t min_num_branches=3)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Combine\+Parallel\+Dense (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{min\+\_\+num\+\_\+branches = {\ttfamily 3}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a186d1029887d7b33d002798d414f4d31}{}\label{namespacetvm_1_1relay_1_1transform_a186d1029887d7b33d002798d414f4d31}


Combine parallel dense ops into a single batch\+\_\+matmul if the number of branches of this dense operator is not less than {\ttfamily min\+\_\+num\+\_\+branch}. 


\begin{DoxyParams}{Parameters}
{\em min\+\_\+num\+\_\+branches} & The minimun number of branches.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Convert\+Layout@{Convert\+Layout}}
\index{Convert\+Layout@{Convert\+Layout}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Convert\+Layout(const std\+::string \&desired\+\_\+layout)}{ConvertLayout(const std::string &desired_layout)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Convert\+Layout (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{desired\+\_\+layout}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_ad12225e2ad26ae24fca669e180026689}{}\label{namespacetvm_1_1relay_1_1transform_ad12225e2ad26ae24fca669e180026689}


Given a dest layout, this pass transforms the expr such that most of the ops input data layout is changed to the dest layout. In ideal situation, there are only 2 layout transforms, one at the start and one at the end. 

This pass is not a part of relay.\+build and is expected to be called between framework-\/relay parser and relay.\+build call. This is very helpful for hardware backends that support/prefer only type of data layout.

R\+FC -\/ \href{https://discuss.tvm.ai/t/layout-conversion-pass/4009}{\tt https\+://discuss.\+tvm.\+ai/t/layout-\/conversion-\/pass/4009}

This pass uses most of the Alter\+Op\+Layout and Infer\+Correct\+Layout infrastructure. We can define new layouts for conv2d ops for now. Most of the other operators try to adapt to their input layout using the Infer\+Correct\+Layout infrastructure.


\begin{DoxyParams}{Parameters}
{\em desired\+\_\+layout} & The desired layout. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Create\+Function\+Pass@{Create\+Function\+Pass}}
\index{Create\+Function\+Pass@{Create\+Function\+Pass}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Create\+Function\+Pass(const runtime\+::\+Typed\+Packed\+Func$<$ Function(\+Function, I\+R\+Module, Pass\+Context)$>$ \&pass\+\_\+func, int opt\+\_\+level, const std\+::string \&name, const tvm\+::\+Array$<$ tvm\+::\+Prim\+Expr $>$ \&required)}{CreateFunctionPass(const runtime::TypedPackedFunc< Function(Function, IRModule, PassContext)> &pass_func, int opt_level, const std::string &name, const tvm::Array< tvm::PrimExpr > &required)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Create\+Function\+Pass (
\begin{DoxyParamCaption}
\item[{const {\bf runtime\+::\+Typed\+Packed\+Func}$<$ {\bf Function}({\bf Function}, {\bf I\+R\+Module}, {\bf Pass\+Context})$>$ \&}]{pass\+\_\+func, }
\item[{int}]{opt\+\_\+level, }
\item[{const std\+::string \&}]{name, }
\item[{const {\bf tvm\+::\+Array}$<$ {\bf tvm\+::\+Prim\+Expr} $>$ \&}]{required}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aba687537c5fd54db0012c745bba74a85}{}\label{namespacetvm_1_1relay_1_1transform_aba687537c5fd54db0012c745bba74a85}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Dead\+Code\+Elimination@{Dead\+Code\+Elimination}}
\index{Dead\+Code\+Elimination@{Dead\+Code\+Elimination}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Dead\+Code\+Elimination(bool inline\+\_\+once=false)}{DeadCodeElimination(bool inline_once=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Dead\+Code\+Elimination (
\begin{DoxyParamCaption}
\item[{bool}]{inline\+\_\+once = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aaa08e0ced82fc7efe515d610104b070c}{}\label{namespacetvm_1_1relay_1_1transform_aaa08e0ced82fc7efe515d610104b070c}


Remove expressions which does not effect the program result. 

It will remove let bindings which are not referenced, and inline let bindings that are only used once.

For example, this pass should turn {\ttfamily let a = 1 in 2} into {\ttfamily 2}, as the value of the expression does not depend on a.

As another example, {\ttfamily let a = 1 in a} will be optimized into 1.


\begin{DoxyParams}{Parameters}
{\em inline\+\_\+once} & whether or not to inline binding used one.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Eliminate\+Common\+Subexpr@{Eliminate\+Common\+Subexpr}}
\index{Eliminate\+Common\+Subexpr@{Eliminate\+Common\+Subexpr}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Eliminate\+Common\+Subexpr(runtime\+::\+Packed\+Func fskip=nullptr)}{EliminateCommonSubexpr(runtime::PackedFunc fskip=nullptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Eliminate\+Common\+Subexpr (
\begin{DoxyParamCaption}
\item[{{\bf runtime\+::\+Packed\+Func}}]{fskip = {\ttfamily nullptr}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_adf21ade01969835b155241d277a94d1c}{}\label{namespacetvm_1_1relay_1_1transform_adf21ade01969835b155241d277a94d1c}


Search and eliminate common subexpression. For example, if there are two expressions evaluated to an identical value, a single variable is created and these two expressions are replaced by this variable. 


\begin{DoxyParams}{Parameters}
{\em fskip} & The callback argument that allows to skip certain expressions.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Eta\+Expand@{Eta\+Expand}}
\index{Eta\+Expand@{Eta\+Expand}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Eta\+Expand(bool expand\+\_\+constructor, bool expand\+\_\+global\+\_\+var)}{EtaExpand(bool expand_constructor, bool expand_global_var)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Eta\+Expand (
\begin{DoxyParamCaption}
\item[{bool}]{expand\+\_\+constructor, }
\item[{bool}]{expand\+\_\+global\+\_\+var}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a6e515696ecc9ff4222af99fef361de4e}{}\label{namespacetvm_1_1relay_1_1transform_a6e515696ecc9ff4222af99fef361de4e}


Add abstraction over a constructor or global variable bound to a function. 

For example\+: {\ttfamily square} is transformed to {\ttfamily fn (x\+: int32) -\/$>$ int32 \{ square(x) \}}.

See \href{https://en.wikipedia.org/wiki/Lambda_calculus#%CE%B7-conversion}{\tt https\+://en.\+wikipedia.\+org/wiki/\+Lambda\+\_\+calculus\#\%\+C\+E\%\+B7-\/conversion} for more details.


\begin{DoxyParams}{Parameters}
{\em expand\+\_\+constructor} & Whether to expand constructors. \\
\hline
{\em expand\+\_\+global\+\_\+var} & Whether to expand global variables.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Fast\+Math@{Fast\+Math}}
\index{Fast\+Math@{Fast\+Math}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Fast\+Math()}{FastMath()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Fast\+Math (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a22870dd16693b2e3edb5fba7cb5dc3e8}{}\label{namespacetvm_1_1relay_1_1transform_a22870dd16693b2e3edb5fba7cb5dc3e8}


Replaces non linear activation functions with their fast but approximate counterparts. 

\begin{DoxyReturn}{Returns}
The Pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Fold\+Constant@{Fold\+Constant}}
\index{Fold\+Constant@{Fold\+Constant}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Fold\+Constant()}{FoldConstant()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Fold\+Constant (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a41656c71a440f1f9c9eae0aa409d2b22}{}\label{namespacetvm_1_1relay_1_1transform_a41656c71a440f1f9c9eae0aa409d2b22}


Fold constant expressions. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Fold\+Scale\+Axis@{Fold\+Scale\+Axis}}
\index{Fold\+Scale\+Axis@{Fold\+Scale\+Axis}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Fold\+Scale\+Axis()}{FoldScaleAxis()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Fold\+Scale\+Axis (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a73946a29efe8cf6f186a681296c8e943}{}\label{namespacetvm_1_1relay_1_1transform_a73946a29efe8cf6f186a681296c8e943}


A sequential pass that executes Forward\+Fold\+Scale\+Axis and Backward\+Fold\+Scale\+Axis passes. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Forward\+Fold\+Scale\+Axis@{Forward\+Fold\+Scale\+Axis}}
\index{Forward\+Fold\+Scale\+Axis@{Forward\+Fold\+Scale\+Axis}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Forward\+Fold\+Scale\+Axis()}{ForwardFoldScaleAxis()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Forward\+Fold\+Scale\+Axis (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aab7f62610e05ed0211f17d452ee37f5f}{}\label{namespacetvm_1_1relay_1_1transform_aab7f62610e05ed0211f17d452ee37f5f}


Forward fold axis scaling into weights of conv/dense operators. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Fuse\+Ops@{Fuse\+Ops}}
\index{Fuse\+Ops@{Fuse\+Ops}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Fuse\+Ops(int fuse\+\_\+opt\+\_\+level=-\/1)}{FuseOps(int fuse_opt_level=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Fuse\+Ops (
\begin{DoxyParamCaption}
\item[{int}]{fuse\+\_\+opt\+\_\+level = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a2a6be6024a96a84f7230faa2519f1a97}{}\label{namespacetvm_1_1relay_1_1transform_a2a6be6024a96a84f7230faa2519f1a97}


Fuse operations into expr into seperate functions. 


\begin{DoxyParams}{Parameters}
{\em fuse\+\_\+opt\+\_\+level} & Optimization level. \hyperlink{classtvm_1_1relay_1_1If}{If} it is -\/1 it will be inferred from pass context.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Infer\+Type@{Infer\+Type}}
\index{Infer\+Type@{Infer\+Type}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Infer\+Type()}{InferType()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Infer\+Type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a1a4fe2161bf32a60bc2e57debab083ee}{}\label{namespacetvm_1_1relay_1_1transform_a1a4fe2161bf32a60bc2e57debab083ee}


Infer the type of an expression. 

The result of type checking is a new expression with unambigous type information filled in, as well as it\textquotesingle{}s checked type field populated with the result type.

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Inline@{Inline}}
\index{Inline@{Inline}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Inline()}{Inline()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Inline (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aba5e588279a3b19a119c9aa28c364bbe}{}\label{namespacetvm_1_1relay_1_1transform_aba5e588279a3b19a119c9aa28c364bbe}


Inline the global functions marked as {\ttfamily inline} in a given Relay \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Lazy\+Gradient\+Init@{Lazy\+Gradient\+Init}}
\index{Lazy\+Gradient\+Init@{Lazy\+Gradient\+Init}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Lazy\+Gradient\+Init()}{LazyGradientInit()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Lazy\+Gradient\+Init (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_ab6e60251741cca1e811564b2f03a4a5d}{}\label{namespacetvm_1_1relay_1_1transform_ab6e60251741cca1e811564b2f03a4a5d}


Convert all expressions of \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} into Grad\+Cell, an algebraic data type defined in gradient.\+rly. 

This will delay or decrease memory usage. All calls to ones, ones\+\_\+like, zeros, zeros\+\_\+like will not immediately instantiate a tensor in memory, rather only instantiate if needed. It also defines + and $\ast$ operation between Grad\+Cell types which can increase performance when using zero-\/filled or one-\/filled tensors, which is the case in reverse mode ad.

\begin{DoxyReturn}{Returns}
the pass 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Legalize@{Legalize}}
\index{Legalize@{Legalize}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Legalize(const std\+::string \&legalize\+\_\+map\+\_\+attr\+\_\+name=""F\+T\+V\+M\+Legalize"")}{Legalize(const std::string &legalize_map_attr_name="FTVMLegalize")}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Legalize (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{legalize\+\_\+map\+\_\+attr\+\_\+name = {\ttfamily \char`\"{}FTVMLegalize\char`\"{}}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a459fec81f00a7a17c5cf7dabe5e4e363}{}\label{namespacetvm_1_1relay_1_1transform_a459fec81f00a7a17c5cf7dabe5e4e363}


Legalizes an expr with another expression. 


\begin{DoxyParams}{Parameters}
{\em legalize\+\_\+map\+\_\+attr\+\_\+name} & The \hyperlink{classtvm_1_1Op}{Op}\textquotesingle{}s attr name which corresponds to the legalize rule function. One can collect and isolate similar type of legalize transformations using this param. For example, transformations that only apply to Dialects can be isolated into a F\+T\+V\+M\+Dialect\+Legalize string. This pass calls only those transformations that have been registered using the supplied legalize\+\_\+map\+\_\+attr\+\_\+name.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Partial\+Eval@{Partial\+Eval}}
\index{Partial\+Eval@{Partial\+Eval}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Partial\+Eval()}{PartialEval()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Partial\+Eval (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aa270d98da5518969e005c7e30d6eb6fe}{}\label{namespacetvm_1_1relay_1_1transform_aa270d98da5518969e005c7e30d6eb6fe}


Aggressive constant propagation/constant folding/inlining. 

It will do as much computation in compile time as possible. It has two benefit\+: remove runtime overhead, and allow more optimization (typically fusion). As a side effect, code size will explode.

\begin{DoxyReturn}{Returns}
the optimized expression. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Partition\+Graph@{Partition\+Graph}}
\index{Partition\+Graph@{Partition\+Graph}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Partition\+Graph()}{PartitionGraph()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Partition\+Graph (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_aac0bfdaf6d09b360602243c81abe05a1}{}\label{namespacetvm_1_1relay_1_1transform_aac0bfdaf6d09b360602243c81abe05a1}


Partition a Relay program into regions that can be executed on different backends. 

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Print\+IR@{Print\+IR}}
\index{Print\+IR@{Print\+IR}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Print\+I\+R(bool show\+\_\+meta\+\_\+data=true)}{PrintIR(bool show_meta_data=true)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Print\+IR (
\begin{DoxyParamCaption}
\item[{bool}]{show\+\_\+meta\+\_\+data = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a065b5d8be6fd8dbfcef44dfa48adeb29}{}\label{namespacetvm_1_1relay_1_1transform_a065b5d8be6fd8dbfcef44dfa48adeb29}


Print the IR for a module to help debugging. 


\begin{DoxyParams}{Parameters}
{\em show\+\_\+meta\+\_\+data} & The flag to control if meta data needs to be printed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Remove\+Unused\+Functions@{Remove\+Unused\+Functions}}
\index{Remove\+Unused\+Functions@{Remove\+Unused\+Functions}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Remove\+Unused\+Functions(\+Array$<$ tvm\+::\+Prim\+Expr $>$ entry\+\_\+functions)}{RemoveUnusedFunctions(Array< tvm::PrimExpr > entry_functions)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Remove\+Unused\+Functions (
\begin{DoxyParamCaption}
\item[{{\bf Array}$<$ {\bf tvm\+::\+Prim\+Expr} $>$}]{entry\+\_\+functions}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_abdccee126a74a602e3669bdfaf0f259c}{}\label{namespacetvm_1_1relay_1_1transform_abdccee126a74a602e3669bdfaf0f259c}


Remove the unused functions in the Relay \hyperlink{classtvm_1_1IRModule}{I\+R\+Module}. 


\begin{DoxyParams}{Parameters}
{\em entry\+\_\+functions} & The entry functions used to search the functions that are being used.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Rewrite\+Annotated\+Ops@{Rewrite\+Annotated\+Ops}}
\index{Rewrite\+Annotated\+Ops@{Rewrite\+Annotated\+Ops}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Rewrite\+Annotated\+Ops(int fallback\+\_\+device)}{RewriteAnnotatedOps(int fallback_device)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Rewrite\+Annotated\+Ops (
\begin{DoxyParamCaption}
\item[{int}]{fallback\+\_\+device}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a03b053f3d99d5c420ddc8492e6b987bf}{}\label{namespacetvm_1_1relay_1_1transform_a03b053f3d99d5c420ddc8492e6b987bf}


Rewrite the annotated program. 


\begin{DoxyParams}{Parameters}
{\em fallback\+\_\+device} & The fallback device which is the default device for operators without annotation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!Simplify\+Inference@{Simplify\+Inference}}
\index{Simplify\+Inference@{Simplify\+Inference}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{Simplify\+Inference()}{SimplifyInference()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+Simplify\+Inference (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_add13a2ad7b216ad4683141bbbb4f6943}{}\label{namespacetvm_1_1relay_1_1transform_add13a2ad7b216ad4683141bbbb4f6943}


Simplify certain operators during inference. For example, batch norm will be unpacked into a number of simplified operators. 

\begin{DoxyReturn}{Returns}
The Pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!To\+A\+Normal\+Form@{To\+A\+Normal\+Form}}
\index{To\+A\+Normal\+Form@{To\+A\+Normal\+Form}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{To\+A\+Normal\+Form()}{ToANormalForm()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+To\+A\+Normal\+Form (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a8cb03cf00b2ddf25f183ab837cde713c}{}\label{namespacetvm_1_1relay_1_1transform_a8cb03cf00b2ddf25f183ab837cde713c}


turn a dataflow graph into Administrative Normal Form, or A-\/\+Normal Form (A\+NF). 

It will turn an expression that is in a graph form (with sharing implicit), to an expression with explicit sharing (A-\/\+Normal Form).

The scope of the root expression is the global scope.

The scope of any non root expression is the least common ancestor of all it\textquotesingle{}s scope.

Values are ordered by post-\/\+D\+FS order in each scope.

\begin{DoxyReturn}{Returns}
The pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!To\+C\+PS@{To\+C\+PS}}
\index{To\+C\+PS@{To\+C\+PS}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{To\+C\+P\+S()}{ToCPS()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+To\+C\+PS (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_ad90e4d6ac08b62ef553755e759d398fa}{}\label{namespacetvm_1_1relay_1_1transform_ad90e4d6ac08b62ef553755e759d398fa}


Turn an expression into continuation passing style(\+C\+P\+S). 

C\+PS mean that every function will, instead of returning the result directly, be passed down an extra function (called the continuation) as argument, and pass the result to the continuation instead.

Thus, every function call has to be passed an extra argument that represent the rest of the computation (Hence the name of continuation).

Similarly, all other compute will be wrapped and call the continuation as well.

\begin{DoxyReturn}{Returns}
the pass. 
\end{DoxyReturn}
\index{tvm\+::relay\+::transform@{tvm\+::relay\+::transform}!To\+Graph\+Normal\+Form@{To\+Graph\+Normal\+Form}}
\index{To\+Graph\+Normal\+Form@{To\+Graph\+Normal\+Form}!tvm\+::relay\+::transform@{tvm\+::relay\+::transform}}
\subsubsection[{\texorpdfstring{To\+Graph\+Normal\+Form()}{ToGraphNormalForm()}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Pass} tvm\+::relay\+::transform\+::\+To\+Graph\+Normal\+Form (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{namespacetvm_1_1relay_1_1transform_a2cfef0e02cca22f3e0e85e0a10a82f5b}{}\label{namespacetvm_1_1relay_1_1transform_a2cfef0e02cca22f3e0e85e0a10a82f5b}


Remove let binding and directly share via pointer instead. 

It will remove all let binding, and turn all of the variable bound by let into direct pointer reference.

\begin{DoxyReturn}{Returns}
the expression in graph normal form. 
\end{DoxyReturn}
