\hypertarget{c__backend__api_8h}{}\section{include/tvm/runtime/c\+\_\+backend\+\_\+api.h File Reference}
\label{c__backend__api_8h}\index{include/tvm/runtime/c\+\_\+backend\+\_\+api.\+h@{include/tvm/runtime/c\+\_\+backend\+\_\+api.\+h}}


T\+VM runtime backend A\+PI.  


{\ttfamily \#include $<$tvm/runtime/c\+\_\+runtime\+\_\+api.\+h$>$}\\*
Include dependency graph for c\+\_\+backend\+\_\+api.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=315pt]{c__backend__api_8h__incl}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structTVMParallelGroupEnv}{T\+V\+M\+Parallel\+Group\+Env}
\begin{DoxyCompactList}\small\item\em Environment for T\+VM parallel task. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef int($\ast$ \hyperlink{c__backend__api_8h_a79a43e3f37e8f77316e8dd16d0ee9b47}{T\+V\+M\+Backend\+Packed\+C\+Func}) (\hyperlink{unionTVMValue}{T\+V\+M\+Value} $\ast$args, int $\ast$type\+\_\+codes, int num\+\_\+args, \hyperlink{unionTVMValue}{T\+V\+M\+Value} $\ast$out\+\_\+ret\+\_\+value, int $\ast$out\+\_\+ret\+\_\+tcode)
\begin{DoxyCompactList}\small\item\em Signature for backend functions exported as D\+LL. \end{DoxyCompactList}\item 
typedef int($\ast$ \hyperlink{c__backend__api_8h_ac1b48128210969500e27aad08a7fe51b}{F\+T\+V\+M\+Parallel\+Lambda}) (int task\+\_\+id, \hyperlink{structTVMParallelGroupEnv}{T\+V\+M\+Parallel\+Group\+Env} $\ast$penv, void $\ast$cdata)
\begin{DoxyCompactList}\small\item\em The callback function to execute a parallel lambda. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{c__backend__api_8h_a56a654a9aeba2f1ccf3e10918dd88ec5}{T\+V\+M\+Backend\+Get\+Func\+From\+Env} (void $\ast$mod\+\_\+node, const char $\ast$func\+\_\+name, \hyperlink{c__runtime__api_8h_acf57d257a6e0841d84ebbd2a339d183e}{T\+V\+M\+Function\+Handle} $\ast$out)
\begin{DoxyCompactList}\small\item\em Backend function for modules to get function from its environment mod\+\_\+node (its imports and global function). The user do should not call T\+V\+M\+Func\+Free on func. \end{DoxyCompactList}\item 
int \hyperlink{c__backend__api_8h_a0c57deb5acb9338ec778d91bd6e42191}{T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol} (const char $\ast$name, void $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Backend function to register system-\/wide library symbol. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{c__backend__api_8h_a07eaf7d1b748d99aa7715c7adbdea231}{T\+V\+M\+Backend\+Alloc\+Workspace} (int device\+\_\+type, int device\+\_\+id, uint64\+\_\+t nbytes, int dtype\+\_\+code\+\_\+hint, int dtype\+\_\+bits\+\_\+hint)
\begin{DoxyCompactList}\small\item\em Backend function to allocate temporal workspace. \end{DoxyCompactList}\item 
int \hyperlink{c__backend__api_8h_a4560d2cbefdae811371596672e455dfd}{T\+V\+M\+Backend\+Free\+Workspace} (int device\+\_\+type, int device\+\_\+id, void $\ast$ptr)
\begin{DoxyCompactList}\small\item\em Backend function to free temporal workspace. \end{DoxyCompactList}\item 
int \hyperlink{c__backend__api_8h_a6ff8662943d0f003d55d9046cd24daf8}{T\+V\+M\+Backend\+Parallel\+Launch} (\hyperlink{c__backend__api_8h_ac1b48128210969500e27aad08a7fe51b}{F\+T\+V\+M\+Parallel\+Lambda} flambda, void $\ast$cdata, int num\+\_\+task)
\begin{DoxyCompactList}\small\item\em Backend function for running parallel jobs. \end{DoxyCompactList}\item 
int \hyperlink{c__backend__api_8h_a2d54b04a58a58eb9ff43e33c320e60a7}{T\+V\+M\+Backend\+Parallel\+Barrier} (int task\+\_\+id, \hyperlink{structTVMParallelGroupEnv}{T\+V\+M\+Parallel\+Group\+Env} $\ast$penv)
\begin{DoxyCompactList}\small\item\em B\+SP barrrier between parallel threads. \end{DoxyCompactList}\item 
int \hyperlink{c__backend__api_8h_ae70bd3ee026eb55b438ada05b08f0ce8}{T\+V\+M\+Backend\+Run\+Once} (void $\ast$$\ast$handle, int($\ast$f)(void $\ast$), void $\ast$cdata, int nbytes)
\begin{DoxyCompactList}\small\item\em Simple static initialization function. Run f once and set handle to be not null. This function is mainly used for test purpose. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
T\+VM runtime backend A\+PI. 

The functions defined in this header are intended to be used by compiled tvm operators, usually user do not need to use these function directly. 

\subsection{Typedef Documentation}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!F\+T\+V\+M\+Parallel\+Lambda@{F\+T\+V\+M\+Parallel\+Lambda}}
\index{F\+T\+V\+M\+Parallel\+Lambda@{F\+T\+V\+M\+Parallel\+Lambda}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{F\+T\+V\+M\+Parallel\+Lambda}{FTVMParallelLambda}}]{\setlength{\rightskip}{0pt plus 5cm}typedef int($\ast$ F\+T\+V\+M\+Parallel\+Lambda) (int task\+\_\+id, {\bf T\+V\+M\+Parallel\+Group\+Env} $\ast$penv, void $\ast$cdata)}\hypertarget{c__backend__api_8h_ac1b48128210969500e27aad08a7fe51b}{}\label{c__backend__api_8h_ac1b48128210969500e27aad08a7fe51b}


The callback function to execute a parallel lambda. 


\begin{DoxyParams}{Parameters}
{\em task\+\_\+id} & the task id of the function. \\
\hline
{\em penv} & The parallel environment backs the execution. \\
\hline
{\em cdata} & The supporting closure data. \\
\hline
\end{DoxyParams}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Packed\+C\+Func@{T\+V\+M\+Backend\+Packed\+C\+Func}}
\index{T\+V\+M\+Backend\+Packed\+C\+Func@{T\+V\+M\+Backend\+Packed\+C\+Func}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Packed\+C\+Func}{TVMBackendPackedCFunc}}]{\setlength{\rightskip}{0pt plus 5cm}typedef int($\ast$ T\+V\+M\+Backend\+Packed\+C\+Func) ({\bf T\+V\+M\+Value} $\ast$args, int $\ast$type\+\_\+codes, int num\+\_\+args, {\bf T\+V\+M\+Value} $\ast$out\+\_\+ret\+\_\+value, int $\ast$out\+\_\+ret\+\_\+tcode)}\hypertarget{c__backend__api_8h_a79a43e3f37e8f77316e8dd16d0ee9b47}{}\label{c__backend__api_8h_a79a43e3f37e8f77316e8dd16d0ee9b47}


Signature for backend functions exported as D\+LL. 


\begin{DoxyParams}{Parameters}
{\em args} & The arguments \\
\hline
{\em type\+\_\+codes} & The type codes of the arguments \\
\hline
{\em num\+\_\+args} & Number of arguments. \\
\hline
{\em out\+\_\+ret\+\_\+value} & The output value of the the return value. \\
\hline
{\em out\+\_\+ret\+\_\+tcode} & The output type code of the return value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success, -\/1 if failure happens, set error via T\+V\+M\+A\+P\+I\+Set\+Last\+Error. 
\end{DoxyReturn}


\subsection{Function Documentation}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Alloc\+Workspace@{T\+V\+M\+Backend\+Alloc\+Workspace}}
\index{T\+V\+M\+Backend\+Alloc\+Workspace@{T\+V\+M\+Backend\+Alloc\+Workspace}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Alloc\+Workspace(int device\+\_\+type, int device\+\_\+id, uint64\+\_\+t nbytes, int dtype\+\_\+code\+\_\+hint, int dtype\+\_\+bits\+\_\+hint)}{TVMBackendAllocWorkspace(int device_type, int device_id, uint64_t nbytes, int dtype_code_hint, int dtype_bits_hint)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ T\+V\+M\+Backend\+Alloc\+Workspace (
\begin{DoxyParamCaption}
\item[{int}]{device\+\_\+type, }
\item[{int}]{device\+\_\+id, }
\item[{uint64\+\_\+t}]{nbytes, }
\item[{int}]{dtype\+\_\+code\+\_\+hint, }
\item[{int}]{dtype\+\_\+bits\+\_\+hint}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a07eaf7d1b748d99aa7715c7adbdea231}{}\label{c__backend__api_8h_a07eaf7d1b748d99aa7715c7adbdea231}


Backend function to allocate temporal workspace. 

\begin{DoxyNote}{Note}
The result allocate spaced is ensured to be aligned to k\+Temp\+Alloca\+Alignment.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em nbytes} & The size of the space requested. \\
\hline
{\em device\+\_\+type} & The device type which the space will be allocated. \\
\hline
{\em device\+\_\+id} & The device id which the space will be allocated. \\
\hline
{\em dtype\+\_\+code\+\_\+hint} & The type code of the array elements. Only used in certain backends such as Open\+GL. \\
\hline
{\em dtype\+\_\+bits\+\_\+hint} & The type bits of the array elements. Only used in certain backends such as Open\+GL. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
nullptr when error is thrown, a valid ptr if success 
\end{DoxyReturn}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Free\+Workspace@{T\+V\+M\+Backend\+Free\+Workspace}}
\index{T\+V\+M\+Backend\+Free\+Workspace@{T\+V\+M\+Backend\+Free\+Workspace}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Free\+Workspace(int device\+\_\+type, int device\+\_\+id, void $\ast$ptr)}{TVMBackendFreeWorkspace(int device_type, int device_id, void *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Free\+Workspace (
\begin{DoxyParamCaption}
\item[{int}]{device\+\_\+type, }
\item[{int}]{device\+\_\+id, }
\item[{void $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a4560d2cbefdae811371596672e455dfd}{}\label{c__backend__api_8h_a4560d2cbefdae811371596672e455dfd}


Backend function to free temporal workspace. 


\begin{DoxyParams}{Parameters}
{\em ptr} & The result allocated space pointer. \\
\hline
{\em device\+\_\+type} & The device type which the space will be allocated. \\
\hline
{\em device\+\_\+id} & The device id which the space will be allocated. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\hyperlink{c__backend__api_8h_a07eaf7d1b748d99aa7715c7adbdea231}{T\+V\+M\+Backend\+Alloc\+Workspace} 
\end{DoxySeeAlso}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Get\+Func\+From\+Env@{T\+V\+M\+Backend\+Get\+Func\+From\+Env}}
\index{T\+V\+M\+Backend\+Get\+Func\+From\+Env@{T\+V\+M\+Backend\+Get\+Func\+From\+Env}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Get\+Func\+From\+Env(void $\ast$mod\+\_\+node, const char $\ast$func\+\_\+name, T\+V\+M\+Function\+Handle $\ast$out)}{TVMBackendGetFuncFromEnv(void *mod_node, const char *func_name, TVMFunctionHandle *out)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Get\+Func\+From\+Env (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{mod\+\_\+node, }
\item[{const char $\ast$}]{func\+\_\+name, }
\item[{{\bf T\+V\+M\+Function\+Handle} $\ast$}]{out}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a56a654a9aeba2f1ccf3e10918dd88ec5}{}\label{c__backend__api_8h_a56a654a9aeba2f1ccf3e10918dd88ec5}


Backend function for modules to get function from its environment mod\+\_\+node (its imports and global function). The user do should not call T\+V\+M\+Func\+Free on func. 


\begin{DoxyParams}{Parameters}
{\em mod\+\_\+node} & The module handle. \\
\hline
{\em func\+\_\+name} & The name of the function. \\
\hline
{\em out} & The result function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens 
\end{DoxyReturn}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Parallel\+Barrier@{T\+V\+M\+Backend\+Parallel\+Barrier}}
\index{T\+V\+M\+Backend\+Parallel\+Barrier@{T\+V\+M\+Backend\+Parallel\+Barrier}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Parallel\+Barrier(int task\+\_\+id, T\+V\+M\+Parallel\+Group\+Env $\ast$penv)}{TVMBackendParallelBarrier(int task_id, TVMParallelGroupEnv *penv)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Parallel\+Barrier (
\begin{DoxyParamCaption}
\item[{int}]{task\+\_\+id, }
\item[{{\bf T\+V\+M\+Parallel\+Group\+Env} $\ast$}]{penv}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a2d54b04a58a58eb9ff43e33c320e60a7}{}\label{c__backend__api_8h_a2d54b04a58a58eb9ff43e33c320e60a7}


B\+SP barrrier between parallel threads. 


\begin{DoxyParams}{Parameters}
{\em task\+\_\+id} & the task id of the function. \\
\hline
{\em penv} & The parallel environment backs the execution. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens 
\end{DoxyReturn}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Parallel\+Launch@{T\+V\+M\+Backend\+Parallel\+Launch}}
\index{T\+V\+M\+Backend\+Parallel\+Launch@{T\+V\+M\+Backend\+Parallel\+Launch}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Parallel\+Launch(\+F\+T\+V\+M\+Parallel\+Lambda flambda, void $\ast$cdata, int num\+\_\+task)}{TVMBackendParallelLaunch(FTVMParallelLambda flambda, void *cdata, int num_task)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Parallel\+Launch (
\begin{DoxyParamCaption}
\item[{{\bf F\+T\+V\+M\+Parallel\+Lambda}}]{flambda, }
\item[{void $\ast$}]{cdata, }
\item[{int}]{num\+\_\+task}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a6ff8662943d0f003d55d9046cd24daf8}{}\label{c__backend__api_8h_a6ff8662943d0f003d55d9046cd24daf8}


Backend function for running parallel jobs. 


\begin{DoxyParams}{Parameters}
{\em flambda} & The parallel function to be launched. \\
\hline
{\em cdata} & The closure data. \\
\hline
{\em num\+\_\+task} & Number of tasks to launch, can be 0, means launch with all available threads.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens 
\end{DoxyReturn}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol@{T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol}}
\index{T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol@{T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol(const char $\ast$name, void $\ast$ptr)}{TVMBackendRegisterSystemLibSymbol(const char *name, void *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Register\+System\+Lib\+Symbol (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{void $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_a0c57deb5acb9338ec778d91bd6e42191}{}\label{c__backend__api_8h_a0c57deb5acb9338ec778d91bd6e42191}


Backend function to register system-\/wide library symbol. 


\begin{DoxyParams}{Parameters}
{\em name} & The name of the symbol \\
\hline
{\em ptr} & The symbol address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens 
\end{DoxyReturn}
\index{c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}!T\+V\+M\+Backend\+Run\+Once@{T\+V\+M\+Backend\+Run\+Once}}
\index{T\+V\+M\+Backend\+Run\+Once@{T\+V\+M\+Backend\+Run\+Once}!c\+\_\+backend\+\_\+api.\+h@{c\+\_\+backend\+\_\+api.\+h}}
\subsubsection[{\texorpdfstring{T\+V\+M\+Backend\+Run\+Once(void $\ast$$\ast$handle, int($\ast$f)(void $\ast$), void $\ast$cdata, int nbytes)}{TVMBackendRunOnce(void **handle, int(*f)(void *), void *cdata, int nbytes)}}]{\setlength{\rightskip}{0pt plus 5cm}int T\+V\+M\+Backend\+Run\+Once (
\begin{DoxyParamCaption}
\item[{void $\ast$$\ast$}]{handle, }
\item[{int($\ast$)(void $\ast$)}]{f, }
\item[{void $\ast$}]{cdata, }
\item[{int}]{nbytes}
\end{DoxyParamCaption}
)}\hypertarget{c__backend__api_8h_ae70bd3ee026eb55b438ada05b08f0ce8}{}\label{c__backend__api_8h_ae70bd3ee026eb55b438ada05b08f0ce8}


Simple static initialization function. Run f once and set handle to be not null. This function is mainly used for test purpose. 


\begin{DoxyParams}{Parameters}
{\em handle} & An global address to indicate f \\
\hline
{\em f} & The function to be ran \\
\hline
{\em cdata} & The closure data to pass to the function. \\
\hline
{\em nbytes} & Number of bytes in the closure data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 when no error is thrown, -\/1 when failure happens 
\end{DoxyReturn}
