\hypertarget{classtvm_1_1runtime_1_1ModuleNode}{}\section{tvm\+:\+:runtime\+:\+:Module\+Node Class Reference}
\label{classtvm_1_1runtime_1_1ModuleNode}\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}


Base container of module.  




{\ttfamily \#include $<$module.\+h$>$}



Inheritance diagram for tvm\+:\+:runtime\+:\+:Module\+Node\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classtvm_1_1runtime_1_1ModuleNode__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for tvm\+:\+:runtime\+:\+:Module\+Node\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{classtvm_1_1runtime_1_1ModuleNode__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual \hyperlink{classtvm_1_1runtime_1_1ModuleNode_add6c8e6967c6906ea5346b2ccd30afb4}{$\sim$\+Module\+Node} ()
\begin{DoxyCompactList}\small\item\em virtual destructor \end{DoxyCompactList}\item 
virtual const char $\ast$ \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a5834549180e1c668e7126562cea9a557}{type\+\_\+key} () const =0
\item 
virtual \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} \hyperlink{classtvm_1_1runtime_1_1ModuleNode_af16bc90e6265eb5492b028308dbb1a25}{Get\+Function} (const std\+::string \&name, const \hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr}$<$ \hyperlink{classtvm_1_1runtime_1_1Object}{Object} $>$ \&sptr\+\_\+to\+\_\+self)=0
\begin{DoxyCompactList}\small\item\em Get a \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} from module. \end{DoxyCompactList}\item 
virtual void \hyperlink{classtvm_1_1runtime_1_1ModuleNode_ad06785ce4a9daf8602748f1b9cff5b90}{Save\+To\+File} (const std\+::string \&file\+\_\+name, const std\+::string \&format)
\begin{DoxyCompactList}\small\item\em Save the module to file. \end{DoxyCompactList}\item 
virtual void \hyperlink{classtvm_1_1runtime_1_1ModuleNode_acd613ea7faf2fc100d1e8b0fd80020c3}{Save\+To\+Binary} (dmlc\+::\+Stream $\ast$stream)
\begin{DoxyCompactList}\small\item\em Save the module to binary stream. \end{DoxyCompactList}\item 
virtual std\+::string \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a73ac521892f4263554116261303e7e44}{Get\+Source} (const std\+::string \&format=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Get the source code of module, when available. \end{DoxyCompactList}\item 
\hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} \hyperlink{classtvm_1_1runtime_1_1ModuleNode_abd6d000714e0ed2b3b2f435ea5bd9a43}{Get\+Function} (const std\+::string \&name, bool query\+\_\+imports=false)
\begin{DoxyCompactList}\small\item\em Get packed function from current module by name. \end{DoxyCompactList}\item 
void \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a79b98521b484d1c672b7ce2ae2aed2b5}{Import} (\hyperlink{classtvm_1_1runtime_1_1Module}{Module} other)
\begin{DoxyCompactList}\small\item\em Import another module into this module. \end{DoxyCompactList}\item 
const \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} $\ast$ \hyperlink{classtvm_1_1runtime_1_1ModuleNode_aa2820340181ff4a9eaa149f89ac706ec}{Get\+Func\+From\+Env} (const std\+::string \&name)
\begin{DoxyCompactList}\small\item\em Get a function from current environment The environment includes all the imports as well as Global functions. \end{DoxyCompactList}\item 
const std\+::vector$<$ \hyperlink{classtvm_1_1runtime_1_1Module}{Module} $>$ \& \hyperlink{classtvm_1_1runtime_1_1ModuleNode_abb10abf603900cbd0bfd51eeb44eb949}{imports} () const 
\item 
\hyperlink{classtvm_1_1runtime_1_1ModuleNode_ac44750d06e11a275b10072b982ef4b13}{T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO} (\hyperlink{classtvm_1_1runtime_1_1ModuleNode}{Module\+Node}, \hyperlink{classtvm_1_1runtime_1_1Object}{Object})
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static constexpr const uint32\+\_\+t \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a56e23ef9427bd055c4868135cc1f38bd}{\+\_\+type\+\_\+index} = Type\+Index\+::k\+Runtime\+Module
\item 
static constexpr const char $\ast$ \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a9346e3758203ca87d500e65de0445e01}{\+\_\+type\+\_\+key} = \char`\"{}runtime.\+Module\char`\"{}
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ \hyperlink{classtvm_1_1runtime_1_1Module}{Module} $>$ \hyperlink{classtvm_1_1runtime_1_1ModuleNode_af05db5c6d76f9b4dbf0631815170c5a7}{imports\+\_\+}
\begin{DoxyCompactList}\small\item\em The modules this module depend on. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a21f639900c480510650969df9c74d17d}{Module}
\item 
class \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a2b490c1acecd166b5824e4e96f17c64e}{Module\+Internal}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
Base container of module. 

Please subclass \hyperlink{classtvm_1_1runtime_1_1ModuleNode}{Module\+Node} to create a specific runtime module.


\begin{DoxyCode}
\textcolor{keyword}{class }MyModuleNode : \textcolor{keyword}{public} ModuleNode \{
 \textcolor{keyword}{public}:
  \textcolor{comment}{// implement the interface}
\};

\textcolor{comment}{// use make\_object to create a specific}
\textcolor{comment}{// instace of MyModuleNode.}
\hyperlink{classtvm_1_1runtime_1_1ModuleNode_a21f639900c480510650969df9c74d17d}{Module} CreateMyModule() \{
  ObjectPtr<MyModuleNode> n =
    tvm::runtime::make\_object<MyModuleNode>();
  \textcolor{keywordflow}{return} \hyperlink{classtvm_1_1runtime_1_1ModuleNode_a21f639900c480510650969df9c74d17d}{Module}(n);
\}
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!````~Module\+Node@{$\sim$\+Module\+Node}}
\index{````~Module\+Node@{$\sim$\+Module\+Node}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{$\sim$\+Module\+Node()}{~ModuleNode()}}]{\setlength{\rightskip}{0pt plus 5cm}virtual tvm\+::runtime\+::\+Module\+Node\+::$\sim$\+Module\+Node (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_add6c8e6967c6906ea5346b2ccd30afb4}{}\label{classtvm_1_1runtime_1_1ModuleNode_add6c8e6967c6906ea5346b2ccd30afb4}


virtual destructor 



\subsection{Member Function Documentation}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Get\+Func\+From\+Env@{Get\+Func\+From\+Env}}
\index{Get\+Func\+From\+Env@{Get\+Func\+From\+Env}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Get\+Func\+From\+Env(const std\+::string \&name)}{GetFuncFromEnv(const std::string &name)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Packed\+Func}$\ast$ tvm\+::runtime\+::\+Module\+Node\+::\+Get\+Func\+From\+Env (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_aa2820340181ff4a9eaa149f89ac706ec}{}\label{classtvm_1_1runtime_1_1ModuleNode_aa2820340181ff4a9eaa149f89ac706ec}


Get a function from current environment The environment includes all the imports as well as Global functions. 


\begin{DoxyParams}{Parameters}
{\em name} & name of the function. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding function. 
\end{DoxyReturn}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Get\+Function@{Get\+Function}}
\index{Get\+Function@{Get\+Function}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Get\+Function(const std\+::string \&name, const Object\+Ptr$<$ Object $>$ \&sptr\+\_\+to\+\_\+self)=0}{GetFunction(const std::string &name, const ObjectPtr< Object > &sptr_to_self)=0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf Packed\+Func} tvm\+::runtime\+::\+Module\+Node\+::\+Get\+Function (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{const {\bf Object\+Ptr}$<$ {\bf Object} $>$ \&}]{sptr\+\_\+to\+\_\+self}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_af16bc90e6265eb5492b028308dbb1a25}{}\label{classtvm_1_1runtime_1_1ModuleNode_af16bc90e6265eb5492b028308dbb1a25}


Get a \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} from module. 

The \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} may not be fully initialized, there might still be first time running overhead when executing the function on certain devices. For benchmarking, use prepare to eliminate


\begin{DoxyParams}{Parameters}
{\em name} & the name of the function. \\
\hline
{\em sptr\+\_\+to\+\_\+self} & The \hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{Object\+Ptr} that points to this module node.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Packed\+Func(nullptr) when it is not available.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The function will always remain valid. If the function need resource from the module(e.\+g. late linking), it should capture sptr\+\_\+to\+\_\+self. 
\end{DoxyNote}


Implemented in \hyperlink{classtvm_1_1runtime_1_1vm_1_1VirtualMachine_a8d1e7cdc6412eae8dea9c2c08c7f48ec}{tvm\+::runtime\+::vm\+::\+Virtual\+Machine}, and \hyperlink{classtvm_1_1runtime_1_1vm_1_1Executable_af052de1610aae050d4363b6625265e86}{tvm\+::runtime\+::vm\+::\+Executable}.

\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Get\+Function@{Get\+Function}}
\index{Get\+Function@{Get\+Function}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Get\+Function(const std\+::string \&name, bool query\+\_\+imports=false)}{GetFunction(const std::string &name, bool query_imports=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Packed\+Func} tvm\+::runtime\+::\+Module\+Node\+::\+Get\+Function (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{bool}]{query\+\_\+imports = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_abd6d000714e0ed2b3b2f435ea5bd9a43}{}\label{classtvm_1_1runtime_1_1ModuleNode_abd6d000714e0ed2b3b2f435ea5bd9a43}


Get packed function from current module by name. 


\begin{DoxyParams}{Parameters}
{\em name} & The name of the function. \\
\hline
{\em query\+\_\+imports} & Whether also query dependency modules. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result function. This function will return Packed\+Func(nullptr) if function do not exist. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Implemented in packed\+\_\+func.\+cc 
\end{DoxyNote}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Get\+Source@{Get\+Source}}
\index{Get\+Source@{Get\+Source}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Get\+Source(const std\+::string \&format="""")}{GetSource(const std::string &format="")}}]{\setlength{\rightskip}{0pt plus 5cm}virtual std\+::string tvm\+::runtime\+::\+Module\+Node\+::\+Get\+Source (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{format = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a73ac521892f4263554116261303e7e44}{}\label{classtvm_1_1runtime_1_1ModuleNode_a73ac521892f4263554116261303e7e44}


Get the source code of module, when available. 


\begin{DoxyParams}{Parameters}
{\em format} & Format of the source code, can be empty by default. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Possible source code when available. 
\end{DoxyReturn}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Import@{Import}}
\index{Import@{Import}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Import(\+Module other)}{Import(Module other)}}]{\setlength{\rightskip}{0pt plus 5cm}void tvm\+::runtime\+::\+Module\+Node\+::\+Import (
\begin{DoxyParamCaption}
\item[{{\bf Module}}]{other}
\end{DoxyParamCaption}
)}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a79b98521b484d1c672b7ce2ae2aed2b5}{}\label{classtvm_1_1runtime_1_1ModuleNode_a79b98521b484d1c672b7ce2ae2aed2b5}


Import another module into this module. 


\begin{DoxyParams}{Parameters}
{\em other} & The module to be imported.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Cyclic dependency is not allowed among modules, An error will be thrown when cyclic dependency is detected. 
\end{DoxyNote}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!imports@{imports}}
\index{imports@{imports}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{imports() const }{imports() const }}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<${\bf Module}$>$\& tvm\+::runtime\+::\+Module\+Node\+::imports (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_abb10abf603900cbd0bfd51eeb44eb949}{}\label{classtvm_1_1runtime_1_1ModuleNode_abb10abf603900cbd0bfd51eeb44eb949}
\begin{DoxyReturn}{Returns}
The module it imports from 
\end{DoxyReturn}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Save\+To\+Binary@{Save\+To\+Binary}}
\index{Save\+To\+Binary@{Save\+To\+Binary}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Save\+To\+Binary(dmlc\+::\+Stream $\ast$stream)}{SaveToBinary(dmlc::Stream *stream)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void tvm\+::runtime\+::\+Module\+Node\+::\+Save\+To\+Binary (
\begin{DoxyParamCaption}
\item[{dmlc\+::\+Stream $\ast$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_acd613ea7faf2fc100d1e8b0fd80020c3}{}\label{classtvm_1_1runtime_1_1ModuleNode_acd613ea7faf2fc100d1e8b0fd80020c3}


Save the module to binary stream. 


\begin{DoxyParams}{Parameters}
{\em stream} & The binary stream to save to. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
It is recommended to implement this for device modules, but not necessarily host modules. We can use this to do A\+OT loading of bundled device functions. 
\end{DoxyNote}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Save\+To\+File@{Save\+To\+File}}
\index{Save\+To\+File@{Save\+To\+File}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Save\+To\+File(const std\+::string \&file\+\_\+name, const std\+::string \&format)}{SaveToFile(const std::string &file_name, const std::string &format)}}]{\setlength{\rightskip}{0pt plus 5cm}virtual void tvm\+::runtime\+::\+Module\+Node\+::\+Save\+To\+File (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{file\+\_\+name, }
\item[{const std\+::string \&}]{format}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_ad06785ce4a9daf8602748f1b9cff5b90}{}\label{classtvm_1_1runtime_1_1ModuleNode_ad06785ce4a9daf8602748f1b9cff5b90}


Save the module to file. 


\begin{DoxyParams}{Parameters}
{\em file\+\_\+name} & The file to be saved to. \\
\hline
{\em format} & The format of the file. \\
\hline
\end{DoxyParams}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO@{T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO}}
\index{T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO@{T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+F\+O(\+Module\+Node, Object)}{TVM_DECLARE_FINAL_OBJECT_INFO(ModuleNode, Object)}}]{\setlength{\rightskip}{0pt plus 5cm}tvm\+::runtime\+::\+Module\+Node\+::\+T\+V\+M\+\_\+\+D\+E\+C\+L\+A\+R\+E\+\_\+\+F\+I\+N\+A\+L\+\_\+\+O\+B\+J\+E\+C\+T\+\_\+\+I\+N\+FO (
\begin{DoxyParamCaption}
\item[{{\bf Module\+Node}}]{, }
\item[{{\bf Object}}]{}
\end{DoxyParamCaption}
)}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_ac44750d06e11a275b10072b982ef4b13}{}\label{classtvm_1_1runtime_1_1ModuleNode_ac44750d06e11a275b10072b982ef4b13}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!type\+\_\+key@{type\+\_\+key}}
\index{type\+\_\+key@{type\+\_\+key}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{type\+\_\+key() const =0}{type_key() const =0}}]{\setlength{\rightskip}{0pt plus 5cm}virtual const char$\ast$ tvm\+::runtime\+::\+Module\+Node\+::type\+\_\+key (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [pure virtual]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a5834549180e1c668e7126562cea9a557}{}\label{classtvm_1_1runtime_1_1ModuleNode_a5834549180e1c668e7126562cea9a557}
\begin{DoxyReturn}{Returns}
The per module type key. 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This key is used to for serializing custom modules. 
\end{DoxyNote}


Implemented in \hyperlink{classtvm_1_1runtime_1_1vm_1_1VirtualMachine_a00f035566a720dbac56f5dea042fb0ec}{tvm\+::runtime\+::vm\+::\+Virtual\+Machine}, and \hyperlink{classtvm_1_1runtime_1_1vm_1_1Executable_aef4f3663ee57fcbdf2d775f4dbbe79dc}{tvm\+::runtime\+::vm\+::\+Executable}.



\subsection{Friends And Related Function Documentation}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Module@{Module}}
\index{Module@{Module}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Module}{Module}}]{\setlength{\rightskip}{0pt plus 5cm}friend class {\bf Module}\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a21f639900c480510650969df9c74d17d}{}\label{classtvm_1_1runtime_1_1ModuleNode_a21f639900c480510650969df9c74d17d}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!Module\+Internal@{Module\+Internal}}
\index{Module\+Internal@{Module\+Internal}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{Module\+Internal}{ModuleInternal}}]{\setlength{\rightskip}{0pt plus 5cm}friend class Module\+Internal\hspace{0.3cm}{\ttfamily [friend]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a2b490c1acecd166b5824e4e96f17c64e}{}\label{classtvm_1_1runtime_1_1ModuleNode_a2b490c1acecd166b5824e4e96f17c64e}


\subsection{Member Data Documentation}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!\+\_\+type\+\_\+index@{\+\_\+type\+\_\+index}}
\index{\+\_\+type\+\_\+index@{\+\_\+type\+\_\+index}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{\+\_\+type\+\_\+index}{_type_index}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const uint32\+\_\+t tvm\+::runtime\+::\+Module\+Node\+::\+\_\+type\+\_\+index = Type\+Index\+::k\+Runtime\+Module\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a56e23ef9427bd055c4868135cc1f38bd}{}\label{classtvm_1_1runtime_1_1ModuleNode_a56e23ef9427bd055c4868135cc1f38bd}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!\+\_\+type\+\_\+key@{\+\_\+type\+\_\+key}}
\index{\+\_\+type\+\_\+key@{\+\_\+type\+\_\+key}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{\+\_\+type\+\_\+key}{_type_key}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::runtime\+::\+Module\+Node\+::\+\_\+type\+\_\+key = \char`\"{}runtime.\+Module\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_a9346e3758203ca87d500e65de0445e01}{}\label{classtvm_1_1runtime_1_1ModuleNode_a9346e3758203ca87d500e65de0445e01}
\index{tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}!imports\+\_\+@{imports\+\_\+}}
\index{imports\+\_\+@{imports\+\_\+}!tvm\+::runtime\+::\+Module\+Node@{tvm\+::runtime\+::\+Module\+Node}}
\subsubsection[{\texorpdfstring{imports\+\_\+}{imports_}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Module}$>$ tvm\+::runtime\+::\+Module\+Node\+::imports\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classtvm_1_1runtime_1_1ModuleNode_af05db5c6d76f9b4dbf0631815170c5a7}{}\label{classtvm_1_1runtime_1_1ModuleNode_af05db5c6d76f9b4dbf0631815170c5a7}


The modules this module depend on. 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/tvm/runtime/\hyperlink{runtime_2module_8h}{module.\+h}\end{DoxyCompactItemize}
