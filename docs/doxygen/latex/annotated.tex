\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AdaptivePool2DAttrs}{tvm\+::relay\+::\+Adaptive\+Pool2\+D\+Attrs} \\*Attributes for adaptive pool operator }{\pageref{structtvm_1_1relay_1_1AdaptivePool2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AdaptivePool3DAttrs}{tvm\+::relay\+::\+Adaptive\+Pool3\+D\+Attrs} }{\pageref{structtvm_1_1relay_1_1AdaptivePool3DAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AddNode}{tvm\+::tir\+::\+Add\+Node} \\*
\begin{DoxyItemize}
\item b 
\end{DoxyItemize}}{\pageref{classtvm_1_1tir_1_1AddNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ADT}{tvm\+::runtime\+::\+A\+DT} \\*Reference to algebraic data type objects }{\pageref{classtvm_1_1runtime_1_1ADT}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ADTObj}{tvm\+::runtime\+::\+A\+D\+T\+Obj} \\*An object representing a structure or enumeration }{\pageref{classtvm_1_1runtime_1_1ADTObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AllocateNode}{tvm\+::tir\+::\+Allocate\+Node} \\*Allocate a buffer that can be used in body }{\pageref{classtvm_1_1tir_1_1AllocateNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AllocTensorAttrs}{tvm\+::relay\+::\+Alloc\+Tensor\+Attrs} \\*Options for allocating tensors }{\pageref{structtvm_1_1relay_1_1AllocTensorAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1Analyzer}{tvm\+::arith\+::\+Analyzer} \\*\hyperlink{classtvm_1_1arith_1_1Analyzer}{Analyzer} that contains bunch of sub-\/analyzers }{\pageref{classtvm_1_1arith_1_1Analyzer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AndNode}{tvm\+::tir\+::\+And\+Node} \\*\&\& b }{\pageref{classtvm_1_1tir_1_1AndNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AnyNode}{tvm\+::tir\+::\+Any\+Node} \\*Any shape }{\pageref{classtvm_1_1tir_1_1AnyNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ArangeAttrs}{tvm\+::relay\+::\+Arange\+Attrs} \\*Attributes used in arange operators }{\pageref{structtvm_1_1relay_1_1ArangeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ArgsortAttrs}{tvm\+::relay\+::\+Argsort\+Attrs} \\*Attributes used in argsort operators }{\pageref{structtvm_1_1relay_1_1ArgsortAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Array}{tvm\+::\+Array$<$ T, typename $>$} \\*\hyperlink{classtvm_1_1Array}{Array} container of Node\+Ref in D\+SL graph. \hyperlink{classtvm_1_1Array}{Array} implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places }{\pageref{classtvm_1_1Array}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1SimpleObjAllocator_1_1ArrayHandler}{tvm\+::runtime\+::\+Simple\+Obj\+Allocator\+::\+Array\+Handler$<$ Array\+Type, Elem\+Type $>$} }{\pageref{classtvm_1_1runtime_1_1SimpleObjAllocator_1_1ArrayHandler}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ArrayNode}{tvm\+::\+Array\+Node} \\*\hyperlink{classtvm_1_1Array}{Array} node content in array }{\pageref{classtvm_1_1ArrayNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AssertStmtNode}{tvm\+::tir\+::\+Assert\+Stmt\+Node} \\*Assert condition, if an error occurs, return the error message }{\pageref{classtvm_1_1tir_1_1AssertStmtNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrDocEntry}{tvm\+::detail\+::\+Attr\+Doc\+Entry} }{\pageref{classtvm_1_1detail_1_1AttrDocEntry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrDocVisitor}{tvm\+::detail\+::\+Attr\+Doc\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrDocVisitor}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1AttrError}{tvm\+::\+Attr\+Error} \\*\hyperlink{classtvm_1_1Error}{Error} thrown during attribute checking }{\pageref{structtvm_1_1AttrError}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrExistVisitor}{tvm\+::detail\+::\+Attr\+Exist\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrExistVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrFieldInfo}{tvm\+::\+Attr\+Field\+Info} \\*\hyperlink{classtvm_1_1AttrFieldInfo}{Attr\+Field\+Info} }{\pageref{classtvm_1_1AttrFieldInfo}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrFieldInfoNode}{tvm\+::\+Attr\+Field\+Info\+Node} \\*Information about attribute fields in string representations }{\pageref{classtvm_1_1AttrFieldInfoNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1AttrInitEntry}{tvm\+::detail\+::\+Attr\+Init\+Entry$<$ T $>$} }{\pageref{structtvm_1_1detail_1_1AttrInitEntry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrInitVisitor}{tvm\+::detail\+::\+Attr\+Init\+Visitor$<$ F\+Find $>$} }{\pageref{classtvm_1_1detail_1_1AttrInitVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrNonDefaultVisitor}{tvm\+::detail\+::\+Attr\+Non\+Default\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrNonDefaultVisitor}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1AttrNopEntry}{tvm\+::detail\+::\+Attr\+Nop\+Entry} }{\pageref{structtvm_1_1detail_1_1AttrNopEntry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrNormalVisitor}{tvm\+::detail\+::\+Attr\+Normal\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrNormalVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Attrs}{tvm\+::\+Attrs} \\*Managed reference to \hyperlink{classtvm_1_1BaseAttrsNode}{Base\+Attrs\+Node} }{\pageref{classtvm_1_1Attrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrsEqual}{tvm\+::\+Attrs\+Equal} \\*Content-\/aware Equality comparator for attrs }{\pageref{classtvm_1_1AttrsEqual}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrsEqualVisitor}{tvm\+::detail\+::\+Attrs\+Equal\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrsEqualVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrsHash}{tvm\+::\+Attrs\+Hash} \\*Content-\/aware hash function }{\pageref{classtvm_1_1AttrsHash}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrsHashVisitor}{tvm\+::detail\+::\+Attrs\+Hash\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrsHashVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrsNode}{tvm\+::\+Attrs\+Node$<$ Derived\+Type $>$} \\*The base class of the all the Use \char`\"{}curiously recurring template pattern\char`\"{} }{\pageref{classtvm_1_1AttrsNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrsSEqualVisitor}{tvm\+::detail\+::\+Attrs\+S\+Equal\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrsSEqualVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1detail_1_1AttrsSHashVisitor}{tvm\+::detail\+::\+Attrs\+S\+Hash\+Visitor} }{\pageref{classtvm_1_1detail_1_1AttrsSHashVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1AttrStmtNode}{tvm\+::tir\+::\+Attr\+Stmt\+Node} \\*Define certain auxiliary attribute for the body to be a symbolic value. This provide auxiliary information for IR passes that transforms body }{\pageref{classtvm_1_1tir_1_1AttrStmtNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1AttrTriggerNonDefaultEntry}{tvm\+::detail\+::\+Attr\+Trigger\+Non\+Default\+Entry$<$ T $>$} }{\pageref{structtvm_1_1detail_1_1AttrTriggerNonDefaultEntry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1AttrVisitor}{tvm\+::\+Attr\+Visitor} \\*Visitor class for to get the attributesof a A\+S\+T/\+IR node. The content is going to be called for each field }{\pageref{classtvm_1_1AttrVisitor}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AvgPool1DAttrs}{tvm\+::relay\+::\+Avg\+Pool1\+D\+Attrs} \\*Attributes for 1D avg pool operator }{\pageref{structtvm_1_1relay_1_1AvgPool1DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AvgPool2DAttrs}{tvm\+::relay\+::\+Avg\+Pool2\+D\+Attrs} \\*Attributes for avg pool operator }{\pageref{structtvm_1_1relay_1_1AvgPool2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1AvgPool3DAttrs}{tvm\+::relay\+::\+Avg\+Pool3\+D\+Attrs} \\*Attributes for 3D avg pool operator }{\pageref{structtvm_1_1relay_1_1AvgPool3DAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseAttrsNode}{tvm\+::\+Base\+Attrs\+Node} \\*Base class of all attribute class }{\pageref{classtvm_1_1BaseAttrsNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1BaseComputeOpNode}{tvm\+::te\+::\+Base\+Compute\+Op\+Node} \\*A Compute op that compute a tensor on certain domain. This is the base class for Compute\+Op (operating on a scalar at a time) and Tensor\+Compute\+Op (operating on a Tensor\+Slice at a time) }{\pageref{classtvm_1_1te_1_1BaseComputeOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseExpr}{tvm\+::\+Base\+Expr} \\*Managed reference to \hyperlink{classtvm_1_1BaseExprNode}{Base\+Expr\+Node} }{\pageref{classtvm_1_1BaseExpr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseExprNode}{tvm\+::\+Base\+Expr\+Node} \\*Base type of all the expressions }{\pageref{classtvm_1_1BaseExprNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseFunc}{tvm\+::\+Base\+Func} \\*Managed reference to \hyperlink{classtvm_1_1BaseFuncNode}{Base\+Func\+Node} }{\pageref{classtvm_1_1BaseFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseFuncNode}{tvm\+::\+Base\+Func\+Node} \\*Base node of all functions }{\pageref{classtvm_1_1BaseFuncNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseTensorType}{tvm\+::\+Base\+Tensor\+Type} \\*Managed reference to \hyperlink{classtvm_1_1BaseTensorTypeNode}{Base\+Tensor\+Type\+Node} }{\pageref{classtvm_1_1BaseTensorType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseTensorTypeNode}{tvm\+::\+Base\+Tensor\+Type\+Node} \\*Base of all Tensor types This container can hold \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} or Generic\+Tensor\+Type }{\pageref{classtvm_1_1BaseTensorTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseValueEqual}{tvm\+::\+Base\+Value\+Equal} \\*Equality definition of base value class }{\pageref{classtvm_1_1BaseValueEqual}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BaseValueHash}{tvm\+::\+Base\+Value\+Hash} \\*Hash definition of base value classes }{\pageref{classtvm_1_1BaseValueHash}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1BatchNormAttrs}{tvm\+::relay\+::\+Batch\+Norm\+Attrs} \\*Attributes used in batch\+\_\+norm operator }{\pageref{structtvm_1_1relay_1_1BatchNormAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1BiasAddAttrs}{tvm\+::relay\+::\+Bias\+Add\+Attrs} \\*Add a 1D Tensor to an axis of a data }{\pageref{structtvm_1_1relay_1_1BiasAddAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1BijectiveLayout}{tvm\+::tir\+::\+Bijective\+Layout} \\*Bijective function mapping for data layout transformation. Given two \hyperlink{classtvm_1_1tir_1_1Layout}{Layout}, \hyperlink{classtvm_1_1tir_1_1BijectiveLayout}{Bijective\+Layout} build and store the mapping rules, provides A\+PI to transform N-\/dimention tensor from the source indices (i0, i1, …, im) to the destination indices (j0, j1, … jm) }{\pageref{classtvm_1_1tir_1_1BijectiveLayout}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1BijectiveLayoutNode}{tvm\+::tir\+::\+Bijective\+Layout\+Node} }{\pageref{classtvm_1_1tir_1_1BijectiveLayoutNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1BinaryConv2DAttrs}{tvm\+::relay\+::\+Binary\+Conv2\+D\+Attrs} \\*Attribues used in bitserial convolution operators }{\pageref{structtvm_1_1relay_1_1BinaryConv2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1BinaryDenseAttrs}{tvm\+::relay\+::\+Binary\+Dense\+Attrs} }{\pageref{structtvm_1_1relay_1_1BinaryDenseAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1BinaryOpNode}{tvm\+::tir\+::\+Binary\+Op\+Node$<$ T $>$} \\*Base template to implement binary ops }{\pageref{classtvm_1_1tir_1_1BinaryOpNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1BitPackAttrs}{tvm\+::relay\+::\+Bit\+Pack\+Attrs} \\*Attributes used in bitpack operators }{\pageref{structtvm_1_1relay_1_1BitPackAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1BroadcastNode}{tvm\+::tir\+::\+Broadcast\+Node} \\*Create a vector where all the elements are value }{\pageref{classtvm_1_1tir_1_1BroadcastNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1Buffer}{tvm\+::tir\+::\+Buffer} \\*\hyperlink{classtvm_1_1tir_1_1Buffer}{Buffer} is a symbolic n-\/darray structure. It is a composition of primitive symbolic types, used to specify the memory layout of the Tensor used in program input }{\pageref{classtvm_1_1tir_1_1Buffer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1BufferNode}{tvm\+::tir\+::\+Buffer\+Node} \\*Node to represent a buffer }{\pageref{classtvm_1_1tir_1_1BufferNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BuildConfig}{tvm\+::\+Build\+Config} \\*Build configuration for compilations }{\pageref{classtvm_1_1BuildConfig}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1BuildConfigNode}{tvm\+::\+Build\+Config\+Node} \\*Container for build configuration options }{\pageref{classtvm_1_1BuildConfigNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Call}{tvm\+::relay\+::\+Call} }{\pageref{classtvm_1_1relay_1_1Call}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1CallNode}{tvm\+::relay\+::\+Call\+Node} \\*\hyperlink{classtvm_1_1relay_1_1Call}{Call} container }{\pageref{classtvm_1_1relay_1_1CallNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1CallNode}{tvm\+::tir\+::\+Call\+Node} \\*Call node }{\pageref{classtvm_1_1tir_1_1CallNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1CanonicalSimplifier}{tvm\+::arith\+::\+Canonical\+Simplifier} \\*Canonical-\/form based simplifier }{\pageref{classtvm_1_1arith_1_1CanonicalSimplifier}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1CastAttrs}{tvm\+::relay\+::\+Cast\+Attrs} \\*Data type cast }{\pageref{structtvm_1_1relay_1_1CastAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1CastHintAttrs}{tvm\+::relay\+::\+Cast\+Hint\+Attrs} \\*Annotate an expression to be cast into specific data type }{\pageref{structtvm_1_1relay_1_1CastHintAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1CastNode}{tvm\+::tir\+::\+Cast\+Node} \\*Cast value from one data type to another }{\pageref{classtvm_1_1tir_1_1CastNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Clause}{tvm\+::relay\+::\+Clause} }{\pageref{classtvm_1_1relay_1_1Clause}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ClauseNode}{tvm\+::relay\+::\+Clause\+Node} \\*\hyperlink{classtvm_1_1relay_1_1Clause}{Clause} container node }{\pageref{classtvm_1_1relay_1_1ClauseNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ClipAttrs}{tvm\+::relay\+::\+Clip\+Attrs} \\*Attributes for Clip operator }{\pageref{structtvm_1_1relay_1_1ClipAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1Closure}{tvm\+::runtime\+::vm\+::\+Closure} \\*Reference to closure }{\pageref{classtvm_1_1runtime_1_1vm_1_1Closure}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1ClosureObj}{tvm\+::runtime\+::vm\+::\+Closure\+Obj} \\*An object representing a closure. This object is used by both the Relay VM and interpreter }{\pageref{classtvm_1_1runtime_1_1vm_1_1ClosureObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1CmpOpNode}{tvm\+::tir\+::\+Cmp\+Op\+Node$<$ T $>$} \\*Base template to implement comparison ops }{\pageref{classtvm_1_1tir_1_1CmpOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1CommReducer}{tvm\+::tir\+::\+Comm\+Reducer} }{\pageref{classtvm_1_1tir_1_1CommReducer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1CommReducerNode}{tvm\+::tir\+::\+Comm\+Reducer\+Node} \\*A commutative reducer node to represent a commutative binary operator with identity element }{\pageref{classtvm_1_1tir_1_1CommReducerNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1CompilerAttrs}{tvm\+::relay\+::\+Compiler\+Attrs} \\*Options for the operators used to annotate a compiler }{\pageref{structtvm_1_1relay_1_1CompilerAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1ComputeOpNode}{tvm\+::te\+::\+Compute\+Op\+Node} \\*A Compute op that compute a tensor on certain domain }{\pageref{classtvm_1_1te_1_1ComputeOpNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ConcatenateAttrs}{tvm\+::relay\+::\+Concatenate\+Attrs} \\*Attributes used in concatenate operators }{\pageref{structtvm_1_1relay_1_1ConcatenateAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Constant}{tvm\+::relay\+::\+Constant} }{\pageref{classtvm_1_1relay_1_1Constant}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ConstantNode}{tvm\+::relay\+::\+Constant\+Node} \\*\hyperlink{classtvm_1_1relay_1_1Constant}{Constant} tensor type }{\pageref{classtvm_1_1relay_1_1ConstantNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ConstIntBound}{tvm\+::arith\+::\+Const\+Int\+Bound} \\*Reference class to \hyperlink{classtvm_1_1arith_1_1ConstIntBoundNode}{Const\+Int\+Bound\+Node} }{\pageref{classtvm_1_1arith_1_1ConstIntBound}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ConstIntBoundAnalyzer}{tvm\+::arith\+::\+Const\+Int\+Bound\+Analyzer} \\*\hyperlink{classtvm_1_1arith_1_1Analyzer}{Analyzer} to get constant integer bound over expression }{\pageref{classtvm_1_1arith_1_1ConstIntBoundAnalyzer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ConstIntBoundNode}{tvm\+::arith\+::\+Const\+Int\+Bound\+Node} \\*Constant integer up and lower bound(inclusive). Useful for value bound analysis }{\pageref{classtvm_1_1arith_1_1ConstIntBoundNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ConstraintContext}{tvm\+::arith\+::\+Constraint\+Context} \\*Constraint context }{\pageref{classtvm_1_1arith_1_1ConstraintContext}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Constructor}{tvm\+::\+Constructor} \\*Managed reference to \hyperlink{classtvm_1_1ConstructorNode}{Constructor\+Node} }{\pageref{classtvm_1_1Constructor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ConstructorNode}{tvm\+::\+Constructor\+Node} \\*A\+DT constructor. Constructors compare by pointer equality }{\pageref{classtvm_1_1ConstructorNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ConstructorValue}{tvm\+::relay\+::\+Constructor\+Value} }{\pageref{classtvm_1_1relay_1_1ConstructorValue}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ConstructorValueObj}{tvm\+::relay\+::\+Constructor\+Value\+Obj} }{\pageref{structtvm_1_1relay_1_1ConstructorValueObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1NDArray_1_1Container}{tvm\+::runtime\+::\+N\+D\+Array\+::\+Container} \\*\hyperlink{classtvm_1_1runtime_1_1Object}{Object} container class that backs \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array} }{\pageref{classtvm_1_1runtime_1_1NDArray_1_1Container}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1NDArray_1_1ContainerBase}{tvm\+::runtime\+::\+N\+D\+Array\+::\+Container\+Base} \\*The container base structure contains all the fields except for the \hyperlink{classtvm_1_1runtime_1_1Object}{Object} header }{\pageref{classtvm_1_1runtime_1_1NDArray_1_1ContainerBase}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv1DAttrs}{tvm\+::relay\+::\+Conv1\+D\+Attrs} \\*Attributes used in 1D convolution operators }{\pageref{structtvm_1_1relay_1_1Conv1DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv1DTransposeAttrs}{tvm\+::relay\+::\+Conv1\+D\+Transpose\+Attrs} \\*Attributes used in 1D transposed convolution operator }{\pageref{structtvm_1_1relay_1_1Conv1DTransposeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv2DAttrs}{tvm\+::relay\+::\+Conv2\+D\+Attrs} \\*Attributes used in convolution operators }{\pageref{structtvm_1_1relay_1_1Conv2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv2DTransposeAttrs}{tvm\+::relay\+::\+Conv2\+D\+Transpose\+Attrs} \\*Attributes used in transposed convolution operator }{\pageref{structtvm_1_1relay_1_1Conv2DTransposeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv2DWinogradAttrs}{tvm\+::relay\+::\+Conv2\+D\+Winograd\+Attrs} \\*Attributes used in convolution operators with winograd algorithm }{\pageref{structtvm_1_1relay_1_1Conv2DWinogradAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs}{tvm\+::relay\+::\+Conv2\+D\+Winograd\+N\+N\+P\+A\+C\+K\+Weight\+Transform\+Attrs} \\*Attributes used in winograd weight transformation operators }{\pageref{structtvm_1_1relay_1_1Conv2DWinogradNNPACKWeightTransformAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs}{tvm\+::relay\+::\+Conv2\+D\+Winograd\+Weight\+Transform\+Attrs} \\*Attributes used in winograd weight transformation operators }{\pageref{structtvm_1_1relay_1_1Conv2DWinogradWeightTransformAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Conv3DAttrs}{tvm\+::relay\+::\+Conv3\+D\+Attrs} \\*Attributes used in convolution operators }{\pageref{structtvm_1_1relay_1_1Conv3DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1CropAndResizeAttrs}{tvm\+::relay\+::\+Crop\+And\+Resize\+Attrs} \\*Attributes used in image crop\+\_\+and\+\_\+resize operator }{\pageref{structtvm_1_1relay_1_1CropAndResizeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1DataType}{tvm\+::runtime\+::\+Data\+Type} \\*Runtime primitive data type }{\pageref{classtvm_1_1runtime_1_1DataType}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1DebugAttrs}{tvm\+::relay\+::\+Debug\+Attrs} \\*Options for the debug operators }{\pageref{structtvm_1_1relay_1_1DebugAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1DeformableConv2DAttrs}{tvm\+::relay\+::\+Deformable\+Conv2\+D\+Attrs} \\*Attributes for Deformable\+Conv2D operator }{\pageref{structtvm_1_1relay_1_1DeformableConv2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1DenseAttrs}{tvm\+::relay\+::\+Dense\+Attrs} \\*Attributes for dense operator }{\pageref{structtvm_1_1relay_1_1DenseAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1DeviceAPI}{tvm\+::runtime\+::\+Device\+A\+PI} \\*T\+VM Runtime Device A\+PI, abstracts the device specific interface for memory management }{\pageref{classtvm_1_1runtime_1_1DeviceAPI}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1DeviceCopyAttrs}{tvm\+::relay\+::\+Device\+Copy\+Attrs} \\*Options for the device copy operators }{\pageref{structtvm_1_1relay_1_1DeviceCopyAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1DictAttrs}{tvm\+::\+Dict\+Attrs} \\*Managed reference to \hyperlink{classtvm_1_1DictAttrsNode}{Dict\+Attrs\+Node} }{\pageref{classtvm_1_1DictAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1DictAttrsNode}{tvm\+::\+Dict\+Attrs\+Node} \\*Specialized attribute type that is backed by a map. The \hyperlink{classtvm_1_1DictAttrsNode}{Dict\+Attrs\+Node} implements the \hyperlink{classtvm_1_1Attrs}{Attrs} behavior, its fields are directly accessible via object.\+field\+\_\+name like other normal nodes }{\pageref{classtvm_1_1DictAttrsNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1Dilation2DAttrs}{tvm\+::relay\+::\+Dilation2\+D\+Attrs} \\*Attributes used in dilation operators }{\pageref{structtvm_1_1relay_1_1Dilation2DAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1DivNode}{tvm\+::tir\+::\+Div\+Node} \\*/ b in the C semnatics }{\pageref{classtvm_1_1tir_1_1DivNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1DropoutAttrs}{tvm\+::relay\+::\+Dropout\+Attrs} \\*Attributes used in dropout operator }{\pageref{structtvm_1_1relay_1_1DropoutAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1EnvFunc}{tvm\+::\+Env\+Func} \\*Managed reference to \hyperlink{classtvm_1_1EnvFuncNode}{Env\+Func\+Node} }{\pageref{classtvm_1_1EnvFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1EnvFuncNode}{tvm\+::\+Env\+Func\+Node} \\*A serializable function backed by T\+VM\textquotesingle{}s global environment }{\pageref{classtvm_1_1EnvFuncNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1EQNode}{tvm\+::tir\+::\+E\+Q\+Node} \\*== b }{\pageref{classtvm_1_1tir_1_1EQNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Error}{tvm\+::\+Error} \\*Custom \hyperlink{classtvm_1_1Error}{Error} class to be thrown during compilation }{\pageref{classtvm_1_1Error}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1ErrorBuilder}{tvm\+::\+Error\+Builder} \\*A wrapper around std\+::stringstream to build error }{\pageref{structtvm_1_1ErrorBuilder}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ErrorReporter}{tvm\+::\+Error\+Reporter} \\*An abstraction around how errors are stored and reported. Designed to be opaque to users, so we can support a robust and simpler error reporting mode, as well as a more complex mode }{\pageref{classtvm_1_1ErrorReporter}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1EvaluateNode}{tvm\+::tir\+::\+Evaluate\+Node} \\*Evaluates an expression. This is mostly used for putting a Call node into \hyperlink{classtvm_1_1tir_1_1Stmt}{Stmt} }{\pageref{classtvm_1_1tir_1_1EvaluateNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1Executable}{tvm\+::runtime\+::vm\+::\+Executable} \\*The executable emitted by the VM compiler }{\pageref{classtvm_1_1runtime_1_1vm_1_1Executable}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ExpandDimsAttrs}{tvm\+::relay\+::\+Expand\+Dims\+Attrs} \\*Attributes used in expand\+\_\+dims operators }{\pageref{structtvm_1_1relay_1_1ExpandDimsAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ExprFunctor}{tvm\+::relay\+::\+Expr\+Functor$<$ F\+Type $>$} \\*A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit \hyperlink{classtvm_1_1relay_1_1Function}{Function} }{\pageref{classtvm_1_1relay_1_1ExprFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ExprFunctor}{tvm\+::tir\+::\+Expr\+Functor$<$ F\+Type $>$} \\*A dynamical functor that dispatches on in the first Expr argument. You can use this as a more powerful Visitor, since it allows you to define function signatures of Visit Function }{\pageref{classtvm_1_1tir_1_1ExprFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4}{tvm\+::relay\+::\+Expr\+Functor$<$ R(const Expr \&n, Args...)$>$} }{\pageref{classtvm_1_1relay_1_1ExprFunctor_3_01R_07const_01Expr_01_6n_00_01Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4}{tvm\+::tir\+::\+Expr\+Functor$<$ R(const Prim\+Expr \&n, Args...)$>$} }{\pageref{classtvm_1_1tir_1_1ExprFunctor_3_01R_07const_01PrimExpr_01_6n_00_01Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ExprMutator}{tvm\+::relay\+::\+Expr\+Mutator} \\*A wrapper around \hyperlink{classtvm_1_1relay_1_1ExprFunctor}{Expr\+Functor} which functionally updates the A\+ST }{\pageref{classtvm_1_1relay_1_1ExprMutator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ExprMutator}{tvm\+::tir\+::\+Expr\+Mutator} \\*\hyperlink{classtvm_1_1tir_1_1ExprMutator}{Expr\+Mutator} that mutates expressions }{\pageref{classtvm_1_1tir_1_1ExprMutator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ExprVisitor}{tvm\+::tir\+::\+Expr\+Visitor} \\*\hyperlink{classtvm_1_1tir_1_1ExprVisitor}{Expr\+Visitor} }{\pageref{classtvm_1_1tir_1_1ExprVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1ExprVisitor}{tvm\+::relay\+::\+Expr\+Visitor} \\*A simple visitor wrapper around \hyperlink{classtvm_1_1relay_1_1ExprFunctor}{Expr\+Functor}. Recursively visit the content }{\pageref{classtvm_1_1relay_1_1ExprVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1ExternOpNode}{tvm\+::te\+::\+Extern\+Op\+Node} \\*External computation that cannot be splitted }{\pageref{classtvm_1_1te_1_1ExternOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1FeatureSet}{tvm\+::relay\+::\+Feature\+Set} \\*A finite set of Feature }{\pageref{classtvm_1_1relay_1_1FeatureSet}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1FIFOBufferAttrs}{tvm\+::relay\+::\+F\+I\+F\+O\+Buffer\+Attrs} \\*Attributes for F\+I\+FO buffer operator }{\pageref{structtvm_1_1relay_1_1FIFOBufferAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SeqStmt_1_1Flattener}{tvm\+::tir\+::\+Seq\+Stmt\+::\+Flattener} \\*Helper class to flatten sequence of arguments into \hyperlink{classtvm_1_1Array}{Array} }{\pageref{classtvm_1_1tir_1_1SeqStmt_1_1Flattener}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1FloatImm}{tvm\+::\+Float\+Imm} \\*Managed reference class to \hyperlink{classtvm_1_1FloatImmNode}{Float\+Imm\+Node} }{\pageref{classtvm_1_1FloatImm}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1FloatImmNode}{tvm\+::\+Float\+Imm\+Node} \\*Constant floating point literals in the program }{\pageref{classtvm_1_1FloatImmNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1FloorDivNode}{tvm\+::tir\+::\+Floor\+Div\+Node} \\*Floor division, floor(a/b) }{\pageref{classtvm_1_1tir_1_1FloorDivNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1FloorModNode}{tvm\+::tir\+::\+Floor\+Mod\+Node} \\*The remainder of the floordiv }{\pageref{classtvm_1_1tir_1_1FloorModNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ForNode}{tvm\+::tir\+::\+For\+Node} \\*A for loop, with poissible type annotations }{\pageref{classtvm_1_1tir_1_1ForNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1FreeNode}{tvm\+::tir\+::\+Free\+Node} \\*Free the resources in the buffer before the scope ends }{\pageref{classtvm_1_1tir_1_1FreeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1StringObj_1_1FromStd}{tvm\+::runtime\+::\+String\+Obj\+::\+From\+Std} \\*An object representing string moved from std\+::string }{\pageref{classtvm_1_1runtime_1_1StringObj_1_1FromStd}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Function}{tvm\+::relay\+::\+Function} \\*Managed reference to \hyperlink{classtvm_1_1relay_1_1FunctionNode}{Function\+Node} }{\pageref{classtvm_1_1relay_1_1Function}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1FunctionBaseNode}{tvm\+::tir\+::\+Function\+Base\+Node} \\*Base node of internal functions }{\pageref{classtvm_1_1tir_1_1FunctionBaseNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1FunctionNode}{tvm\+::relay\+::\+Function\+Node} \\*Relay \hyperlink{classtvm_1_1relay_1_1Function}{Function} container }{\pageref{classtvm_1_1relay_1_1FunctionNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1FunctionRef}{tvm\+::tir\+::\+Function\+Ref} \\*Reference to a function }{\pageref{classtvm_1_1tir_1_1FunctionRef}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1FuncType}{tvm\+::\+Func\+Type} \\*Managed reference to \hyperlink{classtvm_1_1FuncTypeNode}{Func\+Type\+Node} }{\pageref{classtvm_1_1FuncType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1FuncTypeNode}{tvm\+::\+Func\+Type\+Node} \\*Function type }{\pageref{classtvm_1_1FuncTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1FuseNode}{tvm\+::te\+::\+Fuse\+Node} \\*Fuse two domains into one domain }{\pageref{classtvm_1_1te_1_1FuseNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GenericFunc}{tvm\+::\+Generic\+Func} \\*Generic function that can be specialized on a per-\/target basis }{\pageref{classtvm_1_1GenericFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GenericFuncNode}{tvm\+::\+Generic\+Func\+Node} \\*Represents a generic function that can be specialized on a per-\/target basis }{\pageref{classtvm_1_1GenericFuncNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GenericOpMap}{tvm\+::\+Generic\+Op\+Map} \\*Generic map to store additional information of \hyperlink{classtvm_1_1Op}{Op} }{\pageref{classtvm_1_1GenericOpMap}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1GENode}{tvm\+::tir\+::\+G\+E\+Node} \\*$>$= b }{\pageref{classtvm_1_1tir_1_1GENode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1GetValidCountsAttrs}{tvm\+::relay\+::\+Get\+Valid\+Counts\+Attrs} \\*Attributes used in get\+\_\+valid\+\_\+counts operator }{\pageref{structtvm_1_1relay_1_1GetValidCountsAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1GlobalPool2DAttrs}{tvm\+::relay\+::\+Global\+Pool2\+D\+Attrs} \\*Attributes for global pool operator }{\pageref{structtvm_1_1relay_1_1GlobalPool2DAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GlobalTypeVar}{tvm\+::\+Global\+Type\+Var} \\*Managed reference to \hyperlink{classtvm_1_1GlobalTypeVarNode}{Global\+Type\+Var\+Node} }{\pageref{classtvm_1_1GlobalTypeVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GlobalTypeVarNode}{tvm\+::\+Global\+Type\+Var\+Node} \\*A global type variable that is used for defining new types or type aliases }{\pageref{classtvm_1_1GlobalTypeVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GlobalVar}{tvm\+::\+Global\+Var} \\*Managed reference to \hyperlink{classtvm_1_1GlobalVarNode}{Global\+Var\+Node} }{\pageref{classtvm_1_1GlobalVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1GlobalVarNode}{tvm\+::\+Global\+Var\+Node} \\*Global variable that lives in the top-\/level module }{\pageref{classtvm_1_1GlobalVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1GTNode}{tvm\+::tir\+::\+G\+T\+Node} \\*$>$ b }{\pageref{classtvm_1_1tir_1_1GTNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SEqualReducer_1_1Handler}{tvm\+::\+S\+Equal\+Reducer\+::\+Handler} \\*Internal handler that defines custom behaviors. }{\pageref{classtvm_1_1SEqualReducer_1_1Handler}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SHashReducer_1_1Handler}{tvm\+::\+S\+Hash\+Reducer\+::\+Handler} \\*Internal handler that defines custom behaviors }{\pageref{classtvm_1_1SHashReducer_1_1Handler}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1SimpleObjAllocator_1_1Handler}{tvm\+::runtime\+::\+Simple\+Obj\+Allocator\+::\+Handler$<$ T $>$} }{\pageref{classtvm_1_1runtime_1_1SimpleObjAllocator_1_1Handler}}{}
\item\contentsline{section}{\hyperlink{structdmlc_1_1serializer_1_1Handler_3_01DLContext_01_4}{dmlc\+::serializer\+::\+Handler$<$ D\+L\+Context $>$} }{\pageref{structdmlc_1_1serializer_1_1Handler_3_01DLContext_01_4}}{}
\item\contentsline{section}{\hyperlink{structdmlc_1_1serializer_1_1Handler_3_01DLDataType_01_4}{dmlc\+::serializer\+::\+Handler$<$ D\+L\+Data\+Type $>$} }{\pageref{structdmlc_1_1serializer_1_1Handler_3_01DLDataType_01_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1HybridOpNode}{tvm\+::te\+::\+Hybrid\+Op\+Node} \\*A computation operator that generated by hybrid script }{\pageref{classtvm_1_1te_1_1HybridOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Id}{tvm\+::relay\+::\+Id} }{\pageref{classtvm_1_1relay_1_1Id}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1IdNode}{tvm\+::relay\+::\+Id\+Node} \\*The unique identifier of variables }{\pageref{classtvm_1_1relay_1_1IdNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1If}{tvm\+::relay\+::\+If} }{\pageref{classtvm_1_1relay_1_1If}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1IfNode}{tvm\+::relay\+::\+If\+Node} \\*Container of \hyperlink{classtvm_1_1relay_1_1If}{If} }{\pageref{classtvm_1_1relay_1_1IfNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1IfThenElseNode}{tvm\+::tir\+::\+If\+Then\+Else\+Node} \\*If\+Then\+Else statment }{\pageref{classtvm_1_1tir_1_1IfThenElseNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplSEqualReduce}{tvm\+::detail\+::\+Impl\+S\+Equal\+Reduce$<$ T, bool $>$} }{\pageref{structtvm_1_1detail_1_1ImplSEqualReduce}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplSEqualReduce_3_01T_00_01true_01_4}{tvm\+::detail\+::\+Impl\+S\+Equal\+Reduce$<$ T, true $>$} }{\pageref{structtvm_1_1detail_1_1ImplSEqualReduce_3_01T_00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplSHashReduce}{tvm\+::detail\+::\+Impl\+S\+Hash\+Reduce$<$ T, bool $>$} }{\pageref{structtvm_1_1detail_1_1ImplSHashReduce}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplSHashReduce_3_01T_00_01true_01_4}{tvm\+::detail\+::\+Impl\+S\+Hash\+Reduce$<$ T, true $>$} }{\pageref{structtvm_1_1detail_1_1ImplSHashReduce_3_01T_00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplVisitAttrs}{tvm\+::detail\+::\+Impl\+Visit\+Attrs$<$ T, bool $>$} }{\pageref{structtvm_1_1detail_1_1ImplVisitAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ImplVisitAttrs_3_01T_00_01true_01_4}{tvm\+::detail\+::\+Impl\+Visit\+Attrs$<$ T, true $>$} }{\pageref{structtvm_1_1detail_1_1ImplVisitAttrs_3_01T_00_01true_01_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IncompleteType}{tvm\+::\+Incomplete\+Type} \\*Managed reference to \hyperlink{classtvm_1_1IncompleteTypeNode}{Incomplete\+Type\+Node} }{\pageref{classtvm_1_1IncompleteType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IncompleteTypeNode}{tvm\+::\+Incomplete\+Type\+Node} \\*Intermediate values that is used to indicate incomplete type during type inference }{\pageref{classtvm_1_1IncompleteTypeNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1InitOpAttrs}{tvm\+::relay\+::\+Init\+Op\+Attrs} \\*Attributes that specify a tensor }{\pageref{structtvm_1_1relay_1_1InitOpAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1InplaceArrayBase}{tvm\+::runtime\+::\+Inplace\+Array\+Base$<$ Array\+Type, Elem\+Type $>$} \\*Base template for classes with array like memory layout }{\pageref{classtvm_1_1runtime_1_1InplaceArrayBase}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1InstanceNormAttrs}{tvm\+::relay\+::\+Instance\+Norm\+Attrs} \\*Attributes used in instance\+\_\+norm operator }{\pageref{structtvm_1_1relay_1_1InstanceNormAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1vm_1_1Instruction}{tvm\+::runtime\+::vm\+::\+Instruction} \\*A single virtual machine instruction }{\pageref{structtvm_1_1runtime_1_1vm_1_1Instruction}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Integer}{tvm\+::\+Integer} \\*Container of constant int that adds more constructors }{\pageref{classtvm_1_1Integer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1InterpreterClosure}{tvm\+::relay\+::\+Interpreter\+Closure} }{\pageref{classtvm_1_1relay_1_1InterpreterClosure}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1InterpreterClosureObj}{tvm\+::relay\+::\+Interpreter\+Closure\+Obj} \\*The container type of Closures used by the interpreter }{\pageref{classtvm_1_1relay_1_1InterpreterClosureObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IntImm}{tvm\+::\+Int\+Imm} \\*Managed reference class to \hyperlink{classtvm_1_1IntImmNode}{Int\+Imm\+Node} }{\pageref{classtvm_1_1IntImm}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IntImmNode}{tvm\+::\+Int\+Imm\+Node} \\*Constant integer literals in the program }{\pageref{classtvm_1_1IntImmNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1IntSet}{tvm\+::arith\+::\+Int\+Set} \\*Managed reference to \hyperlink{classtvm_1_1arith_1_1IntSetNode}{Int\+Set\+Node} }{\pageref{classtvm_1_1arith_1_1IntSet}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1IntSetAnalyzer}{tvm\+::arith\+::\+Int\+Set\+Analyzer} \\*\hyperlink{classtvm_1_1Integer}{Integer} set analyzer }{\pageref{classtvm_1_1arith_1_1IntSetAnalyzer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1IntSetNode}{tvm\+::arith\+::\+Int\+Set\+Node} \\*Base class of all \hyperlink{classtvm_1_1Integer}{Integer} set containers. represent a set of integers in one dimension }{\pageref{classtvm_1_1arith_1_1IntSetNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IRModule}{tvm\+::\+I\+R\+Module} \\*Managed reference class to \hyperlink{classtvm_1_1IRModuleNode}{I\+R\+Module\+Node} }{\pageref{classtvm_1_1IRModule}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IRModuleNode}{tvm\+::\+I\+R\+Module\+Node} \\*\hyperlink{classtvm_1_1IRModule}{I\+R\+Module} that holds functions and type definitions }{\pageref{classtvm_1_1IRModuleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1IterAdapter}{tvm\+::\+Iter\+Adapter$<$ Converter, T\+Iter $>$} \\*Iterator adapter that adapts T\+Iter to return another type }{\pageref{classtvm_1_1IterAdapter}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1IterVar}{tvm\+::tir\+::\+Iter\+Var} \\*Iteration Variable, represents an iteration over an integer interval }{\pageref{classtvm_1_1tir_1_1IterVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1IterVarAttr}{tvm\+::te\+::\+Iter\+Var\+Attr} \\*Additional scheduable attributes about Iter\+Var }{\pageref{classtvm_1_1te_1_1IterVarAttr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1IterVarAttrNode}{tvm\+::te\+::\+Iter\+Var\+Attr\+Node} \\*Node container for Iter\+Var attr }{\pageref{classtvm_1_1te_1_1IterVarAttrNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1IterVarNode}{tvm\+::tir\+::\+Iter\+Var\+Node} \\*An iteration variable representing an iteration over a one dimensional interval }{\pageref{classtvm_1_1tir_1_1IterVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1IterVarRelation}{tvm\+::te\+::\+Iter\+Var\+Relation} \\*The schedule relation between Iter\+Vars can be Split, Fuse }{\pageref{classtvm_1_1te_1_1IterVarRelation}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1IterVarRelationNode}{tvm\+::te\+::\+Iter\+Var\+Relation\+Node} \\*Base node of iteration var }{\pageref{classtvm_1_1te_1_1IterVarRelationNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1L2NormalizeAttrs}{tvm\+::relay\+::\+L2\+Normalize\+Attrs} \\*Attributes for L2\+Normalize operator }{\pageref{structtvm_1_1relay_1_1L2NormalizeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1LayerNormAttrs}{tvm\+::relay\+::\+Layer\+Norm\+Attrs} \\*Attributes used in layer\+\_\+norm operator }{\pageref{structtvm_1_1relay_1_1LayerNormAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1Layout}{tvm\+::tir\+::\+Layout} \\*\hyperlink{classtvm_1_1tir_1_1Layout}{Layout} is to describe how data is organized within an N-\/dimention tensor. It is composed of upper cases, lower cases and numbers, where upper case indicates a primal axis and the corresponding lower case with factor size indicates the subordinate axis. For example, N\+C\+H\+W16c can describe a 5-\/D tensor of \mbox{[}batch\+\_\+size, channel, height, width, channel\+\_\+block\mbox{]}. Here subordinate axis channel\+\_\+block=16 is the factor size of the primal axis C (channel). \hyperlink{classtvm_1_1tir_1_1Layout}{Layout} for scalar is defined, while both its name and axes have size 0 }{\pageref{classtvm_1_1tir_1_1Layout}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LayoutAxis}{tvm\+::tir\+::\+Layout\+Axis} }{\pageref{classtvm_1_1tir_1_1LayoutAxis}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LayoutNode}{tvm\+::tir\+::\+Layout\+Node} }{\pageref{classtvm_1_1tir_1_1LayoutNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1LayoutTransformAttrs}{tvm\+::relay\+::\+Layout\+Transform\+Attrs} \\*Attributes for Layout\+Transform operator }{\pageref{structtvm_1_1relay_1_1LayoutTransformAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1LeakyReluAttrs}{tvm\+::relay\+::\+Leaky\+Relu\+Attrs} \\*Attributes for leaky relu operator }{\pageref{structtvm_1_1relay_1_1LeakyReluAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1tir_1_1LENode}{tvm\+::tir\+::\+L\+E\+Node} \\*$<$= b }{\pageref{structtvm_1_1tir_1_1LENode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Let}{tvm\+::relay\+::\+Let} }{\pageref{classtvm_1_1relay_1_1Let}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1LetNode}{tvm\+::relay\+::\+Let\+Node} \\*A binding of a sub-\/network }{\pageref{classtvm_1_1relay_1_1LetNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LetNode}{tvm\+::tir\+::\+Let\+Node} \\*Let binding. Bind var to value then evaluate body }{\pageref{classtvm_1_1tir_1_1LetNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LetStmtNode}{tvm\+::tir\+::\+Let\+Stmt\+Node} \\*Let binding, bind var to value, then run body }{\pageref{classtvm_1_1tir_1_1LetStmtNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LoadNode}{tvm\+::tir\+::\+Load\+Node} \\*Load the value from buffer\+\_\+var }{\pageref{classtvm_1_1tir_1_1LoadNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{tvm\+::tir\+::\+Lowered\+Func} \\*\hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} represents function after lowering. This is the final IR representation before codegen }{\pageref{classtvm_1_1tir_1_1LoweredFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LoweredFuncNode}{tvm\+::tir\+::\+Lowered\+Func\+Node} \\*Node container of \hyperlink{classtvm_1_1tir_1_1LoweredFunc}{Lowered\+Func} }{\pageref{classtvm_1_1tir_1_1LoweredFuncNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1LRNAttrs}{tvm\+::relay\+::\+L\+R\+N\+Attrs} \\*Attributes for L\+RN operator }{\pageref{structtvm_1_1relay_1_1LRNAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1LTNode}{tvm\+::tir\+::\+L\+T\+Node} \\*$<$ b }{\pageref{classtvm_1_1tir_1_1LTNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Map}{tvm\+::\+Map$<$ K, V, typename, typename $>$} \\*\hyperlink{classtvm_1_1Map}{Map} container of Node\+Ref-\/$>$Node\+Ref in D\+SL graph. \hyperlink{classtvm_1_1Map}{Map} implements copy on write semantics, which means map is mutable but copy will happen when array is referenced in more than two places }{\pageref{classtvm_1_1Map}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1MapNode}{tvm\+::\+Map\+Node} \\*\hyperlink{classtvm_1_1Map}{Map} node content }{\pageref{classtvm_1_1MapNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Match}{tvm\+::relay\+::\+Match} }{\pageref{classtvm_1_1relay_1_1Match}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1MatchNode}{tvm\+::relay\+::\+Match\+Node} \\*\hyperlink{classtvm_1_1relay_1_1Match}{Match} container node }{\pageref{classtvm_1_1relay_1_1MatchNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1MaxNode}{tvm\+::tir\+::\+Max\+Node} \\*Max(a, b) }{\pageref{classtvm_1_1tir_1_1MaxNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MaxPool1DAttrs}{tvm\+::relay\+::\+Max\+Pool1\+D\+Attrs} \\*Attributes for 1D max pool operator }{\pageref{structtvm_1_1relay_1_1MaxPool1DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MaxPool2DAttrs}{tvm\+::relay\+::\+Max\+Pool2\+D\+Attrs} \\*Attributes for max pool operator }{\pageref{structtvm_1_1relay_1_1MaxPool2DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MaxPool3DAttrs}{tvm\+::relay\+::\+Max\+Pool3\+D\+Attrs} \\*Attributes for 3D max pool operator }{\pageref{structtvm_1_1relay_1_1MaxPool3DAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1MemoryInfo}{tvm\+::\+Memory\+Info} \\*Defines memory info }{\pageref{classtvm_1_1MemoryInfo}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1MemoryInfoNode}{tvm\+::\+Memory\+Info\+Node} \\*Memory information of special memory region. Use \hyperlink{classtvm_1_1MemoryInfo}{Memory\+Info} as its container type }{\pageref{classtvm_1_1MemoryInfoNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1MinNode}{tvm\+::tir\+::\+Min\+Node} \\*Min(a, b) }{\pageref{classtvm_1_1tir_1_1MinNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MirrorPadAttrs}{tvm\+::relay\+::\+Mirror\+Pad\+Attrs} \\*Attributes used for the Mirror\+Padding operator }{\pageref{structtvm_1_1relay_1_1MirrorPadAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ModNode}{tvm\+::tir\+::\+Mod\+Node} \\*\% b in the C semnatics }{\pageref{classtvm_1_1tir_1_1ModNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ModularSet}{tvm\+::arith\+::\+Modular\+Set} \\*Reference of \hyperlink{classtvm_1_1arith_1_1ModularSetNode}{Modular\+Set\+Node} }{\pageref{classtvm_1_1arith_1_1ModularSet}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ModularSetAnalyzer}{tvm\+::arith\+::\+Modular\+Set\+Analyzer} \\*\hyperlink{classtvm_1_1arith_1_1Analyzer}{Analyzer} to get modular information over expression }{\pageref{classtvm_1_1arith_1_1ModularSetAnalyzer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1ModularSetNode}{tvm\+::arith\+::\+Modular\+Set\+Node} \\*\hyperlink{classtvm_1_1Range}{Range} of a linear integer function. Use to do specify the possible index values }{\pageref{classtvm_1_1arith_1_1ModularSetNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1Module}{tvm\+::runtime\+::\+Module} \\*\hyperlink{classtvm_1_1runtime_1_1Module}{Module} container of T\+VM }{\pageref{classtvm_1_1runtime_1_1Module}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ModuleNode}{tvm\+::runtime\+::\+Module\+Node} \\*Base container of module }{\pageref{classtvm_1_1runtime_1_1ModuleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1MulNode}{tvm\+::tir\+::\+Mul\+Node} \\*
\begin{DoxyItemize}
\item b 
\end{DoxyItemize}}{\pageref{classtvm_1_1tir_1_1MulNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MultiBoxPriorAttrs}{tvm\+::relay\+::\+Multi\+Box\+Prior\+Attrs} \\*Attributes used in multibox\+\_\+prior operators }{\pageref{structtvm_1_1relay_1_1MultiBoxPriorAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1MultiBoxTransformLocAttrs}{tvm\+::relay\+::\+Multi\+Box\+Transform\+Loc\+Attrs} }{\pageref{structtvm_1_1relay_1_1MultiBoxTransformLocAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1NDArray}{tvm\+::runtime\+::\+N\+D\+Array} \\*Managed \hyperlink{classtvm_1_1runtime_1_1NDArray}{N\+D\+Array}. The array is backed by reference counted blocks }{\pageref{classtvm_1_1runtime_1_1NDArray}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1NdarraySizeAttrs}{tvm\+::relay\+::\+Ndarray\+Size\+Attrs} \\*Attributes for ndarray\+\_\+size operator }{\pageref{structtvm_1_1relay_1_1NdarraySizeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1NENode}{tvm\+::tir\+::\+N\+E\+Node} \\*!= b }{\pageref{classtvm_1_1tir_1_1NENode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1NodeFunctor}{tvm\+::\+Node\+Functor$<$ F\+Type $>$} \\*A dynamically dispatched functor on the type of the first argument }{\pageref{classtvm_1_1NodeFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1NodeFunctor_3_01R_07const_01ObjectRef_01_6n_00_01Args_8_8_8_08_4}{tvm\+::\+Node\+Functor$<$ R(const Object\+Ref \&n, Args...)$>$} }{\pageref{classtvm_1_1NodeFunctor_3_01R_07const_01ObjectRef_01_6n_00_01Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1NonMaximumSuppressionAttrs}{tvm\+::relay\+::\+Non\+Maximum\+Suppression\+Attrs} \\*Attributes used in non\+\_\+maximum\+\_\+suppression operator }{\pageref{structtvm_1_1relay_1_1NonMaximumSuppressionAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1NotNode}{tvm\+::tir\+::\+Not\+Node} \\*!a }{\pageref{classtvm_1_1tir_1_1NotNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ObjAllocatorBase}{tvm\+::runtime\+::\+Obj\+Allocator\+Base$<$ Derived $>$} \\*Base class of object allocators that implements make. Use curiously recurring template pattern }{\pageref{classtvm_1_1runtime_1_1ObjAllocatorBase}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1Object}{tvm\+::runtime\+::\+Object} \\*Base class of all object containers }{\pageref{classtvm_1_1runtime_1_1Object}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1ObjectEqual}{tvm\+::runtime\+::\+Object\+Equal} \\*\hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref} equal functor }{\pageref{structtvm_1_1runtime_1_1ObjectEqual}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1ObjectHash}{tvm\+::runtime\+::\+Object\+Hash} \\*\hyperlink{classtvm_1_1runtime_1_1ObjectRef}{Object\+Ref} hash functor }{\pageref{structtvm_1_1runtime_1_1ObjectHash}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ObjectPtr}{tvm\+::runtime\+::\+Object\+Ptr$<$ T $>$} \\*A custom smart pointer for \hyperlink{classtvm_1_1runtime_1_1Object}{Object} }{\pageref{classtvm_1_1runtime_1_1ObjectPtr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1ObjectRef}{tvm\+::runtime\+::\+Object\+Ref} \\*Base class of all object reference }{\pageref{classtvm_1_1runtime_1_1ObjectRef}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker}{tvm\+::runtime\+::\+Object\+Type\+Checker$<$ T $>$} \\*\hyperlink{classtvm_1_1Type}{Type} traits for runtime type check during F\+FI conversion }{\pageref{structtvm_1_1runtime_1_1ObjectTypeChecker}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4}{tvm\+::runtime\+::\+Object\+Type\+Checker$<$ Array$<$ T $>$ $>$} }{\pageref{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Array_3_01T_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4}{tvm\+::runtime\+::\+Object\+Type\+Checker$<$ Map$<$ K, V $>$ $>$} }{\pageref{structtvm_1_1runtime_1_1ObjectTypeChecker_3_01Map_3_01K_00_01V_01_4_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1OnDeviceAttrs}{tvm\+::relay\+::\+On\+Device\+Attrs} \\*Options for the device annotation operators }{\pageref{structtvm_1_1relay_1_1OnDeviceAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1OneHotAttrs}{tvm\+::relay\+::\+One\+Hot\+Attrs} \\*Attributes used in one-\/hot operator }{\pageref{structtvm_1_1relay_1_1OneHotAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Op}{tvm\+::\+Op} \\*Managed reference class to \hyperlink{classtvm_1_1OpNode}{Op\+Node} }{\pageref{classtvm_1_1Op}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1Operation}{tvm\+::te\+::\+Operation} \\*\hyperlink{classtvm_1_1te_1_1Operation}{Operation} that produces tensors }{\pageref{classtvm_1_1te_1_1Operation}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1OperationNode}{tvm\+::te\+::\+Operation\+Node} \\*Base class of all operation nodes }{\pageref{classtvm_1_1te_1_1OperationNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpImplementation}{tvm\+::relay\+::\+Op\+Implementation} \\*Operator implementation class }{\pageref{classtvm_1_1relay_1_1OpImplementation}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpImplementationNode}{tvm\+::relay\+::\+Op\+Implementation\+Node} \\*Operator implementation that includes compute and schedule function }{\pageref{classtvm_1_1relay_1_1OpImplementationNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1OpMap}{tvm\+::\+Op\+Map$<$ Value\+Type $>$} \\*Map$<$\+Op,\+Value\+Type$>$ used to store meta-\/information about \hyperlink{classtvm_1_1Op}{Op} }{\pageref{classtvm_1_1OpMap}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1OpNode}{tvm\+::\+Op\+Node} \\*Primitive Op(builtin intrinsics) }{\pageref{classtvm_1_1OpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1OpRegistry}{tvm\+::\+Op\+Registry} \\*Helper structure to register operators }{\pageref{classtvm_1_1OpRegistry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpSpecialization}{tvm\+::relay\+::\+Op\+Specialization} \\*Operator specialization class }{\pageref{classtvm_1_1relay_1_1OpSpecialization}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpSpecializationNode}{tvm\+::relay\+::\+Op\+Specialization\+Node} \\*Specialized implementations for operators under certain conditions }{\pageref{classtvm_1_1relay_1_1OpSpecializationNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpStrategy}{tvm\+::relay\+::\+Op\+Strategy} \\*Operator strategy class }{\pageref{classtvm_1_1relay_1_1OpStrategy}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1OpStrategyNode}{tvm\+::relay\+::\+Op\+Strategy\+Node} \\*Operator strategy to choose implementation }{\pageref{classtvm_1_1relay_1_1OpStrategyNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1OrNode}{tvm\+::tir\+::\+Or\+Node} \\*$\vert$$\vert$ b }{\pageref{classtvm_1_1tir_1_1OrNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1PackedFunc}{tvm\+::runtime\+::\+Packed\+Func} \\*Packed function is a type-\/erased function. The arguments are passed by packed format }{\pageref{classtvm_1_1runtime_1_1PackedFunc}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1PadAttrs}{tvm\+::relay\+::\+Pad\+Attrs} \\*Attributes used for the padding operator }{\pageref{structtvm_1_1relay_1_1PadAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1Pass}{tvm\+::transform\+::\+Pass} }{\pageref{classtvm_1_1transform_1_1Pass}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1PassContext}{tvm\+::transform\+::\+Pass\+Context} \\*\hyperlink{classtvm_1_1transform_1_1PassContext}{Pass\+Context} that is used to configure the pass behavior }{\pageref{classtvm_1_1transform_1_1PassContext}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1PassContextNode}{tvm\+::transform\+::\+Pass\+Context\+Node} \\*\hyperlink{classtvm_1_1transform_1_1PassContextNode}{Pass\+Context\+Node} contains the information that a pass can rely on, such as analysis results }{\pageref{classtvm_1_1transform_1_1PassContextNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1PassInfo}{tvm\+::transform\+::\+Pass\+Info} }{\pageref{classtvm_1_1transform_1_1PassInfo}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1PassInfoNode}{tvm\+::transform\+::\+Pass\+Info\+Node} \\*Meta data that will be used to help optimization and analysis }{\pageref{classtvm_1_1transform_1_1PassInfoNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1PassNode}{tvm\+::transform\+::\+Pass\+Node} \\*\hyperlink{classtvm_1_1transform_1_1PassNode}{Pass\+Node} is the base type of differnt types of optimization passes. It is designed as a pure class and implemented by different pass subclasses at different granularity of Relay nodes }{\pageref{classtvm_1_1transform_1_1PassNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Pattern}{tvm\+::relay\+::\+Pattern} \\*\hyperlink{classtvm_1_1relay_1_1Pattern}{Pattern} is the base type for an A\+DT match pattern in Relay }{\pageref{classtvm_1_1relay_1_1Pattern}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternConstructor}{tvm\+::relay\+::\+Pattern\+Constructor} }{\pageref{classtvm_1_1relay_1_1PatternConstructor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternConstructorNode}{tvm\+::relay\+::\+Pattern\+Constructor\+Node} \\*\hyperlink{classtvm_1_1relay_1_1PatternVar}{Pattern\+Var} container node }{\pageref{classtvm_1_1relay_1_1PatternConstructorNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternFunctor}{tvm\+::relay\+::\+Pattern\+Functor$<$ F\+Type $>$} \\*A dynamical functor on A\+DT patterns that dispatches on its first argument. You can use this as a more powerful visitor, since it allows you to define the types of further arguments to Visit\+Pattern }{\pageref{classtvm_1_1relay_1_1PatternFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternFunctor_3_01R_07const_01Pattern_01_6n_00_01Args_8_8_8_08_4}{tvm\+::relay\+::\+Pattern\+Functor$<$ R(const Pattern \&n, Args...)$>$} }{\pageref{classtvm_1_1relay_1_1PatternFunctor_3_01R_07const_01Pattern_01_6n_00_01Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternMutator}{tvm\+::relay\+::\+Pattern\+Mutator} \\*A wrapper around \hyperlink{classtvm_1_1relay_1_1ExprFunctor}{Expr\+Functor} which functionally updates the A\+ST }{\pageref{classtvm_1_1relay_1_1PatternMutator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternNode}{tvm\+::relay\+::\+Pattern\+Node} \\*Base type for declaring relay pattern }{\pageref{classtvm_1_1relay_1_1PatternNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternTuple}{tvm\+::relay\+::\+Pattern\+Tuple} }{\pageref{classtvm_1_1relay_1_1PatternTuple}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternTupleNode}{tvm\+::relay\+::\+Pattern\+Tuple\+Node} \\*\hyperlink{classtvm_1_1relay_1_1PatternVar}{Pattern\+Var} container node }{\pageref{classtvm_1_1relay_1_1PatternTupleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternVar}{tvm\+::relay\+::\+Pattern\+Var} }{\pageref{classtvm_1_1relay_1_1PatternVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternVarNode}{tvm\+::relay\+::\+Pattern\+Var\+Node} \\*\hyperlink{classtvm_1_1relay_1_1PatternVar}{Pattern\+Var} container node }{\pageref{classtvm_1_1relay_1_1PatternVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternVisitor}{tvm\+::relay\+::\+Pattern\+Visitor} \\*A simple visitor wrapper around \hyperlink{classtvm_1_1relay_1_1PatternFunctor}{Pattern\+Functor} }{\pageref{classtvm_1_1relay_1_1PatternVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternWildcard}{tvm\+::relay\+::\+Pattern\+Wildcard} }{\pageref{classtvm_1_1relay_1_1PatternWildcard}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1PatternWildcardNode}{tvm\+::relay\+::\+Pattern\+Wildcard\+Node} \\*\hyperlink{classtvm_1_1relay_1_1PatternWildcard}{Pattern\+Wildcard} container node }{\pageref{classtvm_1_1relay_1_1PatternWildcardNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1PlaceholderOpNode}{tvm\+::te\+::\+Placeholder\+Op\+Node} \\*A placeholder op represents an input placeholder }{\pageref{classtvm_1_1te_1_1PlaceholderOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PointerType}{tvm\+::\+Pointer\+Type} }{\pageref{classtvm_1_1PointerType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PointerTypeNode}{tvm\+::\+Pointer\+Type\+Node} \\*Low-\/level raw pointer type }{\pageref{classtvm_1_1PointerTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1PrefetchNode}{tvm\+::tir\+::\+Prefetch\+Node} \\*A prefetch hint of func }{\pageref{classtvm_1_1tir_1_1PrefetchNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1PReluAttrs}{tvm\+::relay\+::\+P\+Relu\+Attrs} \\*Attributes for prelu operator }{\pageref{structtvm_1_1relay_1_1PReluAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PrimExpr}{tvm\+::\+Prim\+Expr} \\*Reference to \hyperlink{classtvm_1_1PrimExprNode}{Prim\+Expr\+Node} }{\pageref{classtvm_1_1PrimExpr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PrimExprNode}{tvm\+::\+Prim\+Expr\+Node} \\*Base node of all primitive expressions }{\pageref{classtvm_1_1PrimExprNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1PrimFunc}{tvm\+::tir\+::\+Prim\+Func} \\*Managed reference to \hyperlink{classtvm_1_1tir_1_1PrimFuncNode}{Prim\+Func\+Node} }{\pageref{classtvm_1_1tir_1_1PrimFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1PrimFuncNode}{tvm\+::tir\+::\+Prim\+Func\+Node} \\*Primitive functions that contains T\+IR statements }{\pageref{classtvm_1_1tir_1_1PrimFuncNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PrimType}{tvm\+::\+Prim\+Type} }{\pageref{classtvm_1_1PrimType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1PrimTypeNode}{tvm\+::\+Prim\+Type\+Node} \\*Primitive data types used in the low-\/level IR }{\pageref{classtvm_1_1PrimTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ProducerConsumerNode}{tvm\+::tir\+::\+Producer\+Consumer\+Node} \\*Annotation node of producer/consumer relation }{\pageref{classtvm_1_1tir_1_1ProducerConsumerNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ProposalAttrs}{tvm\+::relay\+::\+Proposal\+Attrs} \\*Attributes used in proposal operators }{\pageref{structtvm_1_1relay_1_1ProposalAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ProvideNode}{tvm\+::tir\+::\+Provide\+Node} \\*Store value into mult-\/dimensional array defined by func }{\pageref{classtvm_1_1tir_1_1ProvideNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1qnn_1_1QuantizeAttrs}{tvm\+::relay\+::qnn\+::\+Quantize\+Attrs} \\*Attribute for quantize operator }{\pageref{structtvm_1_1relay_1_1qnn_1_1QuantizeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1RampNode}{tvm\+::tir\+::\+Ramp\+Node} \\*Construct a vector with lanes elements where its i-\/th element equals base + i $\ast$ stride. This is useful to construct a index for a continuous vector load }{\pageref{classtvm_1_1tir_1_1RampNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Range}{tvm\+::\+Range} \\*\hyperlink{classtvm_1_1Range}{Range} constainer }{\pageref{classtvm_1_1Range}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1RangeNode}{tvm\+::\+Range\+Node} \\*\hyperlink{classtvm_1_1Range}{Range} over one dimension }{\pageref{classtvm_1_1RangeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1RealizeNode}{tvm\+::tir\+::\+Realize\+Node} \\*Annotate the bounds where func need to be written and read in body. We will need to allocate space for the corresponding regions }{\pageref{classtvm_1_1tir_1_1RealizeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1RebaseNode}{tvm\+::te\+::\+Rebase\+Node} \\*Rebase the iteration to make min to be 0. This is useful to normalize the \hyperlink{classtvm_1_1te_1_1Schedule}{Schedule} to make every leaf variable\textquotesingle{}s min to be 0 }{\pageref{classtvm_1_1te_1_1RebaseNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RecClosure}{tvm\+::relay\+::\+Rec\+Closure} }{\pageref{classtvm_1_1relay_1_1RecClosure}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RecClosureObj}{tvm\+::relay\+::\+Rec\+Closure\+Obj} \\*The container type of \hyperlink{classtvm_1_1relay_1_1RecClosure}{Rec\+Closure} }{\pageref{classtvm_1_1relay_1_1RecClosureObj}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ReduceAttrs}{tvm\+::relay\+::\+Reduce\+Attrs} \\*Attributes for Reduce operators }{\pageref{structtvm_1_1relay_1_1ReduceAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ReduceNode}{tvm\+::tir\+::\+Reduce\+Node} \\*Reduction operator operator }{\pageref{classtvm_1_1tir_1_1ReduceNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefCreate}{tvm\+::relay\+::\+Ref\+Create} }{\pageref{classtvm_1_1relay_1_1RefCreate}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefCreateNode}{tvm\+::relay\+::\+Ref\+Create\+Node} }{\pageref{classtvm_1_1relay_1_1RefCreateNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1ReflectionTrait}{tvm\+::detail\+::\+Reflection\+Trait$<$ T $>$} }{\pageref{structtvm_1_1detail_1_1ReflectionTrait}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ReflectionVTable}{tvm\+::\+Reflection\+V\+Table} \\*Virtual function table to support I\+R/\+A\+ST node reflection }{\pageref{classtvm_1_1ReflectionVTable}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefRead}{tvm\+::relay\+::\+Ref\+Read} }{\pageref{classtvm_1_1relay_1_1RefRead}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefReadNode}{tvm\+::relay\+::\+Ref\+Read\+Node} }{\pageref{classtvm_1_1relay_1_1RefReadNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefValue}{tvm\+::relay\+::\+Ref\+Value} }{\pageref{classtvm_1_1relay_1_1RefValue}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1RefValueObj}{tvm\+::relay\+::\+Ref\+Value\+Obj} }{\pageref{structtvm_1_1relay_1_1RefValueObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefWrite}{tvm\+::relay\+::\+Ref\+Write} }{\pageref{classtvm_1_1relay_1_1RefWrite}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RefWriteNode}{tvm\+::relay\+::\+Ref\+Write\+Node} }{\pageref{classtvm_1_1relay_1_1RefWriteNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ReflectionVTable_1_1Registry}{tvm\+::\+Reflection\+V\+Table\+::\+Registry} \\*\hyperlink{classtvm_1_1ReflectionVTable_1_1Registry}{Registry} of a reflection table }{\pageref{classtvm_1_1ReflectionVTable_1_1Registry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1Registry}{tvm\+::runtime\+::\+Registry} \\*\hyperlink{classtvm_1_1runtime_1_1Registry}{Registry} for global function }{\pageref{classtvm_1_1runtime_1_1Registry}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1RelayExpr}{tvm\+::\+Relay\+Expr} \\*Managed reference to \hyperlink{classtvm_1_1RelayExprNode}{Relay\+Expr\+Node} }{\pageref{classtvm_1_1RelayExpr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1RelayExprNode}{tvm\+::\+Relay\+Expr\+Node} \\*Base node of all non-\/primitive expressions }{\pageref{classtvm_1_1RelayExprNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1RelayNode}{tvm\+::relay\+::\+Relay\+Node} \\*This is the base node container of all relay structures }{\pageref{classtvm_1_1relay_1_1RelayNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1RelayRefType}{tvm\+::\+Relay\+Ref\+Type} \\*Managed reference to \hyperlink{classtvm_1_1RelayRefTypeNode}{Relay\+Ref\+Type\+Node} }{\pageref{classtvm_1_1RelayRefType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1RelayRefTypeNode}{tvm\+::\+Relay\+Ref\+Type\+Node} \\*Reference \hyperlink{classtvm_1_1Type}{Type} High-\/level Relay IR }{\pageref{classtvm_1_1RelayRefTypeNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1RepeatAttrs}{tvm\+::relay\+::\+Repeat\+Attrs} \\*Attributes used in repeat operators }{\pageref{structtvm_1_1relay_1_1RepeatAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1ReprPrinter}{tvm\+::\+Repr\+Printer} \\*A printer class to print the A\+S\+T/\+IR nodes }{\pageref{classtvm_1_1ReprPrinter}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1qnn_1_1RequantizeAttrs}{tvm\+::relay\+::qnn\+::\+Requantize\+Attrs} \\*Attribute for requantize operator }{\pageref{structtvm_1_1relay_1_1qnn_1_1RequantizeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ReshapeAttrs}{tvm\+::relay\+::\+Reshape\+Attrs} \\*Attributes used in reshape operators }{\pageref{structtvm_1_1relay_1_1ReshapeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ResizeAttrs}{tvm\+::relay\+::\+Resize\+Attrs} \\*Attributes used in image resize operator }{\pageref{structtvm_1_1relay_1_1ResizeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ReverseAttrs}{tvm\+::relay\+::\+Reverse\+Attrs} \\*Attributes used in reverse operators }{\pageref{structtvm_1_1relay_1_1ReverseAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1arith_1_1RewriteSimplifier}{tvm\+::arith\+::\+Rewrite\+Simplifier} \\*Rewrite-\/rule based simplifier }{\pageref{classtvm_1_1arith_1_1RewriteSimplifier}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ROIAlignAttrs}{tvm\+::relay\+::\+R\+O\+I\+Align\+Attrs} \\*Attributes used in roi\+\_\+align operators }{\pageref{structtvm_1_1relay_1_1ROIAlignAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ROIPoolAttrs}{tvm\+::relay\+::\+R\+O\+I\+Pool\+Attrs} \\*Attributes used in roi\+\_\+pool operators }{\pageref{structtvm_1_1relay_1_1ROIPoolAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1ScanOpNode}{tvm\+::te\+::\+Scan\+Op\+Node} \\*Symbolic scan }{\pageref{classtvm_1_1te_1_1ScanOpNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1Schedule}{tvm\+::te\+::\+Schedule} \\*Global schedule container For operations and all the operations they depend on. The schedule per \hyperlink{classtvm_1_1te_1_1Operation}{Operation} is named as stage }{\pageref{classtvm_1_1te_1_1Schedule}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1ScheduleNode}{tvm\+::te\+::\+Schedule\+Node} \\*Node container for schedule }{\pageref{classtvm_1_1te_1_1ScheduleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SelectNode}{tvm\+::tir\+::\+Select\+Node} \\*Return true\+\_\+value if condition is true, otherwise return false\+\_\+value }{\pageref{classtvm_1_1tir_1_1SelectNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectSEqualReduce}{tvm\+::detail\+::\+Select\+S\+Equal\+Reduce$<$ T, Trait\+Name, bool $>$} }{\pageref{structtvm_1_1detail_1_1SelectSEqualReduce}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectSEqualReduce_3_01T_00_01TraitName_00_01false_01_4}{tvm\+::detail\+::\+Select\+S\+Equal\+Reduce$<$ T, Trait\+Name, false $>$} }{\pageref{structtvm_1_1detail_1_1SelectSEqualReduce_3_01T_00_01TraitName_00_01false_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectSHashReduce}{tvm\+::detail\+::\+Select\+S\+Hash\+Reduce$<$ T, Trait\+Name, bool $>$} }{\pageref{structtvm_1_1detail_1_1SelectSHashReduce}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectSHashReduce_3_01T_00_01TraitName_00_01false_01_4}{tvm\+::detail\+::\+Select\+S\+Hash\+Reduce$<$ T, Trait\+Name, false $>$} }{\pageref{structtvm_1_1detail_1_1SelectSHashReduce_3_01T_00_01TraitName_00_01false_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectVisitAttrs}{tvm\+::detail\+::\+Select\+Visit\+Attrs$<$ T, Trait\+Name, bool $>$} }{\pageref{structtvm_1_1detail_1_1SelectVisitAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1SelectVisitAttrs_3_01T_00_01TraitName_00_01false_01_4}{tvm\+::detail\+::\+Select\+Visit\+Attrs$<$ T, Trait\+Name, false $>$} }{\pageref{structtvm_1_1detail_1_1SelectVisitAttrs_3_01T_00_01TraitName_00_01false_01_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SeqStmt}{tvm\+::tir\+::\+Seq\+Stmt} \\*Sequence statement }{\pageref{classtvm_1_1tir_1_1SeqStmt}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SeqStmtNode}{tvm\+::tir\+::\+Seq\+Stmt\+Node} \\*The container of seq statement. Represent a sequence of statements }{\pageref{classtvm_1_1tir_1_1SeqStmtNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SEqualReducer}{tvm\+::\+S\+Equal\+Reducer} \\*A Reducer class to reduce the structural equality result of two objects }{\pageref{classtvm_1_1SEqualReducer}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SequenceMaskAttrs}{tvm\+::relay\+::\+Sequence\+Mask\+Attrs} }{\pageref{structtvm_1_1relay_1_1SequenceMaskAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1transform_1_1Sequential}{tvm\+::transform\+::\+Sequential} }{\pageref{classtvm_1_1transform_1_1Sequential}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ShapeFuncAttrs}{tvm\+::relay\+::\+Shape\+Func\+Attrs} \\*Options for the shape function operator }{\pageref{structtvm_1_1relay_1_1ShapeFuncAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1ShapeOfAttrs}{tvm\+::relay\+::\+Shape\+Of\+Attrs} \\*Attributes for Shape\+Of operator }{\pageref{structtvm_1_1relay_1_1ShapeOfAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SHashReducer}{tvm\+::\+S\+Hash\+Reducer} \\*A Reducer class to reduce the structural hash value }{\pageref{classtvm_1_1SHashReducer}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1ShuffleNode}{tvm\+::tir\+::\+Shuffle\+Node} \\*Shuffle instruction. vec = concat(vectors) result = (vec\mbox{[}indices\mbox{[}0\mbox{]}\mbox{]}, vec\mbox{[}indices\mbox{[}1\mbox{]}\mbox{]} ...) }{\pageref{classtvm_1_1tir_1_1ShuffleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1SimpleObjAllocator}{tvm\+::runtime\+::\+Simple\+Obj\+Allocator} }{\pageref{classtvm_1_1runtime_1_1SimpleObjAllocator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1SingletonNode}{tvm\+::te\+::\+Singleton\+Node} \\*Singleton iterator \mbox{[}0, 1) }{\pageref{classtvm_1_1te_1_1SingletonNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SizeVar}{tvm\+::tir\+::\+Size\+Var} \\*Named variable represents a tensor index size }{\pageref{classtvm_1_1tir_1_1SizeVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SizeVarNode}{tvm\+::tir\+::\+Size\+Var\+Node} \\*A variable node represent a tensor index size, whose value must be non-\/negative }{\pageref{classtvm_1_1tir_1_1SizeVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1Tensor_1_1Slice}{tvm\+::te\+::\+Tensor\+::\+Slice} \\*Data structure to represent a slice that fixes first k coordinates. This is used to enable syntax sugar of \hyperlink{classtvm_1_1te_1_1Tensor}{Tensor}\mbox{[}x\mbox{]}\mbox{[}y\mbox{]}\mbox{[}z\mbox{]} to get the element }{\pageref{classtvm_1_1te_1_1Tensor_1_1Slice}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SliceLikeAttrs}{tvm\+::relay\+::\+Slice\+Like\+Attrs} }{\pageref{structtvm_1_1relay_1_1SliceLikeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SoftmaxAttrs}{tvm\+::relay\+::\+Softmax\+Attrs} \\*Attributes used in softmax operators }{\pageref{structtvm_1_1relay_1_1SoftmaxAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SourceName}{tvm\+::\+Source\+Name} \\*The source name of a file span }{\pageref{classtvm_1_1SourceName}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SourceNameNode}{tvm\+::\+Source\+Name\+Node} \\*The name of a source fragment }{\pageref{classtvm_1_1SourceNameNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Span}{tvm\+::\+Span} }{\pageref{classtvm_1_1Span}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1SpanNode}{tvm\+::\+Span\+Node} \\*Stores locations in frontend source that generated a node }{\pageref{classtvm_1_1SpanNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SparseDenseAttrs}{tvm\+::relay\+::\+Sparse\+Dense\+Attrs} \\*Attributes for sparse\+\_\+dense operator }{\pageref{structtvm_1_1relay_1_1SparseDenseAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SparseTransposeAttrs}{tvm\+::relay\+::\+Sparse\+Transpose\+Attrs} \\*Attributes for sparse\+\_\+transpose operator }{\pageref{structtvm_1_1relay_1_1SparseTransposeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1SpecializedCondition}{tvm\+::te\+::\+Specialized\+Condition} \\*Specialized condition to enable op specialization }{\pageref{classtvm_1_1te_1_1SpecializedCondition}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1SpecializedConditionNode}{tvm\+::te\+::\+Specialized\+Condition\+Node} \\*Container for specialization conditions }{\pageref{classtvm_1_1te_1_1SpecializedConditionNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SplitAttrs}{tvm\+::relay\+::\+Split\+Attrs} }{\pageref{structtvm_1_1relay_1_1SplitAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1SplitNode}{tvm\+::te\+::\+Split\+Node} \\*Split the parent domain into product of outer and iter }{\pageref{classtvm_1_1te_1_1SplitNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SqueezeAttrs}{tvm\+::relay\+::\+Squeeze\+Attrs} \\*Attributes used in squeeze operators }{\pageref{structtvm_1_1relay_1_1SqueezeAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1StackAttrs}{tvm\+::relay\+::\+Stack\+Attrs} \\*Attributes used in stack operators }{\pageref{structtvm_1_1relay_1_1StackAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1Stage}{tvm\+::te\+::\+Stage} \\*\hyperlink{classtvm_1_1te_1_1Stage}{Stage}, contains scheduling for a stage of computation }{\pageref{classtvm_1_1te_1_1Stage}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1StageNode}{tvm\+::te\+::\+Stage\+Node} \\*\hyperlink{classtvm_1_1te_1_1Stage}{Stage} }{\pageref{classtvm_1_1te_1_1StageNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1Stmt}{tvm\+::tir\+::\+Stmt} \\*Container of all statements }{\pageref{classtvm_1_1tir_1_1Stmt}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtExprMutator}{tvm\+::tir\+::\+Stmt\+Expr\+Mutator} \\*Mutator that recursively mutates stmts and exprs on them }{\pageref{classtvm_1_1tir_1_1StmtExprMutator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtExprVisitor}{tvm\+::tir\+::\+Stmt\+Expr\+Visitor} \\*Visitor that recursively visit stmts and exprs on them }{\pageref{classtvm_1_1tir_1_1StmtExprVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtFunctor}{tvm\+::tir\+::\+Stmt\+Functor$<$ F\+Type $>$} \\*Same as \hyperlink{classtvm_1_1tir_1_1ExprFunctor}{Expr\+Functor} except it is applied on statements }{\pageref{classtvm_1_1tir_1_1StmtFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4}{tvm\+::tir\+::\+Stmt\+Functor$<$ R(const Stmt \&n, Args...\+args)$>$} }{\pageref{classtvm_1_1tir_1_1StmtFunctor_3_01R_07const_01Stmt_01_6n_00_01Args_8_8_8args_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtMutator}{tvm\+::tir\+::\+Stmt\+Mutator} \\*\hyperlink{classtvm_1_1tir_1_1StmtMutator}{Stmt\+Mutator} that mutates the statements }{\pageref{classtvm_1_1tir_1_1StmtMutator}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtNode}{tvm\+::tir\+::\+Stmt\+Node} \\*Base node of all statements }{\pageref{classtvm_1_1tir_1_1StmtNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StmtVisitor}{tvm\+::tir\+::\+Stmt\+Visitor} \\*\hyperlink{classtvm_1_1tir_1_1StmtVisitor}{Stmt\+Visitor} }{\pageref{classtvm_1_1tir_1_1StmtVisitor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StoreNode}{tvm\+::tir\+::\+Store\+Node} \\*Store value to the buffer }{\pageref{classtvm_1_1tir_1_1StoreNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1StridedSliceAttrs}{tvm\+::relay\+::\+Strided\+Slice\+Attrs} \\*Attributes for Strided\+Slice operator }{\pageref{structtvm_1_1relay_1_1StridedSliceAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1String}{tvm\+::runtime\+::\+String} \\*Reference to string objects }{\pageref{classtvm_1_1runtime_1_1String}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StringImm}{tvm\+::tir\+::\+String\+Imm} }{\pageref{classtvm_1_1tir_1_1StringImm}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1StringImmNode}{tvm\+::tir\+::\+String\+Imm\+Node} \\*String constants, only used in asserts }{\pageref{classtvm_1_1tir_1_1StringImmNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1StringObj}{tvm\+::runtime\+::\+String\+Obj} \\*An object representing string. It\textquotesingle{}s P\+OD type }{\pageref{classtvm_1_1runtime_1_1StringObj}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1StrMapNode}{tvm\+::\+Str\+Map\+Node} \\*Specialized map node with string as key }{\pageref{classtvm_1_1StrMapNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1StructuralEqual}{tvm\+::\+Structural\+Equal} \\*Content-\/aware structural equality comparator for objects }{\pageref{classtvm_1_1StructuralEqual}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1StructuralHash}{tvm\+::\+Structural\+Hash} \\*Content-\/aware structural hasing }{\pageref{classtvm_1_1StructuralHash}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1StructuralHash}{tvm\+::relay\+::\+Structural\+Hash} \\*A hashing structure in the style of std\+::hash }{\pageref{structtvm_1_1relay_1_1StructuralHash}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1SubNode}{tvm\+::tir\+::\+Sub\+Node} \\*
\begin{DoxyItemize}
\item b 
\end{DoxyItemize}}{\pageref{classtvm_1_1tir_1_1SubNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1SubPixelAttrs}{tvm\+::relay\+::\+Sub\+Pixel\+Attrs} \\*Attributes used in subpixel operators }{\pageref{structtvm_1_1relay_1_1SubPixelAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1TakeAttrs}{tvm\+::relay\+::\+Take\+Attrs} }{\pageref{structtvm_1_1relay_1_1TakeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Target}{tvm\+::\+Target} \\*Managed reference class to \hyperlink{classtvm_1_1TargetNode}{Target\+Node} }{\pageref{classtvm_1_1Target}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TargetNode}{tvm\+::\+Target\+Node} \\*Compilation target }{\pageref{classtvm_1_1TargetNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1TempExpr}{tvm\+::relay\+::\+Temp\+Expr} }{\pageref{classtvm_1_1relay_1_1TempExpr}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1TempExprNode}{tvm\+::relay\+::\+Temp\+Expr\+Node} \\*Base class of the temporary expression }{\pageref{classtvm_1_1relay_1_1TempExprNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1Tensor}{tvm\+::te\+::\+Tensor} \\*\hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} structure representing a possible input, or intermediate computation result }{\pageref{classtvm_1_1te_1_1Tensor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorComputeOpNode}{tvm\+::te\+::\+Tensor\+Compute\+Op\+Node} \\*A Tenor\+Compute op that compute a tensor with an tensor intrinsic }{\pageref{classtvm_1_1te_1_1TensorComputeOpNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1te_1_1TensorDom}{tvm\+::te\+::\+Tensor\+Dom} \\*Temporary data structure to store union of bounds of each axis of \hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} }{\pageref{structtvm_1_1te_1_1TensorDom}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorIntrin}{tvm\+::te\+::\+Tensor\+Intrin} \\*\hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} intrinsic node }{\pageref{classtvm_1_1te_1_1TensorIntrin}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorIntrinCall}{tvm\+::te\+::\+Tensor\+Intrin\+Call} \\*\hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} intrinsic calling node }{\pageref{classtvm_1_1te_1_1TensorIntrinCall}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorIntrinCallNode}{tvm\+::te\+::\+Tensor\+Intrin\+Call\+Node} }{\pageref{classtvm_1_1te_1_1TensorIntrinCallNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorIntrinNode}{tvm\+::te\+::\+Tensor\+Intrin\+Node} \\*Node to represent a \hyperlink{classtvm_1_1te_1_1Tensor}{Tensor} intrinsic operator }{\pageref{classtvm_1_1te_1_1TensorIntrinNode}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1tir_1_1TensorKey}{tvm\+::tir\+::\+Tensor\+Key} \\*Auxiliary data structure used in IR Pass to indicate a tensor }{\pageref{structtvm_1_1tir_1_1TensorKey}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1te_1_1TensorNode}{tvm\+::te\+::\+Tensor\+Node} \\*Node to represent a tensor }{\pageref{classtvm_1_1te_1_1TensorNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TensorType}{tvm\+::\+Tensor\+Type} \\*Managed reference to \hyperlink{classtvm_1_1TensorTypeNode}{Tensor\+Type\+Node} }{\pageref{classtvm_1_1TensorType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TensorTypeNode}{tvm\+::\+Tensor\+Type\+Node} \\*This is the most commonly used type in relay. \hyperlink{classtvm_1_1TensorType}{Tensor\+Type} have a fixed dimension, data type }{\pageref{classtvm_1_1TensorTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1threading_1_1ThreadGroup}{tvm\+::runtime\+::threading\+::\+Thread\+Group} \\*A platform-\/agnostic abstraction for managing a collection of thread pool threads }{\pageref{classtvm_1_1runtime_1_1threading_1_1ThreadGroup}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1TileAttrs}{tvm\+::relay\+::\+Tile\+Attrs} \\*Attributes used in tile operators }{\pageref{structtvm_1_1relay_1_1TileAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1TopKAttrs}{tvm\+::relay\+::\+Top\+K\+Attrs} }{\pageref{structtvm_1_1relay_1_1TopKAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1TransposeAttrs}{tvm\+::relay\+::\+Transpose\+Attrs} \\*Attributes used in transpose operators }{\pageref{structtvm_1_1relay_1_1TransposeAttrs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Tuple}{tvm\+::relay\+::\+Tuple} }{\pageref{classtvm_1_1relay_1_1Tuple}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1TupleGetItem}{tvm\+::relay\+::\+Tuple\+Get\+Item} }{\pageref{classtvm_1_1relay_1_1TupleGetItem}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1TupleGetItemNode}{tvm\+::relay\+::\+Tuple\+Get\+Item\+Node} }{\pageref{classtvm_1_1relay_1_1TupleGetItemNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1TupleNode}{tvm\+::relay\+::\+Tuple\+Node} \\*\hyperlink{classtvm_1_1relay_1_1Tuple}{Tuple} container }{\pageref{classtvm_1_1relay_1_1TupleNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TupleType}{tvm\+::\+Tuple\+Type} \\*Managed reference to \hyperlink{classtvm_1_1TupleTypeNode}{Tuple\+Type\+Node} }{\pageref{classtvm_1_1TupleType}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TupleTypeNode}{tvm\+::\+Tuple\+Type\+Node} \\*The type of tuple values }{\pageref{classtvm_1_1TupleTypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TVMArgs}{tvm\+::runtime\+::\+T\+V\+M\+Args} \\*Arguments into T\+VM functions }{\pageref{classtvm_1_1runtime_1_1TVMArgs}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TVMArgsSetter}{tvm\+::runtime\+::\+T\+V\+M\+Args\+Setter} }{\pageref{classtvm_1_1runtime_1_1TVMArgsSetter}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TVMArgValue}{tvm\+::runtime\+::\+T\+V\+M\+Arg\+Value} \\*A single argument value to \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func}. Containing both type\+\_\+code and \hyperlink{unionTVMValue}{T\+V\+M\+Value} }{\pageref{classtvm_1_1runtime_1_1TVMArgValue}}{}
\item\contentsline{section}{\hyperlink{structTVMByteArray}{T\+V\+M\+Byte\+Array} \\*Byte array type used to pass in byte array When k\+T\+V\+M\+Bytes is used as data type }{\pageref{structTVMByteArray}}{}
\item\contentsline{section}{\hyperlink{structTVMParallelGroupEnv}{T\+V\+M\+Parallel\+Group\+Env} \\*Environment for T\+VM parallel task }{\pageref{structTVMParallelGroupEnv}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TVMPODValue__}{tvm\+::runtime\+::\+T\+V\+M\+P\+O\+D\+Value\+\_\+} \\*Internal base class to handle conversion to P\+OD values }{\pageref{classtvm_1_1runtime_1_1TVMPODValue__}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TVMRetValue}{tvm\+::runtime\+::\+T\+V\+M\+Ret\+Value} \\*Return Value container, Unlike \hyperlink{classtvm_1_1runtime_1_1TVMArgValue}{T\+V\+M\+Arg\+Value}, which only holds reference and do not delete the underlying container during destruction }{\pageref{classtvm_1_1runtime_1_1TVMRetValue}}{}
\item\contentsline{section}{\hyperlink{unionTVMValue}{T\+V\+M\+Value} \\*Union type of values being passed through A\+PI and function calls }{\pageref{unionTVMValue}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1Type}{tvm\+::\+Type} \\*Managed reference to \hyperlink{classtvm_1_1TypeNode}{Type\+Node} }{\pageref{classtvm_1_1Type}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeCall}{tvm\+::\+Type\+Call} \\*Managed reference to \hyperlink{classtvm_1_1TypeCallNode}{Type\+Call\+Node} }{\pageref{classtvm_1_1TypeCall}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeCallNode}{tvm\+::\+Type\+Call\+Node} \\*\hyperlink{classtvm_1_1Type}{Type} function application }{\pageref{classtvm_1_1TypeCallNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeConstraint}{tvm\+::\+Type\+Constraint} \\*Managed reference to \hyperlink{classtvm_1_1TypeConstraintNode}{Type\+Constraint\+Node} }{\pageref{classtvm_1_1TypeConstraint}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeConstraintNode}{tvm\+::\+Type\+Constraint\+Node} \\*Potential Constraints in a function }{\pageref{classtvm_1_1TypeConstraintNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeData}{tvm\+::\+Type\+Data} \\*Stores all data for an Algebraic Data \hyperlink{classtvm_1_1Type}{Type} (A\+DT) }{\pageref{classtvm_1_1TypeData}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeDataNode}{tvm\+::\+Type\+Data\+Node} \\*\hyperlink{classtvm_1_1TypeData}{Type\+Data} container node }{\pageref{classtvm_1_1TypeDataNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypedEnvFunc}{tvm\+::\+Typed\+Env\+Func$<$ F\+Type $>$} \\*Please refer to \hyperlink{classtvm_1_1TypedEnvFunc_3_01R_07Args_8_8_8_08_4_TypedEnvFuncAnchor}{Typed\+Env\+Func$<$R(Args..)$>$} }{\pageref{classtvm_1_1TypedEnvFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypedEnvFunc_3_01R_07Args_8_8_8_08_4}{tvm\+::\+Typed\+Env\+Func$<$ R(\+Args...)$>$} \\*A typed version of \hyperlink{classtvm_1_1EnvFunc}{Env\+Func}. It is backed by a Global\+Func\+Node internally }{\pageref{classtvm_1_1TypedEnvFunc_3_01R_07Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc}{tvm\+::runtime\+::\+Typed\+Packed\+Func$<$ F\+Type $>$} \\*Please refer to \hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4_TypedPackedFuncAnchor}{Typed\+Packed\+Func$<$R(Args..)$>$} }{\pageref{classtvm_1_1runtime_1_1TypedPackedFunc}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4}{tvm\+::runtime\+::\+Typed\+Packed\+Func$<$ R(\+Args...)$>$} \\*A \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} wrapper to provide typed function signature. It is backed by a \hyperlink{classtvm_1_1runtime_1_1PackedFunc}{Packed\+Func} internally }{\pageref{classtvm_1_1runtime_1_1TypedPackedFunc_3_01R_07Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeFunctor}{tvm\+::\+Type\+Functor$<$ F\+Type $>$} }{\pageref{classtvm_1_1TypeFunctor}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeFunctor_3_01R_07const_01Type_01_6n_00_01Args_8_8_8_08_4}{tvm\+::\+Type\+Functor$<$ R(const Type \&n, Args...)$>$} }{\pageref{classtvm_1_1TypeFunctor_3_01R_07const_01Type_01_6n_00_01Args_8_8_8_08_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeMutator}{tvm\+::\+Type\+Mutator} \\*\hyperlink{classtvm_1_1TypeMutator}{Type\+Mutator} that mutates expressions }{\pageref{classtvm_1_1TypeMutator}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName}{tvm\+::detail\+::\+Type\+Name$<$ T $>$} \\*Helper struct to get the type name known to tvm }{\pageref{structtvm_1_1detail_1_1TypeName}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01bool_01_4}{tvm\+::detail\+::\+Type\+Name$<$ bool $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01bool_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01DataType_01_4}{tvm\+::detail\+::\+Type\+Name$<$ Data\+Type $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01DataType_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01double_01_4}{tvm\+::detail\+::\+Type\+Name$<$ double $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01double_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01int_01_4}{tvm\+::detail\+::\+Type\+Name$<$ int $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01int_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01int64__t_01_4}{tvm\+::detail\+::\+Type\+Name$<$ int64\+\_\+t $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01int64__t_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01uint64__t_01_4}{tvm\+::detail\+::\+Type\+Name$<$ uint64\+\_\+t $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01uint64__t_01_4}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1detail_1_1TypeName_3_01void_01_5_01_4}{tvm\+::detail\+::\+Type\+Name$<$ void $\ast$ $>$} }{\pageref{structtvm_1_1detail_1_1TypeName_3_01void_01_5_01_4}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeNode}{tvm\+::\+Type\+Node} \\*\hyperlink{classtvm_1_1Type}{Type} is the base type of all types }{\pageref{classtvm_1_1TypeNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeRelation}{tvm\+::\+Type\+Relation} \\*Managed reference to \hyperlink{classtvm_1_1TypeRelationNode}{Type\+Relation\+Node} }{\pageref{classtvm_1_1TypeRelation}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeRelationNode}{tvm\+::\+Type\+Relation\+Node} \\*User defined type relation, it is an input-\/output relation on types }{\pageref{classtvm_1_1TypeRelationNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeReporter}{tvm\+::\+Type\+Reporter} \\*Container class of \hyperlink{classtvm_1_1TypeReporter}{Type\+Reporter} }{\pageref{classtvm_1_1TypeReporter}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeReporterNode}{tvm\+::\+Type\+Reporter\+Node} \\*Reporter that reports back to the type resolution information }{\pageref{classtvm_1_1TypeReporterNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeVar}{tvm\+::\+Type\+Var} \\*Managed reference to \hyperlink{classtvm_1_1TypeVarNode}{Type\+Var\+Node} }{\pageref{classtvm_1_1TypeVar}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeVarNode}{tvm\+::\+Type\+Var\+Node} \\*\hyperlink{classtvm_1_1Type}{Type} parameter in functions }{\pageref{classtvm_1_1TypeVarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1TypeVisitor}{tvm\+::\+Type\+Visitor} \\*A type visitor that recursively visit types }{\pageref{classtvm_1_1TypeVisitor}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1UpSampling3DAttrs}{tvm\+::relay\+::\+Up\+Sampling3\+D\+Attrs} \\*Attributes for upsampling3d operator }{\pageref{structtvm_1_1relay_1_1UpSampling3DAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1UpSamplingAttrs}{tvm\+::relay\+::\+Up\+Sampling\+Attrs} \\*Attributes for upsampling operator }{\pageref{structtvm_1_1relay_1_1UpSamplingAttrs}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1Map_1_1ValueConverter}{tvm\+::\+Map$<$ K, V, typename, typename $>$\+::\+Value\+Converter} }{\pageref{structtvm_1_1Map_1_1ValueConverter}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1Array_1_1ValueConverter}{tvm\+::\+Array$<$ T, typename $>$\+::\+Value\+Converter} }{\pageref{structtvm_1_1Array_1_1ValueConverter}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1Var}{tvm\+::tir\+::\+Var} \\*Named variable in T\+VM }{\pageref{classtvm_1_1tir_1_1Var}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1Var}{tvm\+::relay\+::\+Var} }{\pageref{classtvm_1_1relay_1_1Var}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1relay_1_1VarNode}{tvm\+::relay\+::\+Var\+Node} \\*Container for \hyperlink{classtvm_1_1relay_1_1Var}{Var} }{\pageref{classtvm_1_1relay_1_1VarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1tir_1_1VarNode}{tvm\+::tir\+::\+Var\+Node} \\*A variable node in the IR }{\pageref{classtvm_1_1tir_1_1VarNode}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1VirtualMachine}{tvm\+::runtime\+::vm\+::\+Virtual\+Machine} \\*The virtual machine }{\pageref{classtvm_1_1runtime_1_1vm_1_1VirtualMachine}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1VMClosure}{tvm\+::runtime\+::vm\+::\+V\+M\+Closure} \\*Reference to closure }{\pageref{classtvm_1_1runtime_1_1vm_1_1VMClosure}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1runtime_1_1vm_1_1VMClosureObj}{tvm\+::runtime\+::vm\+::\+V\+M\+Closure\+Obj} \\*An object representing a vm closure }{\pageref{classtvm_1_1runtime_1_1vm_1_1VMClosureObj}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1vm_1_1VMFrame}{tvm\+::runtime\+::vm\+::\+V\+M\+Frame} \\*A representation of a stack frame }{\pageref{structtvm_1_1runtime_1_1vm_1_1VMFrame}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1runtime_1_1vm_1_1VMFunction}{tvm\+::runtime\+::vm\+::\+V\+M\+Function} \\*A representation of a Relay function in the VM }{\pageref{structtvm_1_1runtime_1_1vm_1_1VMFunction}}{}
\item\contentsline{section}{\hyperlink{classtvm_1_1With}{tvm\+::\+With$<$ Context\+Type $>$} \\*R\+A\+II wrapper function to enter and exit a context object similar to python\textquotesingle{}s with syntax }{\pageref{classtvm_1_1With}}{}
\item\contentsline{section}{\hyperlink{structtvm_1_1relay_1_1YoloReorgAttrs}{tvm\+::relay\+::\+Yolo\+Reorg\+Attrs} \\*Attributes used in yolo reorg operators }{\pageref{structtvm_1_1relay_1_1YoloReorgAttrs}}{}
\end{DoxyCompactList}
