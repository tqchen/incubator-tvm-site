\hypertarget{namespacetvm_1_1tir_1_1attr}{}\section{tvm\+:\+:tir\+:\+:attr Namespace Reference}
\label{namespacetvm_1_1tir_1_1attr}\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}


\hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func} specific attribute names.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{namespacetvm_1_1tir_1_1attr_a385e883a7cecc309d063786e5fdf2c4b}{Is\+Pragma\+Key} (const std\+::string \&attr\+\_\+key)
\begin{DoxyCompactList}\small\item\em Check if attr\+\_\+key is a pragma key extension. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a4933845b75cf4f08fb66f55fdd94986f}{k\+Device\+Thread\+Axis} = \char`\"{}tir.\+device\+\_\+thread\+\_\+axis\char`\"{}
\begin{DoxyCompactList}\small\item\em List of thread \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} that a Device\+Launch function corresponds to. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ac74386674da85bc4b4dd1ee28a97ff63}{k\+No\+Alias} = \char`\"{}tir.\+noalias\char`\"{}
\begin{DoxyCompactList}\small\item\em Whether to set noalias rule on the function arguments. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a489d0cebd2820025bc3d6c5a9011cdd4}{k\+Is\+Entry\+Func} = \char`\"{}tir.\+is\+\_\+entry\+\_\+func\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark the function as the entry function of the final generated runtime module. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a399eed804ecc482a607f0f65f07b78dd}{thread\+\_\+extent} = \char`\"{}thread\+\_\+extent\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark launching extent of thread, used by device A\+PI. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a464533c1560ace5e0b5071ba6902482e}{virtual\+\_\+thread} = \char`\"{}virtual\+\_\+thread\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark launching of a virtual thread. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ac62a341bfebe5448f290aa54b0f84cac}{coproc\+\_\+scope} = \char`\"{}coproc\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark region is processed by a co-\/proccesor. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ae1d3379e8d6486e79853e254ea9a724e}{coproc\+\_\+uop\+\_\+scope} = \char`\"{}coproc\+\_\+uop\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a14c2370f3a08792a6aaf70d7a3c773e4}{volatile\+\_\+scope} = \char`\"{}volatile\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark the scope as volatile access for certain handle. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a4bd38b620e1e9907216f3e583839dea3}{extern\+\_\+scope} = \char`\"{}extern\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a00a6b89838348f152d844cead81b5016}{compute\+\_\+scope} = \char`\"{}compute\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a04f015503117e6b781ade61e103b074a}{storage\+\_\+scope} = \char`\"{}storage\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark storage scope of buffers. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_af27d464f2065dc5f77408df7b94d4bb6}{storage\+\_\+alignment} = \char`\"{}storage\+\_\+alignment\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark storage alignement requirement of buffers. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_acf70bbdafa7344811d336422bf95cdc5}{realize\+\_\+scope} = \char`\"{}realize\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark storage scope of realization. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a5f3aac4e433fcd6d93f8982540960263}{device\+\_\+context\+\_\+id} = \char`\"{}device\+\_\+context\+\_\+id\char`\"{}
\begin{DoxyCompactList}\small\item\em The allocation context for global malloc in host. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a9e64432b8b1b9323c5ad18957ba88b23}{device\+\_\+context\+\_\+type} = \char`\"{}device\+\_\+context\+\_\+type\char`\"{}
\begin{DoxyCompactList}\small\item\em The device type. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a9125ab905a93924ee79269aa808ed517}{loop\+\_\+scope} = \char`\"{}loop\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark of loop scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a50fc9633b9cfbcefa2393dbb2ece1846}{reduce\+\_\+scope} = \char`\"{}reduce\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark of reduce scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_af08d3d2b645a914f1a64d81e45f3b86a}{pragma\+\_\+scope\+\_\+prefix} = \char`\"{}pragma\+\_\+\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark region is guarded by the pragma extension. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_af00ba402645b1def7c543af3c48be80d}{pragma\+\_\+import\+\_\+llvm} = \char`\"{}pragma\+\_\+import\+\_\+llvm\char`\"{}
\begin{DoxyCompactList}\small\item\em Import llvm source or file into the final code gen module. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a96774004fd5b6411f6c37b8923b71834}{pragma\+\_\+tensor\+\_\+core} = \char`\"{}pragma\+\_\+tensor\+\_\+core\char`\"{}
\begin{DoxyCompactList}\small\item\em Try to modify the A\+ST to support Tensor Core. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ac95fbd1c09a60b10c7a5d07f6c4b68a6}{prefetch\+\_\+scope} = \char`\"{}prefetch\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a9231fc0afe37a8d46a90a1c5fdf522bb}{double\+\_\+buffer\+\_\+scope} = \char`\"{}double\+\_\+buffer\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Marks production of double buffer data. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_af84871a6d841168f8501f141676dfaeb}{double\+\_\+buffer\+\_\+write} = \char`\"{}double\+\_\+buffer\+\_\+write\char`\"{}
\begin{DoxyCompactList}\small\item\em Marks region used by double buffer write. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a84f5d42e968fd8f4cdd7a4aac7ba2137}{scan\+\_\+update\+\_\+scope} = \char`\"{}scan\+\_\+update\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark of scan update scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_af18e3a9ba11d436e02b55e420647b22b}{scan\+\_\+init\+\_\+scope} = \char`\"{}scan\+\_\+init\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark of scan init scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a0ff3c4642eebe20842b1c26e98288a5d}{buffer\+\_\+dim\+\_\+align} = \char`\"{}buffer\+\_\+dim\+\_\+align\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark alignment of buffer dimension stmt.\+node is Tensor stmt.\+value is tvm\+\_\+tuple(dim, align, offset) This gives hint to require stride of dim to be k $\ast$ align + offset. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ac76fd8d0227265617e2f2bb8402d1e19}{buffer\+\_\+bound} = \char`\"{}buffer\+\_\+bound\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark stores/loads with theirs bounds. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a0497d7cff1d672920c2fbd4d92869e62}{buffer\+\_\+bind\+\_\+scope} = \char`\"{}buffer\+\_\+bind\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Bind the buffer specification to the region of the op When this scope occurs, the stmt.\+node is a Array$<$\+Node\+Ref$>$ = \mbox{[}buffer, tensor\mbox{]} stmt.\+value is a tvm\+\_\+tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ad39d05bd13aeed7af51e9f8e323d263b}{channel\+\_\+read\+\_\+scope} = \char`\"{}channel\+\_\+read\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em channel read scope \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a14632ed9597f1c21a0dbd23949e5916e}{channel\+\_\+read\+\_\+advance} = \char`\"{}channel\+\_\+read\+\_\+advance\char`\"{}
\begin{DoxyCompactList}\small\item\em Advance step of channel after end of scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a52f378fc437bd4f7f6508c8e2e9b3e05}{channel\+\_\+write\+\_\+scope} = \char`\"{}channel\+\_\+write\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em channel write scope \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ad8886f0bca07d9fa56db9edea67b1a8d}{channel\+\_\+write\+\_\+advance} = \char`\"{}channel\+\_\+write\+\_\+advance\char`\"{}
\begin{DoxyCompactList}\small\item\em Advance step of channel after end of scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a19ecbf068afc115a2282e533c0fe518d}{pipeline\+\_\+stage\+\_\+scope} = \char`\"{}pipeline\+\_\+stage\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em pipeline stage scope, implies always execution \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_aee14d4d24b86179fd19938a02bc15512}{pipeline\+\_\+exec\+\_\+scope} = \char`\"{}pipeline\+\_\+exec\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em pipeline execution scope, implies the scope can be pipelined. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_ae486f902462321bf26244a9c5b19098c}{opengl\+\_\+stage\+\_\+scope} = \char`\"{}opengl\+\_\+stage\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark that this stage is an Open\+GL shader. Since Open\+GL shader only allows writing out to one element of the output texture, the Provide node gets translated to a special Call\+::glsl\+\_\+texture\+\_\+store statement instead of a Store statement. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a36db026f638ad3d951c302796ddcae24}{device\+\_\+scope} = \char`\"{}device\+\_\+scope\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark that it is in the device scope. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a93d76d80fd7252d66991dc650693c0ef}{fragment\+\_\+shape} = \char`\"{}fragment\+\_\+shape\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark that the shape of Tensor\+Core fragment. \end{DoxyCompactList}\item 
constexpr const char $\ast$ \hyperlink{namespacetvm_1_1tir_1_1attr_a9b33cc65f756817e691b49782ee103bd}{fragment\+\_\+layout} = \char`\"{}fragment\+\_\+layout\char`\"{}
\begin{DoxyCompactList}\small\item\em Mark that the layout of Tensor\+Core fragment. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{classtvm_1_1tir_1_1PrimFunc}{Prim\+Func} specific attribute names. 

namespace of possible attribute sin Attr\+Stmt.\+attr\+\_\+key

\begin{DoxySeeAlso}{See also}
\hyperlink{namespacetvm_1_1attr}{tvm\+::attr} 
\end{DoxySeeAlso}


\subsection{Function Documentation}
\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!Is\+Pragma\+Key@{Is\+Pragma\+Key}}
\index{Is\+Pragma\+Key@{Is\+Pragma\+Key}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{Is\+Pragma\+Key(const std\+::string \&attr\+\_\+key)}{IsPragmaKey(const std::string &attr_key)}}]{\setlength{\rightskip}{0pt plus 5cm}bool tvm\+::tir\+::attr\+::\+Is\+Pragma\+Key (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{attr\+\_\+key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacetvm_1_1tir_1_1attr_a385e883a7cecc309d063786e5fdf2c4b}{}\label{namespacetvm_1_1tir_1_1attr_a385e883a7cecc309d063786e5fdf2c4b}


Check if attr\+\_\+key is a pragma key extension. 


\begin{DoxyParams}{Parameters}
{\em attr\+\_\+key} & The attr key to be compared \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if it is a pragma key 
\end{DoxyReturn}


\subsection{Variable Documentation}
\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!buffer\+\_\+bind\+\_\+scope@{buffer\+\_\+bind\+\_\+scope}}
\index{buffer\+\_\+bind\+\_\+scope@{buffer\+\_\+bind\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{buffer\+\_\+bind\+\_\+scope}{buffer_bind_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::buffer\+\_\+bind\+\_\+scope = \char`\"{}buffer\+\_\+bind\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a0497d7cff1d672920c2fbd4d92869e62}{}\label{namespacetvm_1_1tir_1_1attr_a0497d7cff1d672920c2fbd4d92869e62}


Bind the buffer specification to the region of the op When this scope occurs, the stmt.\+node is a Array$<$\+Node\+Ref$>$ = \mbox{[}buffer, tensor\mbox{]} stmt.\+value is a tvm\+\_\+tuple(min0, extent0, min1, extent1, ...). The scope represents that we need to bind the storage region of tensor to buffer. This will affect replacement of some variables inside the scope that corresponds to field of buffer to be the actual expressions of tensor during storage flattening phase. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!buffer\+\_\+bound@{buffer\+\_\+bound}}
\index{buffer\+\_\+bound@{buffer\+\_\+bound}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{buffer\+\_\+bound}{buffer_bound}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::buffer\+\_\+bound = \char`\"{}buffer\+\_\+bound\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ac76fd8d0227265617e2f2bb8402d1e19}{}\label{namespacetvm_1_1tir_1_1attr_ac76fd8d0227265617e2f2bb8402d1e19}


Mark stores/loads with theirs bounds. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!buffer\+\_\+dim\+\_\+align@{buffer\+\_\+dim\+\_\+align}}
\index{buffer\+\_\+dim\+\_\+align@{buffer\+\_\+dim\+\_\+align}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{buffer\+\_\+dim\+\_\+align}{buffer_dim_align}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::buffer\+\_\+dim\+\_\+align = \char`\"{}buffer\+\_\+dim\+\_\+align\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a0ff3c4642eebe20842b1c26e98288a5d}{}\label{namespacetvm_1_1tir_1_1attr_a0ff3c4642eebe20842b1c26e98288a5d}


Mark alignment of buffer dimension stmt.\+node is Tensor stmt.\+value is tvm\+\_\+tuple(dim, align, offset) This gives hint to require stride of dim to be k $\ast$ align + offset. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!channel\+\_\+read\+\_\+advance@{channel\+\_\+read\+\_\+advance}}
\index{channel\+\_\+read\+\_\+advance@{channel\+\_\+read\+\_\+advance}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{channel\+\_\+read\+\_\+advance}{channel_read_advance}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::channel\+\_\+read\+\_\+advance = \char`\"{}channel\+\_\+read\+\_\+advance\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a14632ed9597f1c21a0dbd23949e5916e}{}\label{namespacetvm_1_1tir_1_1attr_a14632ed9597f1c21a0dbd23949e5916e}


Advance step of channel after end of scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!channel\+\_\+read\+\_\+scope@{channel\+\_\+read\+\_\+scope}}
\index{channel\+\_\+read\+\_\+scope@{channel\+\_\+read\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{channel\+\_\+read\+\_\+scope}{channel_read_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::channel\+\_\+read\+\_\+scope = \char`\"{}channel\+\_\+read\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ad39d05bd13aeed7af51e9f8e323d263b}{}\label{namespacetvm_1_1tir_1_1attr_ad39d05bd13aeed7af51e9f8e323d263b}


channel read scope 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!channel\+\_\+write\+\_\+advance@{channel\+\_\+write\+\_\+advance}}
\index{channel\+\_\+write\+\_\+advance@{channel\+\_\+write\+\_\+advance}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{channel\+\_\+write\+\_\+advance}{channel_write_advance}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::channel\+\_\+write\+\_\+advance = \char`\"{}channel\+\_\+write\+\_\+advance\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ad8886f0bca07d9fa56db9edea67b1a8d}{}\label{namespacetvm_1_1tir_1_1attr_ad8886f0bca07d9fa56db9edea67b1a8d}


Advance step of channel after end of scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!channel\+\_\+write\+\_\+scope@{channel\+\_\+write\+\_\+scope}}
\index{channel\+\_\+write\+\_\+scope@{channel\+\_\+write\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{channel\+\_\+write\+\_\+scope}{channel_write_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::channel\+\_\+write\+\_\+scope = \char`\"{}channel\+\_\+write\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a52f378fc437bd4f7f6508c8e2e9b3e05}{}\label{namespacetvm_1_1tir_1_1attr_a52f378fc437bd4f7f6508c8e2e9b3e05}


channel write scope 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!compute\+\_\+scope@{compute\+\_\+scope}}
\index{compute\+\_\+scope@{compute\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{compute\+\_\+scope}{compute_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::compute\+\_\+scope = \char`\"{}compute\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a00a6b89838348f152d844cead81b5016}{}\label{namespacetvm_1_1tir_1_1attr_a00a6b89838348f152d844cead81b5016}


Mark the scope as when computation start to happen This can hint some code generator to create a new function for compute. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!coproc\+\_\+scope@{coproc\+\_\+scope}}
\index{coproc\+\_\+scope@{coproc\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{coproc\+\_\+scope}{coproc_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::coproc\+\_\+scope = \char`\"{}coproc\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ac62a341bfebe5448f290aa54b0f84cac}{}\label{namespacetvm_1_1tir_1_1attr_ac62a341bfebe5448f290aa54b0f84cac}


Mark region is processed by a co-\/proccesor. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!coproc\+\_\+uop\+\_\+scope@{coproc\+\_\+uop\+\_\+scope}}
\index{coproc\+\_\+uop\+\_\+scope@{coproc\+\_\+uop\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{coproc\+\_\+uop\+\_\+scope}{coproc_uop_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::coproc\+\_\+uop\+\_\+scope = \char`\"{}coproc\+\_\+uop\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ae1d3379e8d6486e79853e254ea9a724e}{}\label{namespacetvm_1_1tir_1_1attr_ae1d3379e8d6486e79853e254ea9a724e}


Mark region creates coprocessor micro ops, can be reused if corresponding variable is independent. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!device\+\_\+context\+\_\+id@{device\+\_\+context\+\_\+id}}
\index{device\+\_\+context\+\_\+id@{device\+\_\+context\+\_\+id}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{device\+\_\+context\+\_\+id}{device_context_id}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::device\+\_\+context\+\_\+id = \char`\"{}device\+\_\+context\+\_\+id\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a5f3aac4e433fcd6d93f8982540960263}{}\label{namespacetvm_1_1tir_1_1attr_a5f3aac4e433fcd6d93f8982540960263}


The allocation context for global malloc in host. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!device\+\_\+context\+\_\+type@{device\+\_\+context\+\_\+type}}
\index{device\+\_\+context\+\_\+type@{device\+\_\+context\+\_\+type}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{device\+\_\+context\+\_\+type}{device_context_type}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::device\+\_\+context\+\_\+type = \char`\"{}device\+\_\+context\+\_\+type\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a9e64432b8b1b9323c5ad18957ba88b23}{}\label{namespacetvm_1_1tir_1_1attr_a9e64432b8b1b9323c5ad18957ba88b23}


The device type. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!device\+\_\+scope@{device\+\_\+scope}}
\index{device\+\_\+scope@{device\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{device\+\_\+scope}{device_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::device\+\_\+scope = \char`\"{}device\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a36db026f638ad3d951c302796ddcae24}{}\label{namespacetvm_1_1tir_1_1attr_a36db026f638ad3d951c302796ddcae24}


Mark that it is in the device scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!double\+\_\+buffer\+\_\+scope@{double\+\_\+buffer\+\_\+scope}}
\index{double\+\_\+buffer\+\_\+scope@{double\+\_\+buffer\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{double\+\_\+buffer\+\_\+scope}{double_buffer_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::double\+\_\+buffer\+\_\+scope = \char`\"{}double\+\_\+buffer\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a9231fc0afe37a8d46a90a1c5fdf522bb}{}\label{namespacetvm_1_1tir_1_1attr_a9231fc0afe37a8d46a90a1c5fdf522bb}


Marks production of double buffer data. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!double\+\_\+buffer\+\_\+write@{double\+\_\+buffer\+\_\+write}}
\index{double\+\_\+buffer\+\_\+write@{double\+\_\+buffer\+\_\+write}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{double\+\_\+buffer\+\_\+write}{double_buffer_write}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::double\+\_\+buffer\+\_\+write = \char`\"{}double\+\_\+buffer\+\_\+write\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_af84871a6d841168f8501f141676dfaeb}{}\label{namespacetvm_1_1tir_1_1attr_af84871a6d841168f8501f141676dfaeb}


Marks region used by double buffer write. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!extern\+\_\+scope@{extern\+\_\+scope}}
\index{extern\+\_\+scope@{extern\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{extern\+\_\+scope}{extern_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::extern\+\_\+scope = \char`\"{}extern\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a4bd38b620e1e9907216f3e583839dea3}{}\label{namespacetvm_1_1tir_1_1attr_a4bd38b620e1e9907216f3e583839dea3}


Mark the scope as generated by extern primitive. such scope can contain arbitrary ir program and we need to be careful when make certain assumptions about the structure of the program. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!fragment\+\_\+layout@{fragment\+\_\+layout}}
\index{fragment\+\_\+layout@{fragment\+\_\+layout}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{fragment\+\_\+layout}{fragment_layout}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::fragment\+\_\+layout = \char`\"{}fragment\+\_\+layout\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a9b33cc65f756817e691b49782ee103bd}{}\label{namespacetvm_1_1tir_1_1attr_a9b33cc65f756817e691b49782ee103bd}


Mark that the layout of Tensor\+Core fragment. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!fragment\+\_\+shape@{fragment\+\_\+shape}}
\index{fragment\+\_\+shape@{fragment\+\_\+shape}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{fragment\+\_\+shape}{fragment_shape}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::fragment\+\_\+shape = \char`\"{}fragment\+\_\+shape\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a93d76d80fd7252d66991dc650693c0ef}{}\label{namespacetvm_1_1tir_1_1attr_a93d76d80fd7252d66991dc650693c0ef}


Mark that the shape of Tensor\+Core fragment. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!k\+Device\+Thread\+Axis@{k\+Device\+Thread\+Axis}}
\index{k\+Device\+Thread\+Axis@{k\+Device\+Thread\+Axis}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{k\+Device\+Thread\+Axis}{kDeviceThreadAxis}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::k\+Device\+Thread\+Axis = \char`\"{}tir.\+device\+\_\+thread\+\_\+axis\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a4933845b75cf4f08fb66f55fdd94986f}{}\label{namespacetvm_1_1tir_1_1attr_a4933845b75cf4f08fb66f55fdd94986f}


List of thread \hyperlink{classtvm_1_1tir_1_1IterVar}{Iter\+Var} that a Device\+Launch function corresponds to. 

\hyperlink{classtvm_1_1Type}{Type}\+: Array$<$tir\+::\+Iter\+Var$>$

We call a device kernel launch function f using the following convention\+:

Call(f, \mbox{[}arg1, arg2, ..., arg\+\_\+n, work\+\_\+size\+\_\+1, work\+\_\+size\+\_\+2, ... work\+\_\+size\+\_\+m\mbox{]})

Here n = len(arg), m = len(work\+\_\+size) = len(device\+\_\+thread\+\_\+axis).

The list of device\+\_\+thread\+\_\+axis indicates how can be bind the work\+\_\+size arguments to the corresponding threads.

\begin{DoxySeeAlso}{See also}
\hyperlink{namespacetvm_a85e4536ea4e1c8d3d48c61135f0a8ff0aea7c0ea92da6200bb14ea17a6094e2bc}{tvm\+::\+Calling\+Conv\+::k\+Device\+Kernel\+Launch} 
\end{DoxySeeAlso}
\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!k\+Is\+Entry\+Func@{k\+Is\+Entry\+Func}}
\index{k\+Is\+Entry\+Func@{k\+Is\+Entry\+Func}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{k\+Is\+Entry\+Func}{kIsEntryFunc}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::k\+Is\+Entry\+Func = \char`\"{}tir.\+is\+\_\+entry\+\_\+func\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a489d0cebd2820025bc3d6c5a9011cdd4}{}\label{namespacetvm_1_1tir_1_1attr_a489d0cebd2820025bc3d6c5a9011cdd4}


Mark the function as the entry function of the final generated runtime module. 

\hyperlink{classtvm_1_1Type}{Type}\+: \hyperlink{classtvm_1_1Integer}{Integer}

\begin{DoxyNote}{Note}
There can only be one entry function per module. 
\end{DoxyNote}
\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!k\+No\+Alias@{k\+No\+Alias}}
\index{k\+No\+Alias@{k\+No\+Alias}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{k\+No\+Alias}{kNoAlias}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::k\+No\+Alias = \char`\"{}tir.\+noalias\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ac74386674da85bc4b4dd1ee28a97ff63}{}\label{namespacetvm_1_1tir_1_1attr_ac74386674da85bc4b4dd1ee28a97ff63}


Whether to set noalias rule on the function arguments. 

\hyperlink{classtvm_1_1Type}{Type}\+: \hyperlink{classtvm_1_1Integer}{Integer} \index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!loop\+\_\+scope@{loop\+\_\+scope}}
\index{loop\+\_\+scope@{loop\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{loop\+\_\+scope}{loop_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::loop\+\_\+scope = \char`\"{}loop\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a9125ab905a93924ee79269aa808ed517}{}\label{namespacetvm_1_1tir_1_1attr_a9125ab905a93924ee79269aa808ed517}


Mark of loop scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!opengl\+\_\+stage\+\_\+scope@{opengl\+\_\+stage\+\_\+scope}}
\index{opengl\+\_\+stage\+\_\+scope@{opengl\+\_\+stage\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{opengl\+\_\+stage\+\_\+scope}{opengl_stage_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::opengl\+\_\+stage\+\_\+scope = \char`\"{}opengl\+\_\+stage\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ae486f902462321bf26244a9c5b19098c}{}\label{namespacetvm_1_1tir_1_1attr_ae486f902462321bf26244a9c5b19098c}


Mark that this stage is an Open\+GL shader. Since Open\+GL shader only allows writing out to one element of the output texture, the Provide node gets translated to a special Call\+::glsl\+\_\+texture\+\_\+store statement instead of a Store statement. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!pipeline\+\_\+exec\+\_\+scope@{pipeline\+\_\+exec\+\_\+scope}}
\index{pipeline\+\_\+exec\+\_\+scope@{pipeline\+\_\+exec\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{pipeline\+\_\+exec\+\_\+scope}{pipeline_exec_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::pipeline\+\_\+exec\+\_\+scope = \char`\"{}pipeline\+\_\+exec\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_aee14d4d24b86179fd19938a02bc15512}{}\label{namespacetvm_1_1tir_1_1attr_aee14d4d24b86179fd19938a02bc15512}


pipeline execution scope, implies the scope can be pipelined. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!pipeline\+\_\+stage\+\_\+scope@{pipeline\+\_\+stage\+\_\+scope}}
\index{pipeline\+\_\+stage\+\_\+scope@{pipeline\+\_\+stage\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{pipeline\+\_\+stage\+\_\+scope}{pipeline_stage_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::pipeline\+\_\+stage\+\_\+scope = \char`\"{}pipeline\+\_\+stage\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a19ecbf068afc115a2282e533c0fe518d}{}\label{namespacetvm_1_1tir_1_1attr_a19ecbf068afc115a2282e533c0fe518d}


pipeline stage scope, implies always execution 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!pragma\+\_\+import\+\_\+llvm@{pragma\+\_\+import\+\_\+llvm}}
\index{pragma\+\_\+import\+\_\+llvm@{pragma\+\_\+import\+\_\+llvm}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{pragma\+\_\+import\+\_\+llvm}{pragma_import_llvm}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::pragma\+\_\+import\+\_\+llvm = \char`\"{}pragma\+\_\+import\+\_\+llvm\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_af00ba402645b1def7c543af3c48be80d}{}\label{namespacetvm_1_1tir_1_1attr_af00ba402645b1def7c543af3c48be80d}


Import llvm source or file into the final code gen module. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!pragma\+\_\+scope\+\_\+prefix@{pragma\+\_\+scope\+\_\+prefix}}
\index{pragma\+\_\+scope\+\_\+prefix@{pragma\+\_\+scope\+\_\+prefix}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{pragma\+\_\+scope\+\_\+prefix}{pragma_scope_prefix}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::pragma\+\_\+scope\+\_\+prefix = \char`\"{}pragma\+\_\+\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_af08d3d2b645a914f1a64d81e45f3b86a}{}\label{namespacetvm_1_1tir_1_1attr_af08d3d2b645a914f1a64d81e45f3b86a}


Mark region is guarded by the pragma extension. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!pragma\+\_\+tensor\+\_\+core@{pragma\+\_\+tensor\+\_\+core}}
\index{pragma\+\_\+tensor\+\_\+core@{pragma\+\_\+tensor\+\_\+core}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{pragma\+\_\+tensor\+\_\+core}{pragma_tensor_core}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::pragma\+\_\+tensor\+\_\+core = \char`\"{}pragma\+\_\+tensor\+\_\+core\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a96774004fd5b6411f6c37b8923b71834}{}\label{namespacetvm_1_1tir_1_1attr_a96774004fd5b6411f6c37b8923b71834}


Try to modify the A\+ST to support Tensor Core. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!prefetch\+\_\+scope@{prefetch\+\_\+scope}}
\index{prefetch\+\_\+scope@{prefetch\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{prefetch\+\_\+scope}{prefetch_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::prefetch\+\_\+scope = \char`\"{}prefetch\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_ac95fbd1c09a60b10c7a5d07f6c4b68a6}{}\label{namespacetvm_1_1tir_1_1attr_ac95fbd1c09a60b10c7a5d07f6c4b68a6}


Mark of prefetch scope, value=offset, run prefetch of Tensor on the current loop scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!realize\+\_\+scope@{realize\+\_\+scope}}
\index{realize\+\_\+scope@{realize\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{realize\+\_\+scope}{realize_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::realize\+\_\+scope = \char`\"{}realize\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_acf70bbdafa7344811d336422bf95cdc5}{}\label{namespacetvm_1_1tir_1_1attr_acf70bbdafa7344811d336422bf95cdc5}


Mark storage scope of realization. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!reduce\+\_\+scope@{reduce\+\_\+scope}}
\index{reduce\+\_\+scope@{reduce\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{reduce\+\_\+scope}{reduce_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::reduce\+\_\+scope = \char`\"{}reduce\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a50fc9633b9cfbcefa2393dbb2ece1846}{}\label{namespacetvm_1_1tir_1_1attr_a50fc9633b9cfbcefa2393dbb2ece1846}


Mark of reduce scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!scan\+\_\+init\+\_\+scope@{scan\+\_\+init\+\_\+scope}}
\index{scan\+\_\+init\+\_\+scope@{scan\+\_\+init\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{scan\+\_\+init\+\_\+scope}{scan_init_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::scan\+\_\+init\+\_\+scope = \char`\"{}scan\+\_\+init\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_af18e3a9ba11d436e02b55e420647b22b}{}\label{namespacetvm_1_1tir_1_1attr_af18e3a9ba11d436e02b55e420647b22b}


Mark of scan init scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!scan\+\_\+update\+\_\+scope@{scan\+\_\+update\+\_\+scope}}
\index{scan\+\_\+update\+\_\+scope@{scan\+\_\+update\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{scan\+\_\+update\+\_\+scope}{scan_update_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::scan\+\_\+update\+\_\+scope = \char`\"{}scan\+\_\+update\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a84f5d42e968fd8f4cdd7a4aac7ba2137}{}\label{namespacetvm_1_1tir_1_1attr_a84f5d42e968fd8f4cdd7a4aac7ba2137}


Mark of scan update scope. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!storage\+\_\+alignment@{storage\+\_\+alignment}}
\index{storage\+\_\+alignment@{storage\+\_\+alignment}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{storage\+\_\+alignment}{storage_alignment}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::storage\+\_\+alignment = \char`\"{}storage\+\_\+alignment\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_af27d464f2065dc5f77408df7b94d4bb6}{}\label{namespacetvm_1_1tir_1_1attr_af27d464f2065dc5f77408df7b94d4bb6}


Mark storage alignement requirement of buffers. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!storage\+\_\+scope@{storage\+\_\+scope}}
\index{storage\+\_\+scope@{storage\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{storage\+\_\+scope}{storage_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::storage\+\_\+scope = \char`\"{}storage\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a04f015503117e6b781ade61e103b074a}{}\label{namespacetvm_1_1tir_1_1attr_a04f015503117e6b781ade61e103b074a}


Mark storage scope of buffers. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!thread\+\_\+extent@{thread\+\_\+extent}}
\index{thread\+\_\+extent@{thread\+\_\+extent}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{thread\+\_\+extent}{thread_extent}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::thread\+\_\+extent = \char`\"{}thread\+\_\+extent\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a399eed804ecc482a607f0f65f07b78dd}{}\label{namespacetvm_1_1tir_1_1attr_a399eed804ecc482a607f0f65f07b78dd}


Mark launching extent of thread, used by device A\+PI. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!virtual\+\_\+thread@{virtual\+\_\+thread}}
\index{virtual\+\_\+thread@{virtual\+\_\+thread}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{virtual\+\_\+thread}{virtual_thread}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::virtual\+\_\+thread = \char`\"{}virtual\+\_\+thread\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a464533c1560ace5e0b5071ba6902482e}{}\label{namespacetvm_1_1tir_1_1attr_a464533c1560ace5e0b5071ba6902482e}


Mark launching of a virtual thread. 

\index{tvm\+::tir\+::attr@{tvm\+::tir\+::attr}!volatile\+\_\+scope@{volatile\+\_\+scope}}
\index{volatile\+\_\+scope@{volatile\+\_\+scope}!tvm\+::tir\+::attr@{tvm\+::tir\+::attr}}
\subsubsection[{\texorpdfstring{volatile\+\_\+scope}{volatile_scope}}]{\setlength{\rightskip}{0pt plus 5cm}constexpr const char$\ast$ tvm\+::tir\+::attr\+::volatile\+\_\+scope = \char`\"{}volatile\+\_\+scope\char`\"{}}\hypertarget{namespacetvm_1_1tir_1_1attr_a14c2370f3a08792a6aaf70d7a3c773e4}{}\label{namespacetvm_1_1tir_1_1attr_a14c2370f3a08792a6aaf70d7a3c773e4}


Mark the scope as volatile access for certain handle. 

