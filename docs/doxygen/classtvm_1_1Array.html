<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>tvm: tvm::Array&lt; T, typename &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">tvm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetvm.html">tvm</a></li><li class="navelem"><a class="el" href="classtvm_1_1Array.html">Array</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classtvm_1_1Array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tvm::Array&lt; T, typename &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> container of NodeRef in DSL graph. <a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places.  
 <a href="classtvm_1_1Array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="node_2container_8h_source.html">container.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tvm::Array&lt; T, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1Array__inherit__graph.svg" width="210" height="360"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Collaboration diagram for tvm::Array&lt; T, typename &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtvm_1_1Array__coll__graph.svg" width="210" height="360"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtvm_1_1Array_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab85f7f463f8a418f6b4dcffdf43b007c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#ab85f7f463f8a418f6b4dcffdf43b007c">ContainerType</a> = <a class="el" href="classtvm_1_1ArrayNode.html">ArrayNode</a></td></tr>
<tr class="memdesc:ab85f7f463f8a418f6b4dcffdf43b007c"><td class="mdescLeft">&#160;</td><td class="mdescRight">specify container node  <a href="#ab85f7f463f8a418f6b4dcffdf43b007c">More...</a><br /></td></tr>
<tr class="separator:ab85f7f463f8a418f6b4dcffdf43b007c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82550eb5257293ba5af8866aa8ff16e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a> = <a class="el" href="classtvm_1_1IterAdapter.html">IterAdapter</a>&lt; <a class="el" href="structtvm_1_1Array_1_1ValueConverter.html">ValueConverter</a>, std::vector&lt; ObjectRef &gt;::const_iterator &gt;</td></tr>
<tr class="separator:a82550eb5257293ba5af8866aa8ff16e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71ab5c7c8c2abffe81a0ea3842fd1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a> = <a class="el" href="classtvm_1_1IterAdapter.html">IterAdapter</a>&lt; <a class="el" href="structtvm_1_1Array_1_1ValueConverter.html">ValueConverter</a>, std::vector&lt; ObjectRef &gt;::const_reverse_iterator &gt;</td></tr>
<tr class="separator:a6b71ab5c7c8c2abffe81a0ea3842fd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab72ecf006512069d8f791e3cae3eee0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#aab72ecf006512069d8f791e3cae3eee0">Array</a> ()</td></tr>
<tr class="memdesc:aab72ecf006512069d8f791e3cae3eee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#aab72ecf006512069d8f791e3cae3eee0">More...</a><br /></td></tr>
<tr class="separator:aab72ecf006512069d8f791e3cae3eee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ad68bcaefafa48967fa815cdb1e9fe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a42ad68bcaefafa48967fa815cdb1e9fe">Array</a> (<a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a42ad68bcaefafa48967fa815cdb1e9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#a42ad68bcaefafa48967fa815cdb1e9fe">More...</a><br /></td></tr>
<tr class="separator:a42ad68bcaefafa48967fa815cdb1e9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ecf47f2a0bc8dfaddc8da83300deed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a48ecf47f2a0bc8dfaddc8da83300deed">Array</a> (const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a48ecf47f2a0bc8dfaddc8da83300deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a48ecf47f2a0bc8dfaddc8da83300deed">More...</a><br /></td></tr>
<tr class="separator:a48ecf47f2a0bc8dfaddc8da83300deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda937076918f8123b1fc62303a940a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#abda937076918f8123b1fc62303a940a4">Array</a> (ObjectPtr&lt; Object &gt; n)</td></tr>
<tr class="memdesc:abda937076918f8123b1fc62303a940a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from pointer  <a href="#abda937076918f8123b1fc62303a940a4">More...</a><br /></td></tr>
<tr class="separator:abda937076918f8123b1fc62303a940a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e465f5428bc1189dfd6eaf7075bb96f"><td class="memTemplParams" colspan="2">template&lt;typename IterType &gt; </td></tr>
<tr class="memitem:a8e465f5428bc1189dfd6eaf7075bb96f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a8e465f5428bc1189dfd6eaf7075bb96f">Array</a> (IterType <a class="el" href="classtvm_1_1Array.html#a5db0d3faad39ca865162e50d555a25fa">begin</a>, IterType <a class="el" href="classtvm_1_1Array.html#a6f05e6a14eca3ea865da0f293b4a5325">end</a>)</td></tr>
<tr class="memdesc:a8e465f5428bc1189dfd6eaf7075bb96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from iterator  <a href="#a8e465f5428bc1189dfd6eaf7075bb96f">More...</a><br /></td></tr>
<tr class="separator:a8e465f5428bc1189dfd6eaf7075bb96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd4b1d4c96884994152797a15df7343"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a9cd4b1d4c96884994152797a15df7343">Array</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a9cd4b1d4c96884994152797a15df7343"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from initializer list  <a href="#a9cd4b1d4c96884994152797a15df7343">More...</a><br /></td></tr>
<tr class="separator:a9cd4b1d4c96884994152797a15df7343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba9f4611201b6bad1fb46f5944922e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a92ba9f4611201b6bad1fb46f5944922e">Array</a> (const std::vector&lt; T &gt; &amp;init)</td></tr>
<tr class="memdesc:a92ba9f4611201b6bad1fb46f5944922e"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from vector  <a href="#a92ba9f4611201b6bad1fb46f5944922e">More...</a><br /></td></tr>
<tr class="separator:a92ba9f4611201b6bad1fb46f5944922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae409fb0a54ed7fb8c34b7b0445f88802"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#ae409fb0a54ed7fb8c34b7b0445f88802">Array</a> (size_t n, const T &amp;val)</td></tr>
<tr class="memdesc:ae409fb0a54ed7fb8c34b7b0445f88802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a container with n elements. Each element is a copy of val.  <a href="#ae409fb0a54ed7fb8c34b7b0445f88802">More...</a><br /></td></tr>
<tr class="separator:ae409fb0a54ed7fb8c34b7b0445f88802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf66932043c572cb9fec8813dbe5d596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#acf66932043c572cb9fec8813dbe5d596">operator=</a> (<a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:acf66932043c572cb9fec8813dbe5d596"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assign operator  <a href="#acf66932043c572cb9fec8813dbe5d596">More...</a><br /></td></tr>
<tr class="separator:acf66932043c572cb9fec8813dbe5d596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06969623060ee1bb0e82ba7a43513450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a06969623060ee1bb0e82ba7a43513450">operator=</a> (const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="memdesc:a06969623060ee1bb0e82ba7a43513450"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assign operator  <a href="#a06969623060ee1bb0e82ba7a43513450">More...</a><br /></td></tr>
<tr class="separator:a06969623060ee1bb0e82ba7a43513450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eebc9ddbd2e257d0586443b6d493df3"><td class="memTemplParams" colspan="2">template&lt;typename IterType &gt; </td></tr>
<tr class="memitem:a5eebc9ddbd2e257d0586443b6d493df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a5eebc9ddbd2e257d0586443b6d493df3">assign</a> (IterType <a class="el" href="classtvm_1_1Array.html#a5db0d3faad39ca865162e50d555a25fa">begin</a>, IterType <a class="el" href="classtvm_1_1Array.html#a6f05e6a14eca3ea865da0f293b4a5325">end</a>)</td></tr>
<tr class="memdesc:a5eebc9ddbd2e257d0586443b6d493df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the array to content from iterator.  <a href="#a5eebc9ddbd2e257d0586443b6d493df3">More...</a><br /></td></tr>
<tr class="separator:a5eebc9ddbd2e257d0586443b6d493df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed60e692eab1b2511b07a2b20751878"><td class="memItemLeft" align="right" valign="top">const T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#afed60e692eab1b2511b07a2b20751878">operator[]</a> (size_t i) const </td></tr>
<tr class="memdesc:afed60e692eab1b2511b07a2b20751878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read i-th element from array.  <a href="#afed60e692eab1b2511b07a2b20751878">More...</a><br /></td></tr>
<tr class="separator:afed60e692eab1b2511b07a2b20751878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c150ee7d3e46117b099d2052b19aec5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a6c150ee7d3e46117b099d2052b19aec5">size</a> () const </td></tr>
<tr class="separator:a6c150ee7d3e46117b099d2052b19aec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe3653e2bcef7481ab6264f7c231c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1ArrayNode.html">ArrayNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a8ebe3653e2bcef7481ab6264f7c231c8">CopyOnWrite</a> ()</td></tr>
<tr class="memdesc:a8ebe3653e2bcef7481ab6264f7c231c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy on write semantics Do nothing if current handle is the unique copy of the array. Otherwise make a new copy of the array to ensure the current handle hold a unique copy.  <a href="#a8ebe3653e2bcef7481ab6264f7c231c8">More...</a><br /></td></tr>
<tr class="separator:a8ebe3653e2bcef7481ab6264f7c231c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d5ac1f6730d46cb1a6d16729f0a7bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a24d5ac1f6730d46cb1a6d16729f0a7bb">push_back</a> (const T &amp;item)</td></tr>
<tr class="memdesc:a24d5ac1f6730d46cb1a6d16729f0a7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">push a new item to the back of the list  <a href="#a24d5ac1f6730d46cb1a6d16729f0a7bb">More...</a><br /></td></tr>
<tr class="separator:a24d5ac1f6730d46cb1a6d16729f0a7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8303345e666f9c72586721bc067e7fc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a8303345e666f9c72586721bc067e7fc9">resize</a> (size_t <a class="el" href="classtvm_1_1Array.html#a6c150ee7d3e46117b099d2052b19aec5">size</a>)</td></tr>
<tr class="memdesc:a8303345e666f9c72586721bc067e7fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the array.  <a href="#a8303345e666f9c72586721bc067e7fc9">More...</a><br /></td></tr>
<tr class="separator:a8303345e666f9c72586721bc067e7fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3db968deb4be7a51767f22d267eb7af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#ab3db968deb4be7a51767f22d267eb7af">Set</a> (size_t i, const T &amp;value)</td></tr>
<tr class="memdesc:ab3db968deb4be7a51767f22d267eb7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">set i-th element of the array.  <a href="#ab3db968deb4be7a51767f22d267eb7af">More...</a><br /></td></tr>
<tr class="separator:ab3db968deb4be7a51767f22d267eb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531169863918d8464aa4b905d236674f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a531169863918d8464aa4b905d236674f">empty</a> () const </td></tr>
<tr class="separator:a531169863918d8464aa4b905d236674f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb864921139827a886c8fec5b7796041"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:abb864921139827a886c8fec5b7796041"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#abb864921139827a886c8fec5b7796041">MutateByApply</a> (F fmutate)</td></tr>
<tr class="memdesc:abb864921139827a886c8fec5b7796041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to apply fmutate to mutate an array.  <a href="#abb864921139827a886c8fec5b7796041">More...</a><br /></td></tr>
<tr class="separator:abb864921139827a886c8fec5b7796041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db0d3faad39ca865162e50d555a25fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a5db0d3faad39ca865162e50d555a25fa">begin</a> () const </td></tr>
<tr class="separator:a5db0d3faad39ca865162e50d555a25fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05e6a14eca3ea865da0f293b4a5325"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#a6f05e6a14eca3ea865da0f293b4a5325">end</a> () const </td></tr>
<tr class="separator:a6f05e6a14eca3ea865da0f293b4a5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e24a3208ffabbc079db08804a6f602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#ad9e24a3208ffabbc079db08804a6f602">rbegin</a> () const </td></tr>
<tr class="separator:ad9e24a3208ffabbc079db08804a6f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2c5ea9dacd9a1fae22c409a39007b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtvm_1_1Array.html#adc2c5ea9dacd9a1fae22c409a39007b8">rend</a> () const </td></tr>
<tr class="separator:adc2c5ea9dacd9a1fae22c409a39007b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt;<br />
class tvm::Array&lt; T, typename &gt;</h3>

<p><a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> container of NodeRef in DSL graph. <a class="el" href="classtvm_1_1Array.html" title="Array container of NodeRef in DSL graph. Array implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. ">Array</a> implements copy on write semantics, which means array is mutable but copy will happen when array is referenced in more than two places. </p>
<p>operator[] only provide const acces, use Set to mutate the content. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The content NodeRef type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab85f7f463f8a418f6b4dcffdf43b007c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html#ab85f7f463f8a418f6b4dcffdf43b007c">ContainerType</a> =  <a class="el" href="classtvm_1_1ArrayNode.html">ArrayNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>specify container node </p>

</div>
</div>
<a class="anchor" id="a82550eb5257293ba5af8866aa8ff16e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a> =  <a class="el" href="classtvm_1_1IterAdapter.html">IterAdapter</a>&lt;<a class="el" href="structtvm_1_1Array_1_1ValueConverter.html">ValueConverter</a>, std::vector&lt;ObjectRef&gt;::const_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b71ab5c7c8c2abffe81a0ea3842fd1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a> =  <a class="el" href="classtvm_1_1IterAdapter.html">IterAdapter</a>&lt; <a class="el" href="structtvm_1_1Array_1_1ValueConverter.html">ValueConverter</a>, std::vector&lt;ObjectRef&gt;::const_reverse_iterator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aab72ecf006512069d8f791e3cae3eee0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a class="anchor" id="a42ad68bcaefafa48967fa815cdb1e9fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48ecf47f2a0bc8dfaddc8da83300deed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abda937076918f8123b1fc62303a940a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">ObjectPtr&lt; Object &gt;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from pointer </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the container pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e465f5428bc1189dfd6eaf7075bb96f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from iterator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>begin of iterator </td></tr>
    <tr><td class="paramname">end</td><td>end of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterType</td><td>The type of iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cd4b1d4c96884994152797a15df7343"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from initializer list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initalizer list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92ba9f4611201b6bad1fb46f5944922e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae409fb0a54ed7fb8c34b7b0445f88802"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::<a class="el" href="classtvm_1_1Array.html">Array</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a container with n elements. Each element is a copy of val. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The size of the container </td></tr>
    <tr><td class="paramname">val</td><td>The init value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5eebc9ddbd2e257d0586443b6d493df3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename IterType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IterType&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset the array to content from iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>begin of iterator </td></tr>
    <tr><td class="paramname">end</td><td>end of iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterType</td><td>The type of iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5db0d3faad39ca865162e50d555a25fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a> <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>begin iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a8ebe3653e2bcef7481ab6264f7c231c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1ArrayNode.html">ArrayNode</a>* <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::CopyOnWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy on write semantics Do nothing if current handle is the unique copy of the array. Otherwise make a new copy of the array to ensure the current handle hold a unique copy. </p>
<dl class="section return"><dt>Returns</dt><dd>Handle to the internal node container(which ganrantees to be unique) </dd></dl>

</div>
</div>
<a class="anchor" id="a531169863918d8464aa4b905d236674f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether array is empty </dd></dl>

</div>
</div>
<a class="anchor" id="a6f05e6a14eca3ea865da0f293b4a5325"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html#a82550eb5257293ba5af8866aa8ff16e6">iterator</a> <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>end iterator </dd></dl>

</div>
</div>
<a class="anchor" id="abb864921139827a886c8fec5b7796041"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::MutateByApply </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>fmutate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to apply fmutate to mutate an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmutate</td><td>The transformation function T -&gt; T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>the type of the mutation function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function performs copy on write optimization. </dd></dl>

</div>
</div>
<a class="anchor" id="acf66932043c572cb9fec8813dbe5d596"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assign operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source of assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to self. </dd></dl>

</div>
</div>
<a class="anchor" id="a06969623060ee1bb0e82ba7a43513450"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html">Array</a>&lt;T&gt;&amp; <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtvm_1_1Array.html">Array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assign operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The source of assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to self. </dd></dl>

</div>
</div>
<a class="anchor" id="afed60e692eab1b2511b07a2b20751878"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read i-th element from array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i-th element. </dd></dl>

</div>
</div>
<a class="anchor" id="a24d5ac1f6730d46cb1a6d16729f0a7bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>push a new item to the back of the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to be pushed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9e24a3208ffabbc079db08804a6f602"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a> <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>rbegin iterator </dd></dl>

</div>
</div>
<a class="anchor" id="adc2c5ea9dacd9a1fae22c409a39007b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtvm_1_1Array.html#a6b71ab5c7c8c2abffe81a0ea3842fd1a">reverse_iterator</a> <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>rend iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a8303345e666f9c72586721bc067e7fc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3db968deb4be7a51767f22d267eb7af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::Set </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set i-th element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index </td></tr>
    <tr><td class="paramname">value</td><td>The value to be setted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c150ee7d3e46117b099d2052b19aec5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename  = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, T&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classtvm_1_1Array.html">tvm::Array</a>&lt; T, typename &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The size of the array </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/tvm/node/<a class="el" href="node_2container_8h_source.html">container.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
